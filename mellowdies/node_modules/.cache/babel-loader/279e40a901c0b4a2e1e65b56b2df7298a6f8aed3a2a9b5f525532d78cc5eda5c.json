{"ast":null,"code":"import WaveSurfer from 'wavesurfer.js';\nexport function sliceAudio(waveSurferInstance, startTime, endTime) {\n  // Get the original buffer from the waveSurfer instance\n  const audioBuffer = waveSurferInstance.backend.buffer;\n\n  // Calculate the sample indices for slicing\n  const startSample = Math.floor(startTime * audioBuffer.sampleRate);\n  const endSample = Math.floor(endTime * audioBuffer.sampleRate);\n\n  // Slice the buffer\n  const slicedBuffer = audioBuffer.slice(startSample, endSample);\n\n  // Update the waveSurfer instance with the new sliced buffer\n  waveSurferInstance.backend.setBuffer(slicedBuffer);\n  waveSurferInstance.drawBuffer();\n}\nexport function deleteAudioSection(waveSurferInstance, startTime, endTime) {\n  const audioBuffer = waveSurferInstance.backend.buffer;\n  const startSample = Math.floor(startTime * audioBuffer.sampleRate);\n  const endSample = Math.floor(endTime * audioBuffer.sampleRate);\n  const beforeSlice = audioBuffer.slice(0, startSample);\n  const afterSlice = audioBuffer.slice(endSample);\n\n  // Concatenate the before and after parts to delete the selected section\n  const newBuffer = concatAudioBuffers(beforeSlice, afterSlice);\n\n  // Update the waveSurfer instance\n  waveSurferInstance.backend.setBuffer(newBuffer);\n  waveSurferInstance.drawBuffer();\n}\nfunction concatAudioBuffers(buffer1, buffer2) {\n  const numberOfChannels = buffer1.numberOfChannels;\n  const newBufferLength = buffer1.length + buffer2.length;\n  const newBuffer = new AudioBuffer({\n    length: newBufferLength,\n    numberOfChannels: numberOfChannels,\n    sampleRate: buffer1.sampleRate\n  });\n\n  // Copy buffer1 into the new buffer\n  for (let channel = 0; channel < numberOfChannels; channel++) {\n    newBuffer.copyToChannel(buffer1.getChannelData(channel), channel);\n    newBuffer.copyToChannel(buffer2.getChannelData(channel), channel, buffer1.length);\n  }\n  return newBuffer;\n}\nexport function handleTrackClick(waveSurferInstance, clickPosition) {\n  // Example of what you could do on track click\n  const duration = waveSurferInstance.getDuration();\n  const clickedTime = clickPosition * duration; // clickPosition is normalized between 0 and 1\n  waveSurferInstance.seekTo(clickPosition);\n}","map":{"version":3,"names":["WaveSurfer","sliceAudio","waveSurferInstance","startTime","endTime","audioBuffer","backend","buffer","startSample","Math","floor","sampleRate","endSample","slicedBuffer","slice","setBuffer","drawBuffer","deleteAudioSection","beforeSlice","afterSlice","newBuffer","concatAudioBuffers","buffer1","buffer2","numberOfChannels","newBufferLength","length","AudioBuffer","channel","copyToChannel","getChannelData","handleTrackClick","clickPosition","duration","getDuration","clickedTime","seekTo"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/src/Landingpage/Audiotrack.js"],"sourcesContent":["import WaveSurfer from 'wavesurfer.js';\r\n\r\nexport function sliceAudio(waveSurferInstance, startTime, endTime) {\r\n    // Get the original buffer from the waveSurfer instance\r\n    const audioBuffer = waveSurferInstance.backend.buffer;\r\n\r\n    // Calculate the sample indices for slicing\r\n    const startSample = Math.floor(startTime * audioBuffer.sampleRate);\r\n    const endSample = Math.floor(endTime * audioBuffer.sampleRate);\r\n\r\n    // Slice the buffer\r\n    const slicedBuffer = audioBuffer.slice(startSample, endSample);\r\n\r\n    // Update the waveSurfer instance with the new sliced buffer\r\n    waveSurferInstance.backend.setBuffer(slicedBuffer);\r\n    waveSurferInstance.drawBuffer();\r\n}\r\n\r\nexport function deleteAudioSection(waveSurferInstance, startTime, endTime) {\r\n    const audioBuffer = waveSurferInstance.backend.buffer;\r\n\r\n    const startSample = Math.floor(startTime * audioBuffer.sampleRate);\r\n    const endSample = Math.floor(endTime * audioBuffer.sampleRate);\r\n\r\n    const beforeSlice = audioBuffer.slice(0, startSample);\r\n    const afterSlice = audioBuffer.slice(endSample);\r\n\r\n    // Concatenate the before and after parts to delete the selected section\r\n    const newBuffer = concatAudioBuffers(beforeSlice, afterSlice);\r\n\r\n    // Update the waveSurfer instance\r\n    waveSurferInstance.backend.setBuffer(newBuffer);\r\n    waveSurferInstance.drawBuffer();\r\n}\r\n\r\nfunction concatAudioBuffers(buffer1, buffer2) {\r\n    const numberOfChannels = buffer1.numberOfChannels;\r\n    const newBufferLength = buffer1.length + buffer2.length;\r\n    const newBuffer = new AudioBuffer({\r\n        length: newBufferLength,\r\n        numberOfChannels: numberOfChannels,\r\n        sampleRate: buffer1.sampleRate\r\n    });\r\n\r\n    // Copy buffer1 into the new buffer\r\n    for (let channel = 0; channel < numberOfChannels; channel++) {\r\n        newBuffer.copyToChannel(buffer1.getChannelData(channel), channel);\r\n        newBuffer.copyToChannel(buffer2.getChannelData(channel), channel, buffer1.length);\r\n    }\r\n\r\n    return newBuffer;\r\n}\r\n\r\nexport function handleTrackClick(waveSurferInstance, clickPosition) {\r\n    // Example of what you could do on track click\r\n    const duration = waveSurferInstance.getDuration();\r\n    const clickedTime = clickPosition * duration; // clickPosition is normalized between 0 and 1\r\n    waveSurferInstance.seekTo(clickPosition);\r\n}\r\n\r\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,eAAe;AAEtC,OAAO,SAASC,UAAUA,CAACC,kBAAkB,EAAEC,SAAS,EAAEC,OAAO,EAAE;EAC/D;EACA,MAAMC,WAAW,GAAGH,kBAAkB,CAACI,OAAO,CAACC,MAAM;;EAErD;EACA,MAAMC,WAAW,GAAGC,IAAI,CAACC,KAAK,CAACP,SAAS,GAAGE,WAAW,CAACM,UAAU,CAAC;EAClE,MAAMC,SAAS,GAAGH,IAAI,CAACC,KAAK,CAACN,OAAO,GAAGC,WAAW,CAACM,UAAU,CAAC;;EAE9D;EACA,MAAME,YAAY,GAAGR,WAAW,CAACS,KAAK,CAACN,WAAW,EAAEI,SAAS,CAAC;;EAE9D;EACAV,kBAAkB,CAACI,OAAO,CAACS,SAAS,CAACF,YAAY,CAAC;EAClDX,kBAAkB,CAACc,UAAU,CAAC,CAAC;AACnC;AAEA,OAAO,SAASC,kBAAkBA,CAACf,kBAAkB,EAAEC,SAAS,EAAEC,OAAO,EAAE;EACvE,MAAMC,WAAW,GAAGH,kBAAkB,CAACI,OAAO,CAACC,MAAM;EAErD,MAAMC,WAAW,GAAGC,IAAI,CAACC,KAAK,CAACP,SAAS,GAAGE,WAAW,CAACM,UAAU,CAAC;EAClE,MAAMC,SAAS,GAAGH,IAAI,CAACC,KAAK,CAACN,OAAO,GAAGC,WAAW,CAACM,UAAU,CAAC;EAE9D,MAAMO,WAAW,GAAGb,WAAW,CAACS,KAAK,CAAC,CAAC,EAAEN,WAAW,CAAC;EACrD,MAAMW,UAAU,GAAGd,WAAW,CAACS,KAAK,CAACF,SAAS,CAAC;;EAE/C;EACA,MAAMQ,SAAS,GAAGC,kBAAkB,CAACH,WAAW,EAAEC,UAAU,CAAC;;EAE7D;EACAjB,kBAAkB,CAACI,OAAO,CAACS,SAAS,CAACK,SAAS,CAAC;EAC/ClB,kBAAkB,CAACc,UAAU,CAAC,CAAC;AACnC;AAEA,SAASK,kBAAkBA,CAACC,OAAO,EAAEC,OAAO,EAAE;EAC1C,MAAMC,gBAAgB,GAAGF,OAAO,CAACE,gBAAgB;EACjD,MAAMC,eAAe,GAAGH,OAAO,CAACI,MAAM,GAAGH,OAAO,CAACG,MAAM;EACvD,MAAMN,SAAS,GAAG,IAAIO,WAAW,CAAC;IAC9BD,MAAM,EAAED,eAAe;IACvBD,gBAAgB,EAAEA,gBAAgB;IAClCb,UAAU,EAAEW,OAAO,CAACX;EACxB,CAAC,CAAC;;EAEF;EACA,KAAK,IAAIiB,OAAO,GAAG,CAAC,EAAEA,OAAO,GAAGJ,gBAAgB,EAAEI,OAAO,EAAE,EAAE;IACzDR,SAAS,CAACS,aAAa,CAACP,OAAO,CAACQ,cAAc,CAACF,OAAO,CAAC,EAAEA,OAAO,CAAC;IACjER,SAAS,CAACS,aAAa,CAACN,OAAO,CAACO,cAAc,CAACF,OAAO,CAAC,EAAEA,OAAO,EAAEN,OAAO,CAACI,MAAM,CAAC;EACrF;EAEA,OAAON,SAAS;AACpB;AAEA,OAAO,SAASW,gBAAgBA,CAAC7B,kBAAkB,EAAE8B,aAAa,EAAE;EAChE;EACA,MAAMC,QAAQ,GAAG/B,kBAAkB,CAACgC,WAAW,CAAC,CAAC;EACjD,MAAMC,WAAW,GAAGH,aAAa,GAAGC,QAAQ,CAAC,CAAC;EAC9C/B,kBAAkB,CAACkC,MAAM,CAACJ,aAAa,CAAC;AAC5C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}