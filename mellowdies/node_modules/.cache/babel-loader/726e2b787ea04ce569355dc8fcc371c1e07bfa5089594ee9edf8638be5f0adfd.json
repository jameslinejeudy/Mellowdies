{"ast":null,"code":"/**\r\n * @module pcm-convert\r\n */\n'use strict';\n\nvar assert = require('assert');\nvar isBuffer = require('is-buffer');\nvar format = require('audio-format');\nvar extend = require('object-assign');\nvar isAudioBuffer = require('is-audio-buffer');\nmodule.exports = convert;\nfunction convert(buffer, from, to, target) {\n  assert(buffer, 'First argument should be data');\n  assert(from, 'Second argument should be format string or object');\n\n  //quick ignore\n  if (from === to) {\n    return buffer;\n  }\n\n  //2-containers case\n  if (isContainer(from)) {\n    target = from;\n    to = format.detect(target);\n    from = format.detect(buffer);\n  }\n  //if no source format defined, just target format\n  else if (to === undefined && target === undefined) {\n    to = getFormat(from);\n    from = format.detect(buffer);\n  }\n  //if no source format but container is passed with from as target format\n  else if (isContainer(to)) {\n    target = to;\n    to = getFormat(from);\n    from = format.detect(buffer);\n  }\n  //all arguments\n  else {\n    var inFormat = getFormat(from);\n    var srcFormat = format.detect(buffer);\n    srcFormat.dtype = inFormat.type === 'arraybuffer' ? srcFormat.type : inFormat.type;\n    from = extend(inFormat, srcFormat);\n    var outFormat = getFormat(to);\n    var dstFormat = format.detect(target);\n    if (outFormat.type) {\n      dstFormat.dtype = outFormat.type === 'arraybuffer' ? dstFormat.type || from.dtype : outFormat.type;\n    }\n    to = extend(outFormat, dstFormat);\n  }\n  if (to.channels == null && from.channels != null) {\n    to.channels = from.channels;\n  }\n  if (to.type == null) {\n    to.type = from.type;\n    to.dtype = from.dtype;\n  }\n  if (to.interleaved != null && from.channels == null) {\n    from.channels = 2;\n  }\n\n  //ignore same format\n  if (from.type === to.type && from.interleaved === to.interleaved && from.endianness === to.endianness) return buffer;\n  normalize(from);\n  normalize(to);\n\n  //audio-buffer-list/audio types\n  if (buffer.buffers || buffer.buffer && buffer.buffer.buffers) {\n    //handle audio\n    if (buffer.buffer) buffer = buffer.buffer;\n\n    //handle audiobufferlist\n    if (buffer.buffers) buffer = buffer.join();\n  }\n  var src;\n  //convert buffer/alike to arrayBuffer\n  if (isAudioBuffer(buffer)) {\n    if (buffer._data) src = buffer._data;else {\n      src = new Float32Array(buffer.length * buffer.numberOfChannels);\n      for (var c = 0, l = buffer.numberOfChannels; c < l; c++) {\n        src.set(buffer.getChannelData(c), buffer.length * c);\n      }\n    }\n  } else if (buffer instanceof ArrayBuffer) {\n    src = new dtypeClass[from.dtype](buffer);\n  } else if (isBuffer(buffer)) {\n    if (buffer.byteOffset != null) src = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);else src = buffer.buffer;\n    src = new dtypeClass[from.dtype](src);\n  }\n  //typed arrays are unchanged as is\n  else {\n    src = buffer;\n  }\n\n  //dst is automatically filled with mapped values\n  //but in some cases mapped badly, e. g. float → int(round + rotate)\n  var dst = to.type === 'array' ? Array.from(src) : new dtypeClass[to.dtype](src);\n\n  //if range differ, we should apply more thoughtful mapping\n  if (from.max !== to.max) {\n    var fromRange = from.max - from.min,\n      toRange = to.max - to.min;\n    for (var i = 0, l = src.length; i < l; i++) {\n      var value = src[i];\n\n      //ignore not changed range\n      //bring to 0..1\n      var normalValue = (value - from.min) / fromRange;\n\n      //bring to new format ranges\n      value = normalValue * toRange + to.min;\n\n      //clamp (buffers do not like values outside of bounds)\n      dst[i] = Math.max(to.min, Math.min(to.max, value));\n    }\n  }\n\n  //reinterleave, if required\n  if (from.interleaved != to.interleaved) {\n    var channels = from.channels;\n    var len = Math.floor(src.length / channels);\n\n    //deinterleave\n    if (from.interleaved && !to.interleaved) {\n      dst = dst.map(function (value, idx, data) {\n        var offset = idx % len;\n        var channel = ~~(idx / len);\n        return data[offset * channels + channel];\n      });\n    }\n    //interleave\n    else if (!from.interleaved && to.interleaved) {\n      dst = dst.map(function (value, idx, data) {\n        var offset = ~~(idx / channels);\n        var channel = idx % channels;\n        return data[channel * len + offset];\n      });\n    }\n  }\n\n  //ensure endianness\n  if (to.dtype != 'array' && to.dtype != 'int8' && to.dtype != 'uint8' && from.endianness && to.endianness && from.endianness !== to.endianness) {\n    var le = to.endianness === 'le';\n    var view = new DataView(dst.buffer);\n    var step = dst.BYTES_PER_ELEMENT;\n    var methodName = 'set' + to.dtype[0].toUpperCase() + to.dtype.slice(1);\n    for (var i = 0, l = dst.length; i < l; i++) {\n      view[methodName](i * step, dst[i], le);\n    }\n  }\n  if (to.type === 'audiobuffer') {\n    //TODO\n  }\n  if (target) {\n    if (Array.isArray(target)) {\n      for (var i = 0; i < dst.length; i++) {\n        target[i] = dst[i];\n      }\n    } else if (target instanceof ArrayBuffer) {\n      var targetContainer = new dtypeClass[to.dtype](target);\n      targetContainer.set(dst);\n      target = targetContainer;\n    } else {\n      target.set(dst);\n    }\n    dst = target;\n  }\n  if (to.type === 'arraybuffer' || to.type === 'buffer') dst = dst.buffer;\n  return dst;\n}\nfunction getFormat(arg) {\n  return typeof arg === 'string' ? format.parse(arg) : format.detect(arg);\n}\nfunction isContainer(arg) {\n  return typeof arg != 'string' && (Array.isArray(arg) || ArrayBuffer.isView(arg) || arg instanceof ArrayBuffer);\n}\nvar dtypeClass = {\n  'uint8': Uint8Array,\n  'uint8_clamped': Uint8ClampedArray,\n  'uint16': Uint16Array,\n  'uint32': Uint32Array,\n  'int8': Int8Array,\n  'int16': Int16Array,\n  'int32': Int32Array,\n  'float32': Float32Array,\n  'float64': Float64Array,\n  'array': Array,\n  'arraybuffer': Uint8Array,\n  'buffer': Uint8Array\n};\nvar defaultDtype = {\n  'float32': 'float32',\n  'audiobuffer': 'float32',\n  'ndsamples': 'float32',\n  'ndarray': 'float32',\n  'float64': 'float64',\n  'buffer': 'uint8',\n  'arraybuffer': 'uint8',\n  'uint8': 'uint8',\n  'uint8_clamped': 'uint8',\n  'uint16': 'uint16',\n  'uint32': 'uint32',\n  'int8': 'int8',\n  'int16': 'int16',\n  'int32': 'int32',\n  'array': 'array'\n};\n\n//make sure all format properties are present\nfunction normalize(obj) {\n  if (!obj.dtype) {\n    obj.dtype = defaultDtype[obj.type] || 'array';\n  }\n\n  //provide limits\n  switch (obj.dtype) {\n    case 'float32':\n    case 'float64':\n    case 'audiobuffer':\n    case 'ndsamples':\n    case 'ndarray':\n      obj.min = -1;\n      obj.max = 1;\n      break;\n    case 'uint8':\n      obj.min = 0;\n      obj.max = 255;\n      break;\n    case 'uint16':\n      obj.min = 0;\n      obj.max = 65535;\n      break;\n    case 'uint32':\n      obj.min = 0;\n      obj.max = 4294967295;\n      break;\n    case 'int8':\n      obj.min = -128;\n      obj.max = 127;\n      break;\n    case 'int16':\n      obj.min = -32768;\n      obj.max = 32767;\n      break;\n    case 'int32':\n      obj.min = -2147483648;\n      obj.max = 2147483647;\n      break;\n    default:\n      obj.min = -1;\n      obj.max = 1;\n      break;\n  }\n  return obj;\n}","map":{"version":3,"names":["assert","require","isBuffer","format","extend","isAudioBuffer","module","exports","convert","buffer","from","to","target","isContainer","detect","undefined","getFormat","inFormat","srcFormat","dtype","type","outFormat","dstFormat","channels","interleaved","endianness","normalize","buffers","join","src","_data","Float32Array","length","numberOfChannels","c","l","set","getChannelData","ArrayBuffer","dtypeClass","byteOffset","slice","byteLength","dst","Array","max","fromRange","min","toRange","i","value","normalValue","Math","len","floor","map","idx","data","offset","channel","le","view","DataView","step","BYTES_PER_ELEMENT","methodName","toUpperCase","isArray","targetContainer","arg","parse","isView","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","Int8Array","Int16Array","Int32Array","Float64Array","defaultDtype","obj"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/pcm-convert/index.js"],"sourcesContent":["/**\r\n * @module pcm-convert\r\n */\r\n'use strict'\r\n\r\nvar assert = require('assert')\r\nvar isBuffer = require('is-buffer')\r\nvar format = require('audio-format')\r\nvar extend = require('object-assign')\r\nvar isAudioBuffer = require('is-audio-buffer')\r\n\r\nmodule.exports = convert\r\n\r\nfunction convert (buffer, from, to, target) {\r\n\tassert(buffer, 'First argument should be data')\r\n\tassert(from, 'Second argument should be format string or object')\r\n\r\n\t//quick ignore\r\n\tif (from === to) {\r\n\t\treturn buffer\r\n\t}\r\n\r\n\t//2-containers case\r\n\tif (isContainer(from)) {\r\n\t\ttarget = from\r\n\t\tto = format.detect(target)\r\n\t\tfrom = format.detect(buffer)\r\n\t}\r\n\t//if no source format defined, just target format\r\n\telse if (to === undefined && target === undefined) {\r\n\t\tto = getFormat(from)\r\n\t\tfrom = format.detect(buffer)\r\n\t}\r\n\t//if no source format but container is passed with from as target format\r\n\telse if (isContainer(to)) {\r\n\t\ttarget = to\r\n\t\tto = getFormat(from)\r\n\t\tfrom = format.detect(buffer)\r\n\t}\r\n\t//all arguments\r\n\telse {\r\n\t\tvar inFormat = getFormat(from)\r\n\t\tvar srcFormat = format.detect(buffer)\r\n\t\tsrcFormat.dtype = inFormat.type === 'arraybuffer' ? srcFormat.type : inFormat.type\r\n\t\tfrom = extend(inFormat, srcFormat)\r\n\r\n\t\tvar outFormat = getFormat(to)\r\n\t\tvar dstFormat = format.detect(target)\r\n\t\tif (outFormat.type) {\r\n\t\t\tdstFormat.dtype = outFormat.type === 'arraybuffer' ? (dstFormat.type || from.dtype) : outFormat.type\r\n\t\t}\r\n\t\tto = extend(outFormat, dstFormat)\r\n\t}\r\n\r\n\tif (to.channels == null && from.channels != null) {\r\n\t\tto.channels = from.channels\r\n\t}\r\n\r\n\tif (to.type == null) {\r\n\t\tto.type = from.type\r\n\t\tto.dtype = from.dtype\r\n\t}\r\n\r\n\tif (to.interleaved != null && from.channels == null) {\r\n\t\tfrom.channels = 2\r\n\t}\r\n\r\n\t//ignore same format\r\n\tif (from.type === to.type &&\r\n\t\tfrom.interleaved === to.interleaved &&\r\n\t\tfrom.endianness === to.endianness) return buffer\r\n\r\n\tnormalize(from)\r\n\tnormalize(to)\r\n\r\n\t//audio-buffer-list/audio types\r\n\tif (buffer.buffers || (buffer.buffer && buffer.buffer.buffers)) {\r\n\t\t//handle audio\r\n\t\tif (buffer.buffer) buffer = buffer.buffer\r\n\r\n\t\t//handle audiobufferlist\r\n\t\tif (buffer.buffers) buffer = buffer.join()\r\n\t}\r\n\r\n\tvar src\r\n\t//convert buffer/alike to arrayBuffer\r\n\tif (isAudioBuffer(buffer)) {\r\n\t\tif (buffer._data) src = buffer._data\r\n\t\telse {\r\n\t\t\tsrc = new Float32Array(buffer.length * buffer.numberOfChannels)\r\n\t\t\tfor (var c = 0, l = buffer.numberOfChannels; c < l; c++) {\r\n\t\t\t\tsrc.set(buffer.getChannelData(c), buffer.length * c)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse if (buffer instanceof ArrayBuffer) {\r\n\t\tsrc = new (dtypeClass[from.dtype])(buffer)\r\n\t}\r\n\telse if (isBuffer(buffer)) {\r\n\t\tif (buffer.byteOffset != null) src = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\r\n\t\telse src = buffer.buffer;\r\n\r\n\t\tsrc = new (dtypeClass[from.dtype])(src)\r\n\t}\r\n\t//typed arrays are unchanged as is\r\n\telse {\r\n\t\tsrc = buffer\r\n\t}\r\n\r\n\t//dst is automatically filled with mapped values\r\n\t//but in some cases mapped badly, e. g. float → int(round + rotate)\r\n\tvar dst = to.type === 'array' ? Array.from(src) : new (dtypeClass[to.dtype])(src)\r\n\r\n\t//if range differ, we should apply more thoughtful mapping\r\n\tif (from.max !== to.max) {\r\n\t\tvar fromRange = from.max - from.min, toRange = to.max - to.min\r\n\t\tfor (var i = 0, l = src.length; i < l; i++) {\r\n\t\t\tvar value = src[i]\r\n\r\n\t\t\t//ignore not changed range\r\n\t\t\t//bring to 0..1\r\n\t\t\tvar normalValue = (value - from.min) / fromRange\r\n\r\n\t\t\t//bring to new format ranges\r\n\t\t\tvalue = normalValue * toRange + to.min\r\n\r\n\t\t\t//clamp (buffers do not like values outside of bounds)\r\n\t\t\tdst[i] = Math.max(to.min, Math.min(to.max, value))\r\n\t\t}\r\n\t}\r\n\r\n\t//reinterleave, if required\r\n\tif (from.interleaved != to.interleaved) {\r\n\t\tvar channels = from.channels\r\n\t\tvar len = Math.floor(src.length / channels)\r\n\r\n\t\t//deinterleave\r\n\t\tif (from.interleaved && !to.interleaved) {\r\n\t\t\tdst = dst.map(function (value, idx, data) {\r\n\t\t\t\tvar offset = idx % len\r\n\t\t\t\tvar channel = ~~(idx / len)\r\n\r\n\t\t\t\treturn data[offset * channels + channel]\r\n\t\t\t})\r\n\t\t}\r\n\t\t//interleave\r\n\t\telse if (!from.interleaved && to.interleaved) {\r\n\t\t\tdst = dst.map(function (value, idx, data) {\r\n\t\t\t\tvar offset = ~~(idx / channels)\r\n\t\t\t\tvar channel = idx % channels\r\n\r\n\t\t\t\treturn data[channel * len + offset]\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\t//ensure endianness\r\n\tif (to.dtype != 'array' && to.dtype != 'int8' && to.dtype != 'uint8' && from.endianness && to.endianness && from.endianness !== to.endianness) {\r\n\t\tvar le = to.endianness === 'le'\r\n\t\tvar view = new DataView(dst.buffer)\r\n\t\tvar step = dst.BYTES_PER_ELEMENT\r\n\t\tvar methodName = 'set' + to.dtype[0].toUpperCase() + to.dtype.slice(1)\r\n\t\tfor (var i = 0, l = dst.length; i < l; i++) {\r\n\t\t\tview[methodName](i*step, dst[i], le)\r\n\t\t}\r\n\t}\r\n\r\n\tif (to.type === 'audiobuffer') {\r\n\t\t//TODO\r\n\t}\r\n\r\n\r\n\tif (target) {\r\n\t\tif (Array.isArray(target)) {\r\n\t\t\tfor (var i = 0; i < dst.length; i++) {\r\n\t\t\t\ttarget[i] = dst[i]\r\n\t\t\t}\r\n\t\t}\r\n\t\telse if (target instanceof ArrayBuffer) {\r\n\t\t\tvar\r\n\t\t\ttargetContainer = new dtypeClass[to.dtype](target)\r\n\t\t\ttargetContainer.set(dst)\r\n\t\t\ttarget = targetContainer\r\n\t\t}\r\n\t\telse {\r\n\t\t\ttarget.set(dst)\r\n\t\t}\r\n\t\tdst = target\r\n\t}\r\n\r\n\tif (to.type === 'arraybuffer' || to.type === 'buffer') dst = dst.buffer\r\n\r\n\treturn dst\r\n}\r\n\r\nfunction getFormat (arg) {\r\n\treturn typeof arg === 'string' ? format.parse(arg) : format.detect(arg)\r\n}\r\n\r\nfunction isContainer (arg) {\r\n\treturn typeof arg != 'string' && (Array.isArray(arg) || ArrayBuffer.isView(arg) || arg instanceof ArrayBuffer)\r\n}\r\n\r\n\r\nvar dtypeClass = {\r\n\t'uint8': Uint8Array,\r\n\t'uint8_clamped': Uint8ClampedArray,\r\n\t'uint16': Uint16Array,\r\n\t'uint32': Uint32Array,\r\n\t'int8': Int8Array,\r\n\t'int16': Int16Array,\r\n\t'int32': Int32Array,\r\n\t'float32': Float32Array,\r\n\t'float64': Float64Array,\r\n\t'array': Array,\r\n\t'arraybuffer': Uint8Array,\r\n\t'buffer': Uint8Array,\r\n}\r\n\r\nvar defaultDtype = {\r\n\t'float32': 'float32',\r\n\t'audiobuffer': 'float32',\r\n\t'ndsamples': 'float32',\r\n\t'ndarray': 'float32',\r\n\t'float64': 'float64',\r\n\t'buffer': 'uint8',\r\n\t'arraybuffer': 'uint8',\r\n\t'uint8': 'uint8',\r\n\t'uint8_clamped': 'uint8',\r\n\t'uint16': 'uint16',\r\n\t'uint32': 'uint32',\r\n\t'int8': 'int8',\r\n\t'int16': 'int16',\r\n\t'int32': 'int32',\r\n\t'array': 'array'\r\n}\r\n\r\n//make sure all format properties are present\r\nfunction normalize (obj) {\r\n\tif (!obj.dtype) {\r\n\t\tobj.dtype = defaultDtype[obj.type] || 'array'\r\n\t}\r\n\r\n\t//provide limits\r\n\tswitch (obj.dtype) {\r\n\t\tcase 'float32':\r\n\t\tcase 'float64':\r\n\t\tcase 'audiobuffer':\r\n\t\tcase 'ndsamples':\r\n\t\tcase 'ndarray':\r\n\t\t\tobj.min = -1\r\n\t\t\tobj.max = 1\r\n\t\t\tbreak;\r\n\t\tcase 'uint8':\r\n\t\t\tobj.min = 0\r\n\t\t\tobj.max = 255\r\n\t\t\tbreak;\r\n\t\tcase 'uint16':\r\n\t\t\tobj.min = 0\r\n\t\t\tobj.max = 65535\r\n\t\t\tbreak;\r\n\t\tcase 'uint32':\r\n\t\t\tobj.min = 0\r\n\t\t\tobj.max = 4294967295\r\n\t\t\tbreak;\r\n\t\tcase 'int8':\r\n\t\t\tobj.min = -128\r\n\t\t\tobj.max = 127\r\n\t\t\tbreak;\r\n\t\tcase 'int16':\r\n\t\t\tobj.min = -32768\r\n\t\t\tobj.max = 32767\r\n\t\t\tbreak;\r\n\t\tcase 'int32':\r\n\t\t\tobj.min = -2147483648\r\n\t\t\tobj.max = 2147483647\r\n\t\t\tbreak;\r\n\t\tdefault:\r\n\t\t\tobj.min = -1\r\n\t\t\tobj.max = 1\r\n\t\t\tbreak;\r\n\t}\r\n\r\n\treturn obj\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}