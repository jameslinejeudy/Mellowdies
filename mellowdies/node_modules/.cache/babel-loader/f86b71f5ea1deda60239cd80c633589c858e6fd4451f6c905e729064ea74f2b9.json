{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  JAVASCRIPT_MODULE_TYPE_AUTO,\n  JAVASCRIPT_MODULE_TYPE_ESM,\n  JAVASCRIPT_MODULE_TYPE_DYNAMIC\n} = require(\"./ModuleTypeConstants\");\nconst RuntimeGlobals = require(\"./RuntimeGlobals\");\nconst WebpackError = require(\"./WebpackError\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst BasicEvaluatedExpression = require(\"./javascript/BasicEvaluatedExpression\");\nconst {\n  evaluateToString,\n  toConstantDependency\n} = require(\"./javascript/JavascriptParserHelpers\");\nconst createHash = require(\"./util/createHash\");\n\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"./Compilation\").ValueCacheVersion} ValueCacheVersion */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\").BuildInfo} BuildInfo */\n/** @typedef {import(\"./NormalModule\")} NormalModule */\n/** @typedef {import(\"./RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"./javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./javascript/JavascriptParser\").DestructuringAssignmentProperty} DestructuringAssignmentProperty */\n/** @typedef {import(\"./javascript/JavascriptParser\").Range} Range */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/createHash\").Algorithm} Algorithm */\n\n/** @typedef {null|undefined|RegExp|Function|string|number|boolean|bigint|undefined} CodeValuePrimitive */\n/** @typedef {RecursiveArrayOrRecord<CodeValuePrimitive|RuntimeValue>} CodeValue */\n\n/**\n * @typedef {object} RuntimeValueOptions\n * @property {string[]=} fileDependencies\n * @property {string[]=} contextDependencies\n * @property {string[]=} missingDependencies\n * @property {string[]=} buildDependencies\n * @property {string|function(): string=} version\n */\n\n/** @typedef {function({ module: NormalModule, key: string, readonly version: ValueCacheVersion }): CodeValuePrimitive} GeneratorFn */\n\nclass RuntimeValue {\n  /**\n   * @param {GeneratorFn} fn generator function\n   * @param {true | string[] | RuntimeValueOptions=} options options\n   */\n  constructor(fn, options) {\n    this.fn = fn;\n    if (Array.isArray(options)) {\n      options = {\n        fileDependencies: options\n      };\n    }\n    this.options = options || {};\n  }\n  get fileDependencies() {\n    return this.options === true ? true : this.options.fileDependencies;\n  }\n\n  /**\n   * @param {JavascriptParser} parser the parser\n   * @param {Map<string, ValueCacheVersion>} valueCacheVersions valueCacheVersions\n   * @param {string} key the defined key\n   * @returns {CodeValuePrimitive} code\n   */\n  exec(parser, valueCacheVersions, key) {\n    const buildInfo = /** @type {BuildInfo} */parser.state.module.buildInfo;\n    if (this.options === true) {\n      buildInfo.cacheable = false;\n    } else {\n      if (this.options.fileDependencies) {\n        for (const dep of this.options.fileDependencies) {\n          /** @type {NonNullable<BuildInfo[\"fileDependencies\"]>} */\n          buildInfo.fileDependencies.add(dep);\n        }\n      }\n      if (this.options.contextDependencies) {\n        for (const dep of this.options.contextDependencies) {\n          /** @type {NonNullable<BuildInfo[\"contextDependencies\"]>} */\n          buildInfo.contextDependencies.add(dep);\n        }\n      }\n      if (this.options.missingDependencies) {\n        for (const dep of this.options.missingDependencies) {\n          /** @type {NonNullable<BuildInfo[\"missingDependencies\"]>} */\n          buildInfo.missingDependencies.add(dep);\n        }\n      }\n      if (this.options.buildDependencies) {\n        for (const dep of this.options.buildDependencies) {\n          /** @type {NonNullable<BuildInfo[\"buildDependencies\"]>} */\n          buildInfo.buildDependencies.add(dep);\n        }\n      }\n    }\n    return this.fn({\n      module: parser.state.module,\n      key,\n      get version() {\n        return valueCacheVersions.get(VALUE_DEP_PREFIX + key);\n      }\n    });\n  }\n  getCacheVersion() {\n    return this.options === true ? undefined : (typeof this.options.version === \"function\" ? this.options.version() : this.options.version) || \"unset\";\n  }\n}\n\n/**\n * @param {Set<DestructuringAssignmentProperty> | undefined} properties properties\n * @returns {Set<string> | undefined} used keys\n */\nfunction getObjKeys(properties) {\n  if (!properties) return;\n  return new Set([...properties].map(p => p.id));\n}\n\n/** @typedef {Set<string> | null} ObjKeys */\n/** @typedef {boolean | undefined | null} AsiSafe */\n\n/**\n * @param {any[]|{[k: string]: any}} obj obj\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, ValueCacheVersion>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Logger} logger the logger object\n * @param {AsiSafe=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @param {ObjKeys=} objKeys used keys\n * @returns {string} code converted to string that evaluates\n */\nconst stringifyObj = (obj, parser, valueCacheVersions, key, runtimeTemplate, logger, asiSafe, objKeys) => {\n  let code;\n  const arr = Array.isArray(obj);\n  if (arr) {\n    code = `[${/** @type {any[]} */obj.map(code => toCode(code, parser, valueCacheVersions, key, runtimeTemplate, logger, null)).join(\",\")}]`;\n  } else {\n    let keys = Object.keys(obj);\n    if (objKeys) {\n      keys = objKeys.size === 0 ? [] : keys.filter(k => objKeys.has(k));\n    }\n    code = `{${keys.map(key => {\n      const code = /** @type {{[k: string]: any}} */obj[key];\n      return `${JSON.stringify(key)}:${toCode(code, parser, valueCacheVersions, key, runtimeTemplate, logger, null)}`;\n    }).join(\",\")}}`;\n  }\n  switch (asiSafe) {\n    case null:\n      return code;\n    case true:\n      return arr ? code : `(${code})`;\n    case false:\n      return arr ? `;${code}` : `;(${code})`;\n    default:\n      return `/*#__PURE__*/Object(${code})`;\n  }\n};\n\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, ValueCacheVersion>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Logger} logger the logger object\n * @param {boolean | undefined | null=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @param {ObjKeys=} objKeys used keys\n * @returns {string} code converted to string that evaluates\n */\nconst toCode = (code, parser, valueCacheVersions, key, runtimeTemplate, logger, asiSafe, objKeys) => {\n  const transformToCode = () => {\n    if (code === null) {\n      return \"null\";\n    }\n    if (code === undefined) {\n      return \"undefined\";\n    }\n    if (Object.is(code, -0)) {\n      return \"-0\";\n    }\n    if (code instanceof RuntimeValue) {\n      return toCode(code.exec(parser, valueCacheVersions, key), parser, valueCacheVersions, key, runtimeTemplate, logger, asiSafe);\n    }\n    if (code instanceof RegExp && code.toString) {\n      return code.toString();\n    }\n    if (typeof code === \"function\" && code.toString) {\n      return `(${code.toString()})`;\n    }\n    if (typeof code === \"object\") {\n      return stringifyObj(code, parser, valueCacheVersions, key, runtimeTemplate, logger, asiSafe, objKeys);\n    }\n    if (typeof code === \"bigint\") {\n      return runtimeTemplate.supportsBigIntLiteral() ? `${code}n` : `BigInt(\"${code}\")`;\n    }\n    return `${code}`;\n  };\n  const strCode = transformToCode();\n  logger.debug(`Replaced \"${key}\" with \"${strCode}\"`);\n  return strCode;\n};\n\n/**\n * @param {CodeValue} code code\n * @returns {string | undefined} result\n */\nconst toCacheVersion = code => {\n  if (code === null) {\n    return \"null\";\n  }\n  if (code === undefined) {\n    return \"undefined\";\n  }\n  if (Object.is(code, -0)) {\n    return \"-0\";\n  }\n  if (code instanceof RuntimeValue) {\n    return code.getCacheVersion();\n  }\n  if (code instanceof RegExp && code.toString) {\n    return code.toString();\n  }\n  if (typeof code === \"function\" && code.toString) {\n    return `(${code.toString()})`;\n  }\n  if (typeof code === \"object\") {\n    const items = Object.keys(code).map(key => ({\n      key,\n      value: toCacheVersion(/** @type {Record<string, any>} */code[key])\n    }));\n    if (items.some(({\n      value\n    }) => value === undefined)) return;\n    return `{${items.map(({\n      key,\n      value\n    }) => `${key}: ${value}`).join(\", \")}}`;\n  }\n  if (typeof code === \"bigint\") {\n    return `${code}n`;\n  }\n  return `${code}`;\n};\nconst PLUGIN_NAME = \"DefinePlugin\";\nconst VALUE_DEP_PREFIX = `webpack/${PLUGIN_NAME} `;\nconst VALUE_DEP_MAIN = `webpack/${PLUGIN_NAME}_hash`;\nconst TYPEOF_OPERATOR_REGEXP = /^typeof\\s+/;\nconst WEBPACK_REQUIRE_FUNCTION_REGEXP = new RegExp(`${RuntimeGlobals.require}\\\\s*(!?\\\\.)`);\nconst WEBPACK_REQUIRE_IDENTIFIER_REGEXP = new RegExp(RuntimeGlobals.require);\nclass DefinePlugin {\n  /**\n   * Create a new define plugin\n   * @param {Record<string, CodeValue>} definitions A map of global object definitions\n   */\n  constructor(definitions) {\n    this.definitions = definitions;\n  }\n\n  /**\n   * @param {GeneratorFn} fn generator function\n   * @param {true | string[] | RuntimeValueOptions=} options options\n   * @returns {RuntimeValue} runtime value\n   */\n  static runtimeValue(fn, options) {\n    return new RuntimeValue(fn, options);\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const definitions = this.definitions;\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, {\n      normalModuleFactory\n    }) => {\n      const logger = compilation.getLogger(\"webpack.DefinePlugin\");\n      compilation.dependencyTemplates.set(ConstDependency, new ConstDependency.Template());\n      const {\n        runtimeTemplate\n      } = compilation;\n      const mainHash = createHash(/** @type {Algorithm} */\n      compilation.outputOptions.hashFunction);\n      mainHash.update(/** @type {string} */\n      compilation.valueCacheVersions.get(VALUE_DEP_MAIN) || \"\");\n\n      /**\n       * Handler\n       * @param {JavascriptParser} parser Parser\n       * @returns {void}\n       */\n      const handler = parser => {\n        const mainValue = compilation.valueCacheVersions.get(VALUE_DEP_MAIN);\n        parser.hooks.program.tap(PLUGIN_NAME, () => {\n          const buildInfo = /** @type {BuildInfo} */\n          parser.state.module.buildInfo;\n          if (!buildInfo.valueDependencies) buildInfo.valueDependencies = new Map();\n          buildInfo.valueDependencies.set(VALUE_DEP_MAIN, mainValue);\n        });\n\n        /**\n         * @param {string} key key\n         */\n        const addValueDependency = key => {\n          const buildInfo = /** @type {BuildInfo} */\n          parser.state.module.buildInfo;\n          /** @type {NonNullable<BuildInfo[\"valueDependencies\"]>} */\n          buildInfo.valueDependencies.set(VALUE_DEP_PREFIX + key, compilation.valueCacheVersions.get(VALUE_DEP_PREFIX + key));\n        };\n\n        /**\n         * @template {Function} T\n         * @param {string} key key\n         * @param {T} fn fn\n         * @returns {function(TODO): TODO} result\n         */\n        const withValueDependency = (key, fn) => (...args) => {\n          addValueDependency(key);\n          return fn(...args);\n        };\n\n        /**\n         * Walk definitions\n         * @param {Record<string, CodeValue>} definitions Definitions map\n         * @param {string} prefix Prefix string\n         * @returns {void}\n         */\n        const walkDefinitions = (definitions, prefix) => {\n          for (const key of Object.keys(definitions)) {\n            const code = definitions[key];\n            if (code && typeof code === \"object\" && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) {\n              walkDefinitions(/** @type {Record<string, CodeValue>} */code, `${prefix + key}.`);\n              applyObjectDefine(prefix + key, code);\n              continue;\n            }\n            applyDefineKey(prefix, key);\n            applyDefine(prefix + key, code);\n          }\n        };\n\n        /**\n         * Apply define key\n         * @param {string} prefix Prefix\n         * @param {string} key Key\n         * @returns {void}\n         */\n        const applyDefineKey = (prefix, key) => {\n          const splittedKey = key.split(\".\");\n          for (const [i, _] of splittedKey.slice(1).entries()) {\n            const fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n            parser.hooks.canRename.for(fullKey).tap(PLUGIN_NAME, () => {\n              addValueDependency(key);\n              return true;\n            });\n          }\n        };\n\n        /**\n         * Apply Code\n         * @param {string} key Key\n         * @param {CodeValue} code Code\n         * @returns {void}\n         */\n        const applyDefine = (key, code) => {\n          const originalKey = key;\n          const isTypeof = TYPEOF_OPERATOR_REGEXP.test(key);\n          if (isTypeof) key = key.replace(TYPEOF_OPERATOR_REGEXP, \"\");\n          let recurse = false;\n          let recurseTypeof = false;\n          if (!isTypeof) {\n            parser.hooks.canRename.for(key).tap(PLUGIN_NAME, () => {\n              addValueDependency(originalKey);\n              return true;\n            });\n            parser.hooks.evaluateIdentifier.for(key).tap(PLUGIN_NAME, expr => {\n              /**\n               * this is needed in case there is a recursion in the DefinePlugin\n               * to prevent an endless recursion\n               * e.g.: new DefinePlugin({\n               * \"a\": \"b\",\n               * \"b\": \"a\"\n               * });\n               */\n              if (recurse) return;\n              addValueDependency(originalKey);\n              recurse = true;\n              const res = parser.evaluate(toCode(code, parser, compilation.valueCacheVersions, key, runtimeTemplate, logger, null));\n              recurse = false;\n              res.setRange(/** @type {Range} */expr.range);\n              return res;\n            });\n            parser.hooks.expression.for(key).tap(PLUGIN_NAME, expr => {\n              addValueDependency(originalKey);\n              let strCode = toCode(code, parser, compilation.valueCacheVersions, originalKey, runtimeTemplate, logger, !parser.isAsiPosition(/** @type {Range} */expr.range[0]), null);\n              if (parser.scope.inShorthand) {\n                strCode = `${parser.scope.inShorthand}:${strCode}`;\n              }\n              if (WEBPACK_REQUIRE_FUNCTION_REGEXP.test(strCode)) {\n                return toConstantDependency(parser, strCode, [RuntimeGlobals.require])(expr);\n              } else if (WEBPACK_REQUIRE_IDENTIFIER_REGEXP.test(strCode)) {\n                return toConstantDependency(parser, strCode, [RuntimeGlobals.requireScope])(expr);\n              }\n              return toConstantDependency(parser, strCode)(expr);\n            });\n          }\n          parser.hooks.evaluateTypeof.for(key).tap(PLUGIN_NAME, expr => {\n            /**\n             * this is needed in case there is a recursion in the DefinePlugin\n             * to prevent an endless recursion\n             * e.g.: new DefinePlugin({\n             * \"typeof a\": \"typeof b\",\n             * \"typeof b\": \"typeof a\"\n             * });\n             */\n            if (recurseTypeof) return;\n            recurseTypeof = true;\n            addValueDependency(originalKey);\n            const codeCode = toCode(code, parser, compilation.valueCacheVersions, originalKey, runtimeTemplate, logger, null);\n            const typeofCode = isTypeof ? codeCode : `typeof (${codeCode})`;\n            const res = parser.evaluate(typeofCode);\n            recurseTypeof = false;\n            res.setRange(/** @type {Range} */expr.range);\n            return res;\n          });\n          parser.hooks.typeof.for(key).tap(PLUGIN_NAME, expr => {\n            addValueDependency(originalKey);\n            const codeCode = toCode(code, parser, compilation.valueCacheVersions, originalKey, runtimeTemplate, logger, null);\n            const typeofCode = isTypeof ? codeCode : `typeof (${codeCode})`;\n            const res = parser.evaluate(typeofCode);\n            if (!res.isString()) return;\n            return toConstantDependency(parser, JSON.stringify(res.string)).bind(parser)(expr);\n          });\n        };\n\n        /**\n         * Apply Object\n         * @param {string} key Key\n         * @param {object} obj Object\n         * @returns {void}\n         */\n        const applyObjectDefine = (key, obj) => {\n          parser.hooks.canRename.for(key).tap(PLUGIN_NAME, () => {\n            addValueDependency(key);\n            return true;\n          });\n          parser.hooks.evaluateIdentifier.for(key).tap(PLUGIN_NAME, expr => {\n            addValueDependency(key);\n            return new BasicEvaluatedExpression().setTruthy().setSideEffects(false).setRange(/** @type {Range} */expr.range);\n          });\n          parser.hooks.evaluateTypeof.for(key).tap(PLUGIN_NAME, withValueDependency(key, evaluateToString(\"object\")));\n          parser.hooks.expression.for(key).tap(PLUGIN_NAME, expr => {\n            addValueDependency(key);\n            let strCode = stringifyObj(obj, parser, compilation.valueCacheVersions, key, runtimeTemplate, logger, !parser.isAsiPosition(/** @type {Range} */expr.range[0]), getObjKeys(parser.destructuringAssignmentPropertiesFor(expr)));\n            if (parser.scope.inShorthand) {\n              strCode = `${parser.scope.inShorthand}:${strCode}`;\n            }\n            if (WEBPACK_REQUIRE_FUNCTION_REGEXP.test(strCode)) {\n              return toConstantDependency(parser, strCode, [RuntimeGlobals.require])(expr);\n            } else if (WEBPACK_REQUIRE_IDENTIFIER_REGEXP.test(strCode)) {\n              return toConstantDependency(parser, strCode, [RuntimeGlobals.requireScope])(expr);\n            }\n            return toConstantDependency(parser, strCode)(expr);\n          });\n          parser.hooks.typeof.for(key).tap(PLUGIN_NAME, withValueDependency(key, toConstantDependency(parser, JSON.stringify(\"object\"))));\n        };\n        walkDefinitions(definitions, \"\");\n      };\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_AUTO).tap(PLUGIN_NAME, handler);\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_DYNAMIC).tap(PLUGIN_NAME, handler);\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_ESM).tap(PLUGIN_NAME, handler);\n\n      /**\n       * Walk definitions\n       * @param {Record<string, CodeValue>} definitions Definitions map\n       * @param {string} prefix Prefix string\n       * @returns {void}\n       */\n      const walkDefinitionsForValues = (definitions, prefix) => {\n        for (const key of Object.keys(definitions)) {\n          const code = definitions[key];\n          const version = toCacheVersion(code);\n          const name = VALUE_DEP_PREFIX + prefix + key;\n          mainHash.update(`|${prefix}${key}`);\n          const oldVersion = compilation.valueCacheVersions.get(name);\n          if (oldVersion === undefined) {\n            compilation.valueCacheVersions.set(name, version);\n          } else if (oldVersion !== version) {\n            const warning = new WebpackError(`${PLUGIN_NAME}\\nConflicting values for '${prefix + key}'`);\n            warning.details = `'${oldVersion}' !== '${version}'`;\n            warning.hideStack = true;\n            compilation.warnings.push(warning);\n          }\n          if (code && typeof code === \"object\" && !(code instanceof RuntimeValue) && !(code instanceof RegExp)) {\n            walkDefinitionsForValues(/** @type {Record<string, CodeValue>} */code, `${prefix + key}.`);\n          }\n        }\n      };\n      walkDefinitionsForValues(definitions, \"\");\n      compilation.valueCacheVersions.set(VALUE_DEP_MAIN, /** @type {string} */mainHash.digest(\"hex\").slice(0, 8));\n    });\n  }\n}\nmodule.exports = DefinePlugin;","map":{"version":3,"names":["JAVASCRIPT_MODULE_TYPE_AUTO","JAVASCRIPT_MODULE_TYPE_ESM","JAVASCRIPT_MODULE_TYPE_DYNAMIC","require","RuntimeGlobals","WebpackError","ConstDependency","BasicEvaluatedExpression","evaluateToString","toConstantDependency","createHash","RuntimeValue","constructor","fn","options","Array","isArray","fileDependencies","exec","parser","valueCacheVersions","key","buildInfo","state","module","cacheable","dep","add","contextDependencies","missingDependencies","buildDependencies","version","get","VALUE_DEP_PREFIX","getCacheVersion","undefined","getObjKeys","properties","Set","map","p","id","stringifyObj","obj","runtimeTemplate","logger","asiSafe","objKeys","code","arr","toCode","join","keys","Object","size","filter","k","has","JSON","stringify","transformToCode","is","RegExp","toString","supportsBigIntLiteral","strCode","debug","toCacheVersion","items","value","some","PLUGIN_NAME","VALUE_DEP_MAIN","TYPEOF_OPERATOR_REGEXP","WEBPACK_REQUIRE_FUNCTION_REGEXP","WEBPACK_REQUIRE_IDENTIFIER_REGEXP","DefinePlugin","definitions","runtimeValue","apply","compiler","hooks","compilation","tap","normalModuleFactory","getLogger","dependencyTemplates","set","Template","mainHash","outputOptions","hashFunction","update","handler","mainValue","program","valueDependencies","Map","addValueDependency","withValueDependency","args","walkDefinitions","prefix","applyObjectDefine","applyDefineKey","applyDefine","splittedKey","split","i","_","slice","entries","fullKey","canRename","for","originalKey","isTypeof","test","replace","recurse","recurseTypeof","evaluateIdentifier","expr","res","evaluate","setRange","range","expression","isAsiPosition","scope","inShorthand","requireScope","evaluateTypeof","codeCode","typeofCode","typeof","isString","string","bind","setTruthy","setSideEffects","destructuringAssignmentPropertiesFor","walkDefinitionsForValues","name","oldVersion","warning","details","hideStack","warnings","push","digest","exports"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/webpack/lib/DefinePlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n\tJAVASCRIPT_MODULE_TYPE_AUTO,\n\tJAVASCRIPT_MODULE_TYPE_ESM,\n\tJAVASCRIPT_MODULE_TYPE_DYNAMIC\n} = require(\"./ModuleTypeConstants\");\nconst RuntimeGlobals = require(\"./RuntimeGlobals\");\nconst WebpackError = require(\"./WebpackError\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst BasicEvaluatedExpression = require(\"./javascript/BasicEvaluatedExpression\");\n\nconst {\n\tevaluateToString,\n\ttoConstantDependency\n} = require(\"./javascript/JavascriptParserHelpers\");\nconst createHash = require(\"./util/createHash\");\n\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"./Compilation\").ValueCacheVersion} ValueCacheVersion */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Module\").BuildInfo} BuildInfo */\n/** @typedef {import(\"./NormalModule\")} NormalModule */\n/** @typedef {import(\"./RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {import(\"./javascript/JavascriptParser\")} JavascriptParser */\n/** @typedef {import(\"./javascript/JavascriptParser\").DestructuringAssignmentProperty} DestructuringAssignmentProperty */\n/** @typedef {import(\"./javascript/JavascriptParser\").Range} Range */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/createHash\").Algorithm} Algorithm */\n\n/** @typedef {null|undefined|RegExp|Function|string|number|boolean|bigint|undefined} CodeValuePrimitive */\n/** @typedef {RecursiveArrayOrRecord<CodeValuePrimitive|RuntimeValue>} CodeValue */\n\n/**\n * @typedef {object} RuntimeValueOptions\n * @property {string[]=} fileDependencies\n * @property {string[]=} contextDependencies\n * @property {string[]=} missingDependencies\n * @property {string[]=} buildDependencies\n * @property {string|function(): string=} version\n */\n\n/** @typedef {function({ module: NormalModule, key: string, readonly version: ValueCacheVersion }): CodeValuePrimitive} GeneratorFn */\n\nclass RuntimeValue {\n\t/**\n\t * @param {GeneratorFn} fn generator function\n\t * @param {true | string[] | RuntimeValueOptions=} options options\n\t */\n\tconstructor(fn, options) {\n\t\tthis.fn = fn;\n\t\tif (Array.isArray(options)) {\n\t\t\toptions = {\n\t\t\t\tfileDependencies: options\n\t\t\t};\n\t\t}\n\t\tthis.options = options || {};\n\t}\n\n\tget fileDependencies() {\n\t\treturn this.options === true ? true : this.options.fileDependencies;\n\t}\n\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t * @param {Map<string, ValueCacheVersion>} valueCacheVersions valueCacheVersions\n\t * @param {string} key the defined key\n\t * @returns {CodeValuePrimitive} code\n\t */\n\texec(parser, valueCacheVersions, key) {\n\t\tconst buildInfo = /** @type {BuildInfo} */ (parser.state.module.buildInfo);\n\t\tif (this.options === true) {\n\t\t\tbuildInfo.cacheable = false;\n\t\t} else {\n\t\t\tif (this.options.fileDependencies) {\n\t\t\t\tfor (const dep of this.options.fileDependencies) {\n\t\t\t\t\t/** @type {NonNullable<BuildInfo[\"fileDependencies\"]>} */\n\t\t\t\t\t(buildInfo.fileDependencies).add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.options.contextDependencies) {\n\t\t\t\tfor (const dep of this.options.contextDependencies) {\n\t\t\t\t\t/** @type {NonNullable<BuildInfo[\"contextDependencies\"]>} */\n\t\t\t\t\t(buildInfo.contextDependencies).add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.options.missingDependencies) {\n\t\t\t\tfor (const dep of this.options.missingDependencies) {\n\t\t\t\t\t/** @type {NonNullable<BuildInfo[\"missingDependencies\"]>} */\n\t\t\t\t\t(buildInfo.missingDependencies).add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.options.buildDependencies) {\n\t\t\t\tfor (const dep of this.options.buildDependencies) {\n\t\t\t\t\t/** @type {NonNullable<BuildInfo[\"buildDependencies\"]>} */\n\t\t\t\t\t(buildInfo.buildDependencies).add(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this.fn({\n\t\t\tmodule: parser.state.module,\n\t\t\tkey,\n\t\t\tget version() {\n\t\t\t\treturn valueCacheVersions.get(VALUE_DEP_PREFIX + key);\n\t\t\t}\n\t\t});\n\t}\n\n\tgetCacheVersion() {\n\t\treturn this.options === true\n\t\t\t? undefined\n\t\t\t: (typeof this.options.version === \"function\"\n\t\t\t\t\t? this.options.version()\n\t\t\t\t\t: this.options.version) || \"unset\";\n\t}\n}\n\n/**\n * @param {Set<DestructuringAssignmentProperty> | undefined} properties properties\n * @returns {Set<string> | undefined} used keys\n */\nfunction getObjKeys(properties) {\n\tif (!properties) return;\n\treturn new Set([...properties].map(p => p.id));\n}\n\n/** @typedef {Set<string> | null} ObjKeys */\n/** @typedef {boolean | undefined | null} AsiSafe */\n\n/**\n * @param {any[]|{[k: string]: any}} obj obj\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, ValueCacheVersion>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Logger} logger the logger object\n * @param {AsiSafe=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @param {ObjKeys=} objKeys used keys\n * @returns {string} code converted to string that evaluates\n */\nconst stringifyObj = (\n\tobj,\n\tparser,\n\tvalueCacheVersions,\n\tkey,\n\truntimeTemplate,\n\tlogger,\n\tasiSafe,\n\tobjKeys\n) => {\n\tlet code;\n\tconst arr = Array.isArray(obj);\n\tif (arr) {\n\t\tcode = `[${\n\t\t\t/** @type {any[]} */ (obj)\n\t\t\t\t.map(code =>\n\t\t\t\t\ttoCode(\n\t\t\t\t\t\tcode,\n\t\t\t\t\t\tparser,\n\t\t\t\t\t\tvalueCacheVersions,\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\tlogger,\n\t\t\t\t\t\tnull\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t.join(\",\")\n\t\t}]`;\n\t} else {\n\t\tlet keys = Object.keys(obj);\n\t\tif (objKeys) {\n\t\t\tkeys = objKeys.size === 0 ? [] : keys.filter(k => objKeys.has(k));\n\t\t}\n\t\tcode = `{${keys\n\t\t\t.map(key => {\n\t\t\t\tconst code = /** @type {{[k: string]: any}} */ (obj)[key];\n\t\t\t\treturn `${JSON.stringify(key)}:${toCode(\n\t\t\t\t\tcode,\n\t\t\t\t\tparser,\n\t\t\t\t\tvalueCacheVersions,\n\t\t\t\t\tkey,\n\t\t\t\t\truntimeTemplate,\n\t\t\t\t\tlogger,\n\t\t\t\t\tnull\n\t\t\t\t)}`;\n\t\t\t})\n\t\t\t.join(\",\")}}`;\n\t}\n\n\tswitch (asiSafe) {\n\t\tcase null:\n\t\t\treturn code;\n\t\tcase true:\n\t\t\treturn arr ? code : `(${code})`;\n\t\tcase false:\n\t\t\treturn arr ? `;${code}` : `;(${code})`;\n\t\tdefault:\n\t\t\treturn `/*#__PURE__*/Object(${code})`;\n\t}\n};\n\n/**\n * Convert code to a string that evaluates\n * @param {CodeValue} code Code to evaluate\n * @param {JavascriptParser} parser Parser\n * @param {Map<string, ValueCacheVersion>} valueCacheVersions valueCacheVersions\n * @param {string} key the defined key\n * @param {RuntimeTemplate} runtimeTemplate the runtime template\n * @param {Logger} logger the logger object\n * @param {boolean | undefined | null=} asiSafe asi safe (undefined: unknown, null: unneeded)\n * @param {ObjKeys=} objKeys used keys\n * @returns {string} code converted to string that evaluates\n */\nconst toCode = (\n\tcode,\n\tparser,\n\tvalueCacheVersions,\n\tkey,\n\truntimeTemplate,\n\tlogger,\n\tasiSafe,\n\tobjKeys\n) => {\n\tconst transformToCode = () => {\n\t\tif (code === null) {\n\t\t\treturn \"null\";\n\t\t}\n\t\tif (code === undefined) {\n\t\t\treturn \"undefined\";\n\t\t}\n\t\tif (Object.is(code, -0)) {\n\t\t\treturn \"-0\";\n\t\t}\n\t\tif (code instanceof RuntimeValue) {\n\t\t\treturn toCode(\n\t\t\t\tcode.exec(parser, valueCacheVersions, key),\n\t\t\t\tparser,\n\t\t\t\tvalueCacheVersions,\n\t\t\t\tkey,\n\t\t\t\truntimeTemplate,\n\t\t\t\tlogger,\n\t\t\t\tasiSafe\n\t\t\t);\n\t\t}\n\t\tif (code instanceof RegExp && code.toString) {\n\t\t\treturn code.toString();\n\t\t}\n\t\tif (typeof code === \"function\" && code.toString) {\n\t\t\treturn `(${code.toString()})`;\n\t\t}\n\t\tif (typeof code === \"object\") {\n\t\t\treturn stringifyObj(\n\t\t\t\tcode,\n\t\t\t\tparser,\n\t\t\t\tvalueCacheVersions,\n\t\t\t\tkey,\n\t\t\t\truntimeTemplate,\n\t\t\t\tlogger,\n\t\t\t\tasiSafe,\n\t\t\t\tobjKeys\n\t\t\t);\n\t\t}\n\t\tif (typeof code === \"bigint\") {\n\t\t\treturn runtimeTemplate.supportsBigIntLiteral()\n\t\t\t\t? `${code}n`\n\t\t\t\t: `BigInt(\"${code}\")`;\n\t\t}\n\t\treturn `${code}`;\n\t};\n\n\tconst strCode = transformToCode();\n\n\tlogger.debug(`Replaced \"${key}\" with \"${strCode}\"`);\n\n\treturn strCode;\n};\n\n/**\n * @param {CodeValue} code code\n * @returns {string | undefined} result\n */\nconst toCacheVersion = code => {\n\tif (code === null) {\n\t\treturn \"null\";\n\t}\n\tif (code === undefined) {\n\t\treturn \"undefined\";\n\t}\n\tif (Object.is(code, -0)) {\n\t\treturn \"-0\";\n\t}\n\tif (code instanceof RuntimeValue) {\n\t\treturn code.getCacheVersion();\n\t}\n\tif (code instanceof RegExp && code.toString) {\n\t\treturn code.toString();\n\t}\n\tif (typeof code === \"function\" && code.toString) {\n\t\treturn `(${code.toString()})`;\n\t}\n\tif (typeof code === \"object\") {\n\t\tconst items = Object.keys(code).map(key => ({\n\t\t\tkey,\n\t\t\tvalue: toCacheVersion(/** @type {Record<string, any>} */ (code)[key])\n\t\t}));\n\t\tif (items.some(({ value }) => value === undefined)) return;\n\t\treturn `{${items.map(({ key, value }) => `${key}: ${value}`).join(\", \")}}`;\n\t}\n\tif (typeof code === \"bigint\") {\n\t\treturn `${code}n`;\n\t}\n\treturn `${code}`;\n};\n\nconst PLUGIN_NAME = \"DefinePlugin\";\nconst VALUE_DEP_PREFIX = `webpack/${PLUGIN_NAME} `;\nconst VALUE_DEP_MAIN = `webpack/${PLUGIN_NAME}_hash`;\nconst TYPEOF_OPERATOR_REGEXP = /^typeof\\s+/;\nconst WEBPACK_REQUIRE_FUNCTION_REGEXP = new RegExp(\n\t`${RuntimeGlobals.require}\\\\s*(!?\\\\.)`\n);\nconst WEBPACK_REQUIRE_IDENTIFIER_REGEXP = new RegExp(RuntimeGlobals.require);\n\nclass DefinePlugin {\n\t/**\n\t * Create a new define plugin\n\t * @param {Record<string, CodeValue>} definitions A map of global object definitions\n\t */\n\tconstructor(definitions) {\n\t\tthis.definitions = definitions;\n\t}\n\n\t/**\n\t * @param {GeneratorFn} fn generator function\n\t * @param {true | string[] | RuntimeValueOptions=} options options\n\t * @returns {RuntimeValue} runtime value\n\t */\n\tstatic runtimeValue(fn, options) {\n\t\treturn new RuntimeValue(fn, options);\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst definitions = this.definitions;\n\t\tcompiler.hooks.compilation.tap(\n\t\t\tPLUGIN_NAME,\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst logger = compilation.getLogger(\"webpack.DefinePlugin\");\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tConstDependency,\n\t\t\t\t\tnew ConstDependency.Template()\n\t\t\t\t);\n\t\t\t\tconst { runtimeTemplate } = compilation;\n\n\t\t\t\tconst mainHash = createHash(\n\t\t\t\t\t/** @type {Algorithm} */\n\t\t\t\t\t(compilation.outputOptions.hashFunction)\n\t\t\t\t);\n\t\t\t\tmainHash.update(\n\t\t\t\t\t/** @type {string} */\n\t\t\t\t\t(compilation.valueCacheVersions.get(VALUE_DEP_MAIN)) || \"\"\n\t\t\t\t);\n\n\t\t\t\t/**\n\t\t\t\t * Handler\n\t\t\t\t * @param {JavascriptParser} parser Parser\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst handler = parser => {\n\t\t\t\t\tconst mainValue = compilation.valueCacheVersions.get(VALUE_DEP_MAIN);\n\t\t\t\t\tparser.hooks.program.tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\tconst buildInfo = /** @type {BuildInfo} */ (\n\t\t\t\t\t\t\tparser.state.module.buildInfo\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (!buildInfo.valueDependencies)\n\t\t\t\t\t\t\tbuildInfo.valueDependencies = new Map();\n\t\t\t\t\t\tbuildInfo.valueDependencies.set(VALUE_DEP_MAIN, mainValue);\n\t\t\t\t\t});\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} key key\n\t\t\t\t\t */\n\t\t\t\t\tconst addValueDependency = key => {\n\t\t\t\t\t\tconst buildInfo =\n\t\t\t\t\t\t\t/** @type {BuildInfo} */\n\t\t\t\t\t\t\t(parser.state.module.buildInfo);\n\t\t\t\t\t\t/** @type {NonNullable<BuildInfo[\"valueDependencies\"]>} */\n\t\t\t\t\t\t(buildInfo.valueDependencies).set(\n\t\t\t\t\t\t\tVALUE_DEP_PREFIX + key,\n\t\t\t\t\t\t\tcompilation.valueCacheVersions.get(VALUE_DEP_PREFIX + key)\n\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @template {Function} T\n\t\t\t\t\t * @param {string} key key\n\t\t\t\t\t * @param {T} fn fn\n\t\t\t\t\t * @returns {function(TODO): TODO} result\n\t\t\t\t\t */\n\t\t\t\t\tconst withValueDependency =\n\t\t\t\t\t\t(key, fn) =>\n\t\t\t\t\t\t(...args) => {\n\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\treturn fn(...args);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Walk definitions\n\t\t\t\t\t * @param {Record<string, CodeValue>} definitions Definitions map\n\t\t\t\t\t * @param {string} prefix Prefix string\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst walkDefinitions = (definitions, prefix) => {\n\t\t\t\t\t\tfor (const key of Object.keys(definitions)) {\n\t\t\t\t\t\t\tconst code = definitions[key];\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcode &&\n\t\t\t\t\t\t\t\ttypeof code === \"object\" &&\n\t\t\t\t\t\t\t\t!(code instanceof RuntimeValue) &&\n\t\t\t\t\t\t\t\t!(code instanceof RegExp)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\twalkDefinitions(\n\t\t\t\t\t\t\t\t\t/** @type {Record<string, CodeValue>} */ (code),\n\t\t\t\t\t\t\t\t\t`${prefix + key}.`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tapplyObjectDefine(prefix + key, code);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tapplyDefineKey(prefix, key);\n\t\t\t\t\t\t\tapplyDefine(prefix + key, code);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply define key\n\t\t\t\t\t * @param {string} prefix Prefix\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefineKey = (prefix, key) => {\n\t\t\t\t\t\tconst splittedKey = key.split(\".\");\n\t\t\t\t\t\tfor (const [i, _] of splittedKey.slice(1).entries()) {\n\t\t\t\t\t\t\tconst fullKey = prefix + splittedKey.slice(0, i + 1).join(\".\");\n\t\t\t\t\t\t\tparser.hooks.canRename.for(fullKey).tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Code\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {CodeValue} code Code\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyDefine = (key, code) => {\n\t\t\t\t\t\tconst originalKey = key;\n\t\t\t\t\t\tconst isTypeof = TYPEOF_OPERATOR_REGEXP.test(key);\n\t\t\t\t\t\tif (isTypeof) key = key.replace(TYPEOF_OPERATOR_REGEXP, \"\");\n\t\t\t\t\t\tlet recurse = false;\n\t\t\t\t\t\tlet recurseTypeof = false;\n\t\t\t\t\t\tif (!isTypeof) {\n\t\t\t\t\t\t\tparser.hooks.canRename.for(key).tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t\t.tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t\t\t * \"a\": \"b\",\n\t\t\t\t\t\t\t\t\t * \"b\": \"a\"\n\t\t\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\tif (recurse) return;\n\t\t\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\t\t\trecurse = true;\n\t\t\t\t\t\t\t\t\tconst res = parser.evaluate(\n\t\t\t\t\t\t\t\t\t\ttoCode(\n\t\t\t\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\t\t\t\tlogger,\n\t\t\t\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\trecurse = false;\n\t\t\t\t\t\t\t\t\tres.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tparser.hooks.expression.for(key).tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\t\tlet strCode = toCode(\n\t\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\t\toriginalKey,\n\t\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\t\tlogger,\n\t\t\t\t\t\t\t\t\t!parser.isAsiPosition(/** @type {Range} */ (expr.range)[0]),\n\t\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\tif (parser.scope.inShorthand) {\n\t\t\t\t\t\t\t\t\tstrCode = `${parser.scope.inShorthand}:${strCode}`;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (WEBPACK_REQUIRE_FUNCTION_REGEXP.test(strCode)) {\n\t\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\t\tRuntimeGlobals.require\n\t\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t\t} else if (WEBPACK_REQUIRE_IDENTIFIER_REGEXP.test(strCode)) {\n\t\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\t\tRuntimeGlobals.requireScope\n\t\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode)(expr);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparser.hooks.evaluateTypeof.for(key).tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * this is needed in case there is a recursion in the DefinePlugin\n\t\t\t\t\t\t\t * to prevent an endless recursion\n\t\t\t\t\t\t\t * e.g.: new DefinePlugin({\n\t\t\t\t\t\t\t * \"typeof a\": \"typeof b\",\n\t\t\t\t\t\t\t * \"typeof b\": \"typeof a\"\n\t\t\t\t\t\t\t * });\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tif (recurseTypeof) return;\n\t\t\t\t\t\t\trecurseTypeof = true;\n\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\tconst codeCode = toCode(\n\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\toriginalKey,\n\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\tlogger,\n\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst typeofCode = isTypeof ? codeCode : `typeof (${codeCode})`;\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\trecurseTypeof = false;\n\t\t\t\t\t\t\tres.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\t\t\treturn res;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof.for(key).tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\taddValueDependency(originalKey);\n\t\t\t\t\t\t\tconst codeCode = toCode(\n\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\toriginalKey,\n\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\tlogger,\n\t\t\t\t\t\t\t\tnull\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tconst typeofCode = isTypeof ? codeCode : `typeof (${codeCode})`;\n\t\t\t\t\t\t\tconst res = parser.evaluate(typeofCode);\n\t\t\t\t\t\t\tif (!res.isString()) return;\n\t\t\t\t\t\t\treturn toConstantDependency(\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tJSON.stringify(res.string)\n\t\t\t\t\t\t\t).bind(parser)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Apply Object\n\t\t\t\t\t * @param {string} key Key\n\t\t\t\t\t * @param {object} obj Object\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst applyObjectDefine = (key, obj) => {\n\t\t\t\t\t\tparser.hooks.canRename.for(key).tap(PLUGIN_NAME, () => {\n\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.evaluateIdentifier.for(key).tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setTruthy()\n\t\t\t\t\t\t\t\t.setSideEffects(false)\n\t\t\t\t\t\t\t\t.setRange(/** @type {Range} */ (expr.range));\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.evaluateTypeof\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\n\t\t\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\t\t\twithValueDependency(key, evaluateToString(\"object\"))\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\tparser.hooks.expression.for(key).tap(PLUGIN_NAME, expr => {\n\t\t\t\t\t\t\taddValueDependency(key);\n\t\t\t\t\t\t\tlet strCode = stringifyObj(\n\t\t\t\t\t\t\t\tobj,\n\t\t\t\t\t\t\t\tparser,\n\t\t\t\t\t\t\t\tcompilation.valueCacheVersions,\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\truntimeTemplate,\n\t\t\t\t\t\t\t\tlogger,\n\t\t\t\t\t\t\t\t!parser.isAsiPosition(/** @type {Range} */ (expr.range)[0]),\n\t\t\t\t\t\t\t\tgetObjKeys(parser.destructuringAssignmentPropertiesFor(expr))\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif (parser.scope.inShorthand) {\n\t\t\t\t\t\t\t\tstrCode = `${parser.scope.inShorthand}:${strCode}`;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (WEBPACK_REQUIRE_FUNCTION_REGEXP.test(strCode)) {\n\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\tRuntimeGlobals.require\n\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t} else if (WEBPACK_REQUIRE_IDENTIFIER_REGEXP.test(strCode)) {\n\t\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode, [\n\t\t\t\t\t\t\t\t\tRuntimeGlobals.requireScope\n\t\t\t\t\t\t\t\t])(expr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn toConstantDependency(parser, strCode)(expr);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tparser.hooks.typeof\n\t\t\t\t\t\t\t.for(key)\n\t\t\t\t\t\t\t.tap(\n\t\t\t\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t\t\t\twithValueDependency(\n\t\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t\ttoConstantDependency(parser, JSON.stringify(\"object\"))\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\twalkDefinitions(definitions, \"\");\n\t\t\t\t};\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_AUTO)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_DYNAMIC)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_ESM)\n\t\t\t\t\t.tap(PLUGIN_NAME, handler);\n\n\t\t\t\t/**\n\t\t\t\t * Walk definitions\n\t\t\t\t * @param {Record<string, CodeValue>} definitions Definitions map\n\t\t\t\t * @param {string} prefix Prefix string\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst walkDefinitionsForValues = (definitions, prefix) => {\n\t\t\t\t\tfor (const key of Object.keys(definitions)) {\n\t\t\t\t\t\tconst code = definitions[key];\n\t\t\t\t\t\tconst version = toCacheVersion(code);\n\t\t\t\t\t\tconst name = VALUE_DEP_PREFIX + prefix + key;\n\t\t\t\t\t\tmainHash.update(`|${prefix}${key}`);\n\t\t\t\t\t\tconst oldVersion = compilation.valueCacheVersions.get(name);\n\t\t\t\t\t\tif (oldVersion === undefined) {\n\t\t\t\t\t\t\tcompilation.valueCacheVersions.set(name, version);\n\t\t\t\t\t\t} else if (oldVersion !== version) {\n\t\t\t\t\t\t\tconst warning = new WebpackError(\n\t\t\t\t\t\t\t\t`${PLUGIN_NAME}\\nConflicting values for '${prefix + key}'`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\twarning.details = `'${oldVersion}' !== '${version}'`;\n\t\t\t\t\t\t\twarning.hideStack = true;\n\t\t\t\t\t\t\tcompilation.warnings.push(warning);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcode &&\n\t\t\t\t\t\t\ttypeof code === \"object\" &&\n\t\t\t\t\t\t\t!(code instanceof RuntimeValue) &&\n\t\t\t\t\t\t\t!(code instanceof RegExp)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\twalkDefinitionsForValues(\n\t\t\t\t\t\t\t\t/** @type {Record<string, CodeValue>} */ (code),\n\t\t\t\t\t\t\t\t`${prefix + key}.`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\twalkDefinitionsForValues(definitions, \"\");\n\n\t\t\t\tcompilation.valueCacheVersions.set(\n\t\t\t\t\tVALUE_DEP_MAIN,\n\t\t\t\t\t/** @type {string} */ (mainHash.digest(\"hex\").slice(0, 8))\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\nmodule.exports = DefinePlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}