{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst parseJson = require(\"json-parse-even-better-errors\");\nconst asyncLib = require(\"neo-async\");\nconst {\n  SyncHook,\n  SyncBailHook,\n  AsyncParallelHook,\n  AsyncSeriesHook\n} = require(\"tapable\");\nconst {\n  SizeOnlySource\n} = require(\"webpack-sources\");\nconst webpack = require(\".\");\nconst Cache = require(\"./Cache\");\nconst CacheFacade = require(\"./CacheFacade\");\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Compilation = require(\"./Compilation\");\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nconst ContextModuleFactory = require(\"./ContextModuleFactory\");\nconst ModuleGraph = require(\"./ModuleGraph\");\nconst NormalModuleFactory = require(\"./NormalModuleFactory\");\nconst RequestShortener = require(\"./RequestShortener\");\nconst ResolverFactory = require(\"./ResolverFactory\");\nconst Stats = require(\"./Stats\");\nconst Watching = require(\"./Watching\");\nconst WebpackError = require(\"./WebpackError\");\nconst {\n  Logger\n} = require(\"./logging/Logger\");\nconst {\n  join,\n  dirname,\n  mkdirp\n} = require(\"./util/fs\");\nconst {\n  makePathsRelative\n} = require(\"./util/identifier\");\nconst {\n  isSourceEqual\n} = require(\"./util/source\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryNormalized} Entry */\n/** @typedef {import(\"../declarations/WebpackOptions\").OutputNormalized} OutputOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackOptionsNormalized} WebpackOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackPluginInstance} WebpackPluginInstance */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compilation\").References} References */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./FileSystemInfo\").FileSystemInfoEntry} FileSystemInfoEntry */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Module\").BuildInfo} BuildInfo */\n/** @typedef {import(\"./config/target\").PlatformTargetProperties} PlatformTargetProperties */\n/** @typedef {import(\"./logging/createConsoleLogger\").LoggingFunction} LoggingFunction */\n/** @typedef {import(\"./util/fs\").IStats} IStats */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @template {any[]} T\n * @template V\n * @typedef {import(\"./util/WeakTupleMap\")<T, V>} WeakTupleMap\n */\n\n/**\n * @typedef {object} CompilationParams\n * @property {NormalModuleFactory} normalModuleFactory\n * @property {ContextModuleFactory} contextModuleFactory\n */\n\n/**\n * @template T\n * @callback RunCallback\n * @param {Error | null} err\n * @param {T=} result\n */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunAsChildCallback\n * @param {Error | null} err\n * @param {Chunk[]=} entries\n * @param {Compilation=} compilation\n */\n\n/**\n * @typedef {object} AssetEmittedInfo\n * @property {Buffer} content\n * @property {Source} source\n * @property {Compilation} compilation\n * @property {string} outputPath\n * @property {string} targetPath\n */\n\n/** @typedef {{ sizeOnlySource: SizeOnlySource | undefined, writtenTo: Map<string, number> }} CacheEntry */\n/** @typedef {{ path: string, source: Source, size: number | undefined, waiting: ({ cacheEntry: any, file: string }[] | undefined) }} SimilarEntry */\n\n/**\n * @param {string[]} array an array\n * @returns {boolean} true, if the array is sorted\n */\nconst isSorted = array => {\n  for (let i = 1; i < array.length; i++) {\n    if (array[i - 1] > array[i]) return false;\n  }\n  return true;\n};\n\n/**\n * @param {{[key: string]: any}} obj an object\n * @param {string[]} keys the keys of the object\n * @returns {{[key: string]: any}} the object with properties sorted by property name\n */\nconst sortObject = (obj, keys) => {\n  /** @type {{[key: string]: any}} */\n  const o = {};\n  for (const k of keys.sort()) {\n    o[k] = obj[k];\n  }\n  return o;\n};\n\n/**\n * @param {string} filename filename\n * @param {string | string[] | undefined} hashes list of hashes\n * @returns {boolean} true, if the filename contains any hash\n */\nconst includesHash = (filename, hashes) => {\n  if (!hashes) return false;\n  if (Array.isArray(hashes)) {\n    return hashes.some(hash => filename.includes(hash));\n  }\n  return filename.includes(hashes);\n};\nclass Compiler {\n  /**\n   * @param {string} context the compilation path\n   * @param {WebpackOptions} options options\n   */\n  constructor(context, options = (/** @type {WebpackOptions} */{})) {\n    this.hooks = Object.freeze({\n      /** @type {SyncHook<[]>} */\n      initialize: new SyncHook([]),\n      /** @type {SyncBailHook<[Compilation], boolean | undefined>} */\n      shouldEmit: new SyncBailHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<[Stats]>} */\n      done: new AsyncSeriesHook([\"stats\"]),\n      /** @type {SyncHook<[Stats]>} */\n      afterDone: new SyncHook([\"stats\"]),\n      /** @type {AsyncSeriesHook<[]>} */\n      additionalPass: new AsyncSeriesHook([]),\n      /** @type {AsyncSeriesHook<[Compiler]>} */\n      beforeRun: new AsyncSeriesHook([\"compiler\"]),\n      /** @type {AsyncSeriesHook<[Compiler]>} */\n      run: new AsyncSeriesHook([\"compiler\"]),\n      /** @type {AsyncSeriesHook<[Compilation]>} */\n      emit: new AsyncSeriesHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<[string, AssetEmittedInfo]>} */\n      assetEmitted: new AsyncSeriesHook([\"file\", \"info\"]),\n      /** @type {AsyncSeriesHook<[Compilation]>} */\n      afterEmit: new AsyncSeriesHook([\"compilation\"]),\n      /** @type {SyncHook<[Compilation, CompilationParams]>} */\n      thisCompilation: new SyncHook([\"compilation\", \"params\"]),\n      /** @type {SyncHook<[Compilation, CompilationParams]>} */\n      compilation: new SyncHook([\"compilation\", \"params\"]),\n      /** @type {SyncHook<[NormalModuleFactory]>} */\n      normalModuleFactory: new SyncHook([\"normalModuleFactory\"]),\n      /** @type {SyncHook<[ContextModuleFactory]>}  */\n      contextModuleFactory: new SyncHook([\"contextModuleFactory\"]),\n      /** @type {AsyncSeriesHook<[CompilationParams]>} */\n      beforeCompile: new AsyncSeriesHook([\"params\"]),\n      /** @type {SyncHook<[CompilationParams]>} */\n      compile: new SyncHook([\"params\"]),\n      /** @type {AsyncParallelHook<[Compilation]>} */\n      make: new AsyncParallelHook([\"compilation\"]),\n      /** @type {AsyncParallelHook<[Compilation]>} */\n      finishMake: new AsyncSeriesHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<[Compilation]>} */\n      afterCompile: new AsyncSeriesHook([\"compilation\"]),\n      /** @type {AsyncSeriesHook<[]>} */\n      readRecords: new AsyncSeriesHook([]),\n      /** @type {AsyncSeriesHook<[]>} */\n      emitRecords: new AsyncSeriesHook([]),\n      /** @type {AsyncSeriesHook<[Compiler]>} */\n      watchRun: new AsyncSeriesHook([\"compiler\"]),\n      /** @type {SyncHook<[Error]>} */\n      failed: new SyncHook([\"error\"]),\n      /** @type {SyncHook<[string | null, number]>} */\n      invalid: new SyncHook([\"filename\", \"changeTime\"]),\n      /** @type {SyncHook<[]>} */\n      watchClose: new SyncHook([]),\n      /** @type {AsyncSeriesHook<[]>} */\n      shutdown: new AsyncSeriesHook([]),\n      /** @type {SyncBailHook<[string, string, any[] | undefined], true>} */\n      infrastructureLog: new SyncBailHook([\"origin\", \"type\", \"args\"]),\n      // TODO the following hooks are weirdly located here\n      // TODO move them for webpack 5\n      /** @type {SyncHook<[]>} */\n      environment: new SyncHook([]),\n      /** @type {SyncHook<[]>} */\n      afterEnvironment: new SyncHook([]),\n      /** @type {SyncHook<[Compiler]>} */\n      afterPlugins: new SyncHook([\"compiler\"]),\n      /** @type {SyncHook<[Compiler]>} */\n      afterResolvers: new SyncHook([\"compiler\"]),\n      /** @type {SyncBailHook<[string, Entry], boolean>} */\n      entryOption: new SyncBailHook([\"context\", \"entry\"])\n    });\n    this.webpack = webpack;\n\n    /** @type {string | undefined} */\n    this.name = undefined;\n    /** @type {Compilation | undefined} */\n    this.parentCompilation = undefined;\n    /** @type {Compiler} */\n    this.root = this;\n    /** @type {string} */\n    this.outputPath = \"\";\n    /** @type {Watching | undefined} */\n    this.watching = undefined;\n\n    /** @type {OutputFileSystem | null} */\n    this.outputFileSystem = null;\n    /** @type {IntermediateFileSystem | null} */\n    this.intermediateFileSystem = null;\n    /** @type {InputFileSystem | null} */\n    this.inputFileSystem = null;\n    /** @type {WatchFileSystem | null} */\n    this.watchFileSystem = null;\n\n    /** @type {string|null} */\n    this.recordsInputPath = null;\n    /** @type {string|null} */\n    this.recordsOutputPath = null;\n    /** @type {Record<string, TODO>} */\n    this.records = {};\n    /** @type {Set<string | RegExp>} */\n    this.managedPaths = new Set();\n    /** @type {Set<string | RegExp>} */\n    this.unmanagedPaths = new Set();\n    /** @type {Set<string | RegExp>} */\n    this.immutablePaths = new Set();\n\n    /** @type {ReadonlySet<string> | undefined} */\n    this.modifiedFiles = undefined;\n    /** @type {ReadonlySet<string> | undefined} */\n    this.removedFiles = undefined;\n    /** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null> | undefined} */\n    this.fileTimestamps = undefined;\n    /** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null> | undefined} */\n    this.contextTimestamps = undefined;\n    /** @type {number | undefined} */\n    this.fsStartTime = undefined;\n\n    /** @type {ResolverFactory} */\n    this.resolverFactory = new ResolverFactory();\n\n    /** @type {LoggingFunction | undefined} */\n    this.infrastructureLogger = undefined;\n\n    /** @type {Readonly<PlatformTargetProperties>} */\n    this.platform = {\n      web: null,\n      browser: null,\n      webworker: null,\n      node: null,\n      nwjs: null,\n      electron: null\n    };\n    this.options = options;\n    this.context = context;\n    this.requestShortener = new RequestShortener(context, this.root);\n    this.cache = new Cache();\n\n    /** @type {Map<Module, { buildInfo: BuildInfo, references: References | undefined, memCache: WeakTupleMap<any, any> }> | undefined} */\n    this.moduleMemCaches = undefined;\n    this.compilerPath = \"\";\n\n    /** @type {boolean} */\n    this.running = false;\n\n    /** @type {boolean} */\n    this.idle = false;\n\n    /** @type {boolean} */\n    this.watchMode = false;\n    this._backCompat = this.options.experiments.backCompat !== false;\n\n    /** @type {Compilation | undefined} */\n    this._lastCompilation = undefined;\n    /** @type {NormalModuleFactory | undefined} */\n    this._lastNormalModuleFactory = undefined;\n\n    /**\n     * @private\n     * @type {WeakMap<Source, CacheEntry>}\n     */\n    this._assetEmittingSourceCache = new WeakMap();\n    /**\n     * @private\n     * @type {Map<string, number>}\n     */\n    this._assetEmittingWrittenFiles = new Map();\n    /**\n     * @private\n     * @type {Set<string>}\n     */\n    this._assetEmittingPreviousFiles = new Set();\n  }\n\n  /**\n   * @param {string} name cache name\n   * @returns {CacheFacade} the cache facade instance\n   */\n  getCache(name) {\n    return new CacheFacade(this.cache, `${this.compilerPath}${name}`, this.options.output.hashFunction);\n  }\n\n  /**\n   * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n   * @returns {Logger} a logger with that name\n   */\n  getInfrastructureLogger(name) {\n    if (!name) {\n      throw new TypeError(\"Compiler.getInfrastructureLogger(name) called without a name\");\n    }\n    return new Logger((type, args) => {\n      if (typeof name === \"function\") {\n        name = name();\n        if (!name) {\n          throw new TypeError(\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\");\n        }\n      }\n      if (this.hooks.infrastructureLog.call(name, type, args) === undefined && this.infrastructureLogger !== undefined) {\n        this.infrastructureLogger(name, type, args);\n      }\n    }, childName => {\n      if (typeof name === \"function\") {\n        if (typeof childName === \"function\") {\n          return this.getInfrastructureLogger(() => {\n            if (typeof name === \"function\") {\n              name = name();\n              if (!name) {\n                throw new TypeError(\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\");\n              }\n            }\n            if (typeof childName === \"function\") {\n              childName = childName();\n              if (!childName) {\n                throw new TypeError(\"Logger.getChildLogger(name) called with a function not returning a name\");\n              }\n            }\n            return `${name}/${childName}`;\n          });\n        }\n        return this.getInfrastructureLogger(() => {\n          if (typeof name === \"function\") {\n            name = name();\n            if (!name) {\n              throw new TypeError(\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\");\n            }\n          }\n          return `${name}/${childName}`;\n        });\n      }\n      if (typeof childName === \"function\") {\n        return this.getInfrastructureLogger(() => {\n          if (typeof childName === \"function\") {\n            childName = childName();\n            if (!childName) {\n              throw new TypeError(\"Logger.getChildLogger(name) called with a function not returning a name\");\n            }\n          }\n          return `${name}/${childName}`;\n        });\n      }\n      return this.getInfrastructureLogger(`${name}/${childName}`);\n    });\n  }\n\n  // TODO webpack 6: solve this in a better way\n  // e.g. move compilation specific info from Modules into ModuleGraph\n  _cleanupLastCompilation() {\n    if (this._lastCompilation !== undefined) {\n      for (const childCompilation of this._lastCompilation.children) {\n        for (const module of childCompilation.modules) {\n          ChunkGraph.clearChunkGraphForModule(module);\n          ModuleGraph.clearModuleGraphForModule(module);\n          module.cleanupForCache();\n        }\n        for (const chunk of childCompilation.chunks) {\n          ChunkGraph.clearChunkGraphForChunk(chunk);\n        }\n      }\n      for (const module of this._lastCompilation.modules) {\n        ChunkGraph.clearChunkGraphForModule(module);\n        ModuleGraph.clearModuleGraphForModule(module);\n        module.cleanupForCache();\n      }\n      for (const chunk of this._lastCompilation.chunks) {\n        ChunkGraph.clearChunkGraphForChunk(chunk);\n      }\n      this._lastCompilation = undefined;\n    }\n  }\n\n  // TODO webpack 6: solve this in a better way\n  _cleanupLastNormalModuleFactory() {\n    if (this._lastNormalModuleFactory !== undefined) {\n      this._lastNormalModuleFactory.cleanupForCache();\n      this._lastNormalModuleFactory = undefined;\n    }\n  }\n\n  /**\n   * @param {WatchOptions} watchOptions the watcher's options\n   * @param {RunCallback<Stats>} handler signals when the call finishes\n   * @returns {Watching} a compiler watcher\n   */\n  watch(watchOptions, handler) {\n    if (this.running) {\n      return handler(new ConcurrentCompilationError());\n    }\n    this.running = true;\n    this.watchMode = true;\n    this.watching = new Watching(this, watchOptions, handler);\n    return this.watching;\n  }\n\n  /**\n   * @param {RunCallback<Stats>} callback signals when the call finishes\n   * @returns {void}\n   */\n  run(callback) {\n    if (this.running) {\n      return callback(new ConcurrentCompilationError());\n    }\n\n    /** @type {Logger | undefined} */\n    let logger;\n\n    /**\n     * @param {Error | null} err error\n     * @param {Stats=} stats stats\n     */\n    const finalCallback = (err, stats) => {\n      if (logger) logger.time(\"beginIdle\");\n      this.idle = true;\n      this.cache.beginIdle();\n      this.idle = true;\n      if (logger) logger.timeEnd(\"beginIdle\");\n      this.running = false;\n      if (err) {\n        this.hooks.failed.call(err);\n      }\n      if (callback !== undefined) callback(err, stats);\n      this.hooks.afterDone.call(/** @type {Stats} */stats);\n    };\n    const startTime = Date.now();\n    this.running = true;\n\n    /**\n     * @param {Error | null} err error\n     * @param {Compilation=} _compilation compilation\n     * @returns {void}\n     */\n    const onCompiled = (err, _compilation) => {\n      if (err) return finalCallback(err);\n      const compilation = /** @type {Compilation} */_compilation;\n      if (this.hooks.shouldEmit.call(compilation) === false) {\n        compilation.startTime = startTime;\n        compilation.endTime = Date.now();\n        const stats = new Stats(compilation);\n        this.hooks.done.callAsync(stats, err => {\n          if (err) return finalCallback(err);\n          return finalCallback(null, stats);\n        });\n        return;\n      }\n      process.nextTick(() => {\n        logger = compilation.getLogger(\"webpack.Compiler\");\n        logger.time(\"emitAssets\");\n        this.emitAssets(compilation, err => {\n          /** @type {Logger} */\n          logger.timeEnd(\"emitAssets\");\n          if (err) return finalCallback(err);\n          if (compilation.hooks.needAdditionalPass.call()) {\n            compilation.needAdditionalPass = true;\n            compilation.startTime = startTime;\n            compilation.endTime = Date.now();\n            /** @type {Logger} */\n            logger.time(\"done hook\");\n            const stats = new Stats(compilation);\n            this.hooks.done.callAsync(stats, err => {\n              /** @type {Logger} */\n              logger.timeEnd(\"done hook\");\n              if (err) return finalCallback(err);\n              this.hooks.additionalPass.callAsync(err => {\n                if (err) return finalCallback(err);\n                this.compile(onCompiled);\n              });\n            });\n            return;\n          }\n\n          /** @type {Logger} */\n          logger.time(\"emitRecords\");\n          this.emitRecords(err => {\n            /** @type {Logger} */\n            logger.timeEnd(\"emitRecords\");\n            if (err) return finalCallback(err);\n            compilation.startTime = startTime;\n            compilation.endTime = Date.now();\n            /** @type {Logger} */\n            logger.time(\"done hook\");\n            const stats = new Stats(compilation);\n            this.hooks.done.callAsync(stats, err => {\n              /** @type {Logger} */\n              logger.timeEnd(\"done hook\");\n              if (err) return finalCallback(err);\n              this.cache.storeBuildDependencies(compilation.buildDependencies, err => {\n                if (err) return finalCallback(err);\n                return finalCallback(null, stats);\n              });\n            });\n          });\n        });\n      });\n    };\n    const run = () => {\n      this.hooks.beforeRun.callAsync(this, err => {\n        if (err) return finalCallback(err);\n        this.hooks.run.callAsync(this, err => {\n          if (err) return finalCallback(err);\n          this.readRecords(err => {\n            if (err) return finalCallback(err);\n            this.compile(onCompiled);\n          });\n        });\n      });\n    };\n    if (this.idle) {\n      this.cache.endIdle(err => {\n        if (err) return finalCallback(err);\n        this.idle = false;\n        run();\n      });\n    } else {\n      run();\n    }\n  }\n\n  /**\n   * @param {RunAsChildCallback} callback signals when the call finishes\n   * @returns {void}\n   */\n  runAsChild(callback) {\n    const startTime = Date.now();\n\n    /**\n     * @param {Error | null} err error\n     * @param {Chunk[]=} entries entries\n     * @param {Compilation=} compilation compilation\n     */\n    const finalCallback = (err, entries, compilation) => {\n      try {\n        callback(err, entries, compilation);\n      } catch (runAsChildErr) {\n        const err = new WebpackError(`compiler.runAsChild callback error: ${runAsChildErr}`);\n        err.details = /** @type {Error} */runAsChildErr.stack;\n        /** @type {Compilation} */\n        this.parentCompilation.errors.push(err);\n      }\n    };\n    this.compile((err, _compilation) => {\n      if (err) return finalCallback(err);\n      const compilation = /** @type {Compilation} */_compilation;\n      const parentCompilation = /** @type {Compilation} */\n      this.parentCompilation;\n      parentCompilation.children.push(compilation);\n      for (const {\n        name,\n        source,\n        info\n      } of compilation.getAssets()) {\n        parentCompilation.emitAsset(name, source, info);\n      }\n\n      /** @type {Chunk[]} */\n      const entries = [];\n      for (const ep of compilation.entrypoints.values()) {\n        entries.push(...ep.chunks);\n      }\n      compilation.startTime = startTime;\n      compilation.endTime = Date.now();\n      return finalCallback(null, entries, compilation);\n    });\n  }\n  purgeInputFileSystem() {\n    if (this.inputFileSystem && this.inputFileSystem.purge) {\n      this.inputFileSystem.purge();\n    }\n  }\n\n  /**\n   * @param {Compilation} compilation the compilation\n   * @param {Callback<void>} callback signals when the assets are emitted\n   * @returns {void}\n   */\n  emitAssets(compilation, callback) {\n    /** @type {string} */\n    let outputPath;\n\n    /**\n     * @param {Error=} err error\n     * @returns {void}\n     */\n    const emitFiles = err => {\n      if (err) return callback(err);\n      const assets = compilation.getAssets();\n      compilation.assets = {\n        ...compilation.assets\n      };\n      /** @type {Map<string, SimilarEntry>} */\n      const caseInsensitiveMap = new Map();\n      /** @type {Set<string>} */\n      const allTargetPaths = new Set();\n      asyncLib.forEachLimit(assets, 15, ({\n        name: file,\n        source,\n        info\n      }, callback) => {\n        let targetFile = file;\n        let immutable = info.immutable;\n        const queryStringIdx = targetFile.indexOf(\"?\");\n        if (queryStringIdx >= 0) {\n          targetFile = targetFile.slice(0, queryStringIdx);\n          // We may remove the hash, which is in the query string\n          // So we recheck if the file is immutable\n          // This doesn't cover all cases, but immutable is only a performance optimization anyway\n          immutable = immutable && (includesHash(targetFile, info.contenthash) || includesHash(targetFile, info.chunkhash) || includesHash(targetFile, info.modulehash) || includesHash(targetFile, info.fullhash));\n        }\n\n        /**\n         * @param {Error=} err error\n         * @returns {void}\n         */\n        const writeOut = err => {\n          if (err) return callback(err);\n          const targetPath = join(/** @type {OutputFileSystem} */\n          this.outputFileSystem, outputPath, targetFile);\n          allTargetPaths.add(targetPath);\n\n          // check if the target file has already been written by this Compiler\n          const targetFileGeneration = this._assetEmittingWrittenFiles.get(targetPath);\n\n          // create an cache entry for this Source if not already existing\n          let cacheEntry = this._assetEmittingSourceCache.get(source);\n          if (cacheEntry === undefined) {\n            cacheEntry = {\n              sizeOnlySource: undefined,\n              writtenTo: new Map()\n            };\n            this._assetEmittingSourceCache.set(source, cacheEntry);\n          }\n\n          /** @type {SimilarEntry | undefined} */\n          let similarEntry;\n          const checkSimilarFile = () => {\n            const caseInsensitiveTargetPath = targetPath.toLowerCase();\n            similarEntry = caseInsensitiveMap.get(caseInsensitiveTargetPath);\n            if (similarEntry !== undefined) {\n              const {\n                path: other,\n                source: otherSource\n              } = similarEntry;\n              if (isSourceEqual(otherSource, source)) {\n                // Size may or may not be available at this point.\n                // If it's not available add to \"waiting\" list and it will be updated once available\n                if (similarEntry.size !== undefined) {\n                  updateWithReplacementSource(similarEntry.size);\n                } else {\n                  if (!similarEntry.waiting) similarEntry.waiting = [];\n                  similarEntry.waiting.push({\n                    file,\n                    cacheEntry\n                  });\n                }\n                alreadyWritten();\n              } else {\n                const err = new WebpackError(`Prevent writing to file that only differs in casing or query string from already written file.\nThis will lead to a race-condition and corrupted files on case-insensitive file systems.\n${targetPath}\n${other}`);\n                err.file = file;\n                callback(err);\n              }\n              return true;\n            }\n            caseInsensitiveMap.set(caseInsensitiveTargetPath, similarEntry = /** @type {SimilarEntry} */{\n              path: targetPath,\n              source,\n              size: undefined,\n              waiting: undefined\n            });\n            return false;\n          };\n\n          /**\n           * get the binary (Buffer) content from the Source\n           * @returns {Buffer} content for the source\n           */\n          const getContent = () => {\n            if (typeof source.buffer === \"function\") {\n              return source.buffer();\n            }\n            const bufferOrString = source.source();\n            if (Buffer.isBuffer(bufferOrString)) {\n              return bufferOrString;\n            }\n            return Buffer.from(bufferOrString, \"utf8\");\n          };\n          const alreadyWritten = () => {\n            // cache the information that the Source has been already been written to that location\n            if (targetFileGeneration === undefined) {\n              const newGeneration = 1;\n              this._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n              /** @type {CacheEntry} */\n              cacheEntry.writtenTo.set(targetPath, newGeneration);\n            } else {\n              /** @type {CacheEntry} */\n              cacheEntry.writtenTo.set(targetPath, targetFileGeneration);\n            }\n            callback();\n          };\n\n          /**\n           * Write the file to output file system\n           * @param {Buffer} content content to be written\n           * @returns {void}\n           */\n          const doWrite = content => {\n            /** @type {OutputFileSystem} */\n            this.outputFileSystem.writeFile(targetPath, content, err => {\n              if (err) return callback(err);\n\n              // information marker that the asset has been emitted\n              compilation.emittedAssets.add(file);\n\n              // cache the information that the Source has been written to that location\n              const newGeneration = targetFileGeneration === undefined ? 1 : targetFileGeneration + 1;\n              /** @type {CacheEntry} */\n              cacheEntry.writtenTo.set(targetPath, newGeneration);\n              this._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n              this.hooks.assetEmitted.callAsync(file, {\n                content,\n                source,\n                outputPath,\n                compilation,\n                targetPath\n              }, callback);\n            });\n          };\n\n          /**\n           * @param {number} size size\n           */\n          const updateWithReplacementSource = size => {\n            updateFileWithReplacementSource(file, /** @type {CacheEntry} */cacheEntry, size);\n            /** @type {SimilarEntry} */\n            similarEntry.size = size;\n            if (/** @type {SimilarEntry} */similarEntry.waiting !== undefined) {\n              for (const {\n                file,\n                cacheEntry\n              } of /** @type {SimilarEntry} */similarEntry.waiting) {\n                updateFileWithReplacementSource(file, cacheEntry, size);\n              }\n            }\n          };\n\n          /**\n           * @param {string} file file\n           * @param {CacheEntry} cacheEntry cache entry\n           * @param {number} size size\n           */\n          const updateFileWithReplacementSource = (file, cacheEntry, size) => {\n            // Create a replacement resource which only allows to ask for size\n            // This allows to GC all memory allocated by the Source\n            // (expect when the Source is stored in any other cache)\n            if (!cacheEntry.sizeOnlySource) {\n              cacheEntry.sizeOnlySource = new SizeOnlySource(size);\n            }\n            compilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n              size\n            });\n          };\n\n          /**\n           * @param {IStats} stats stats\n           * @returns {void}\n           */\n          const processExistingFile = stats => {\n            // skip emitting if it's already there and an immutable file\n            if (immutable) {\n              updateWithReplacementSource(/** @type {number} */stats.size);\n              return alreadyWritten();\n            }\n            const content = getContent();\n            updateWithReplacementSource(content.length);\n\n            // if it exists and content on disk matches content\n            // skip writing the same content again\n            // (to keep mtime and don't trigger watchers)\n            // for a fast negative match file size is compared first\n            if (content.length === stats.size) {\n              compilation.comparedForEmitAssets.add(file);\n              return /** @type {OutputFileSystem} */this.outputFileSystem.readFile(targetPath, (err, existingContent) => {\n                if (err || !content.equals(/** @type {Buffer} */existingContent)) {\n                  return doWrite(content);\n                }\n                return alreadyWritten();\n              });\n            }\n            return doWrite(content);\n          };\n          const processMissingFile = () => {\n            const content = getContent();\n            updateWithReplacementSource(content.length);\n            return doWrite(content);\n          };\n\n          // if the target file has already been written\n          if (targetFileGeneration !== undefined) {\n            // check if the Source has been written to this target file\n            const writtenGeneration = /** @type {CacheEntry} */cacheEntry.writtenTo.get(targetPath);\n            if (writtenGeneration === targetFileGeneration) {\n              // if yes, we may skip writing the file\n              // if it's already there\n              // (we assume one doesn't modify files while the Compiler is running, other then removing them)\n\n              if (this._assetEmittingPreviousFiles.has(targetPath)) {\n                const sizeOnlySource = /** @type {SizeOnlySource} */\n                /** @type {CacheEntry} */cacheEntry.sizeOnlySource;\n\n                // We assume that assets from the last compilation say intact on disk (they are not removed)\n                compilation.updateAsset(file, sizeOnlySource, {\n                  size: sizeOnlySource.size()\n                });\n                return callback();\n              }\n              // Settings immutable will make it accept file content without comparing when file exist\n              immutable = true;\n            } else if (!immutable) {\n              if (checkSimilarFile()) return;\n              // We wrote to this file before which has very likely a different content\n              // skip comparing and assume content is different for performance\n              // This case happens often during watch mode.\n              return processMissingFile();\n            }\n          }\n          if (checkSimilarFile()) return;\n          if (this.options.output.compareBeforeEmit) {\n            /** @type {OutputFileSystem} */\n            this.outputFileSystem.stat(targetPath, (err, stats) => {\n              const exists = !err && /** @type {IStats} */stats.isFile();\n              if (exists) {\n                processExistingFile(/** @type {IStats} */stats);\n              } else {\n                processMissingFile();\n              }\n            });\n          } else {\n            processMissingFile();\n          }\n        };\n        if (/\\/|\\\\/.test(targetFile)) {\n          const fs = /** @type {OutputFileSystem} */this.outputFileSystem;\n          const dir = dirname(fs, join(fs, outputPath, targetFile));\n          mkdirp(fs, dir, writeOut);\n        } else {\n          writeOut();\n        }\n      }, err => {\n        // Clear map to free up memory\n        caseInsensitiveMap.clear();\n        if (err) {\n          this._assetEmittingPreviousFiles.clear();\n          return callback(err);\n        }\n        this._assetEmittingPreviousFiles = allTargetPaths;\n        this.hooks.afterEmit.callAsync(compilation, err => {\n          if (err) return callback(err);\n          return callback();\n        });\n      });\n    };\n    this.hooks.emit.callAsync(compilation, err => {\n      if (err) return callback(err);\n      outputPath = compilation.getPath(this.outputPath, {});\n      mkdirp(/** @type {OutputFileSystem} */this.outputFileSystem, outputPath, emitFiles);\n    });\n  }\n\n  /**\n   * @param {Callback<void>} callback signals when the call finishes\n   * @returns {void}\n   */\n  emitRecords(callback) {\n    if (this.hooks.emitRecords.isUsed()) {\n      if (this.recordsOutputPath) {\n        asyncLib.parallel([cb => this.hooks.emitRecords.callAsync(cb), this._emitRecords.bind(this)], err => callback(err));\n      } else {\n        this.hooks.emitRecords.callAsync(callback);\n      }\n    } else if (this.recordsOutputPath) {\n      this._emitRecords(callback);\n    } else {\n      callback();\n    }\n  }\n\n  /**\n   * @param {Callback<void>} callback signals when the call finishes\n   * @returns {void}\n   */\n  _emitRecords(callback) {\n    const writeFile = () => {\n      /** @type {OutputFileSystem} */\n      this.outputFileSystem.writeFile(/** @type {string} */this.recordsOutputPath, JSON.stringify(this.records, (n, value) => {\n        if (typeof value === \"object\" && value !== null && !Array.isArray(value)) {\n          const keys = Object.keys(value);\n          if (!isSorted(keys)) {\n            return sortObject(value, keys);\n          }\n        }\n        return value;\n      }, 2), callback);\n    };\n    const recordsOutputPathDirectory = dirname(/** @type {OutputFileSystem} */this.outputFileSystem, /** @type {string} */this.recordsOutputPath);\n    if (!recordsOutputPathDirectory) {\n      return writeFile();\n    }\n    mkdirp(/** @type {OutputFileSystem} */this.outputFileSystem, recordsOutputPathDirectory, err => {\n      if (err) return callback(err);\n      writeFile();\n    });\n  }\n\n  /**\n   * @param {Callback<void>} callback signals when the call finishes\n   * @returns {void}\n   */\n  readRecords(callback) {\n    if (this.hooks.readRecords.isUsed()) {\n      if (this.recordsInputPath) {\n        asyncLib.parallel([cb => this.hooks.readRecords.callAsync(cb), this._readRecords.bind(this)], err => callback(err));\n      } else {\n        this.records = {};\n        this.hooks.readRecords.callAsync(callback);\n      }\n    } else if (this.recordsInputPath) {\n      this._readRecords(callback);\n    } else {\n      this.records = {};\n      callback();\n    }\n  }\n\n  /**\n   * @param {Callback<void>} callback signals when the call finishes\n   * @returns {void}\n   */\n  _readRecords(callback) {\n    if (!this.recordsInputPath) {\n      this.records = {};\n      return callback();\n    }\n    /** @type {InputFileSystem} */\n    this.inputFileSystem.stat(this.recordsInputPath, err => {\n      // It doesn't exist\n      // We can ignore this.\n      if (err) return callback();\n\n      /** @type {InputFileSystem} */\n      this.inputFileSystem.readFile(/** @type {string} */this.recordsInputPath, (err, content) => {\n        if (err) return callback(err);\n        try {\n          this.records = parseJson(/** @type {Buffer} */content.toString(\"utf-8\"));\n        } catch (parseErr) {\n          return callback(new Error(`Cannot parse records: ${/** @type {Error} */parseErr.message}`));\n        }\n        return callback();\n      });\n    });\n  }\n\n  /**\n   * @param {Compilation} compilation the compilation\n   * @param {string} compilerName the compiler's name\n   * @param {number} compilerIndex the compiler's index\n   * @param {OutputOptions=} outputOptions the output options\n   * @param {WebpackPluginInstance[]=} plugins the plugins to apply\n   * @returns {Compiler} a child compiler\n   */\n  createChildCompiler(compilation, compilerName, compilerIndex, outputOptions, plugins) {\n    const childCompiler = new Compiler(this.context, {\n      ...this.options,\n      output: {\n        ...this.options.output,\n        ...outputOptions\n      }\n    });\n    childCompiler.name = compilerName;\n    childCompiler.outputPath = this.outputPath;\n    childCompiler.inputFileSystem = this.inputFileSystem;\n    childCompiler.outputFileSystem = null;\n    childCompiler.resolverFactory = this.resolverFactory;\n    childCompiler.modifiedFiles = this.modifiedFiles;\n    childCompiler.removedFiles = this.removedFiles;\n    childCompiler.fileTimestamps = this.fileTimestamps;\n    childCompiler.contextTimestamps = this.contextTimestamps;\n    childCompiler.fsStartTime = this.fsStartTime;\n    childCompiler.cache = this.cache;\n    childCompiler.compilerPath = `${this.compilerPath}${compilerName}|${compilerIndex}|`;\n    childCompiler._backCompat = this._backCompat;\n    const relativeCompilerName = makePathsRelative(this.context, compilerName, this.root);\n    if (!this.records[relativeCompilerName]) {\n      this.records[relativeCompilerName] = [];\n    }\n    if (this.records[relativeCompilerName][compilerIndex]) {\n      childCompiler.records = this.records[relativeCompilerName][compilerIndex];\n    } else {\n      this.records[relativeCompilerName].push(childCompiler.records = {});\n    }\n    childCompiler.parentCompilation = compilation;\n    childCompiler.root = this.root;\n    if (Array.isArray(plugins)) {\n      for (const plugin of plugins) {\n        if (plugin) {\n          plugin.apply(childCompiler);\n        }\n      }\n    }\n    for (const name in this.hooks) {\n      if (![\"make\", \"compile\", \"emit\", \"afterEmit\", \"invalid\", \"done\", \"thisCompilation\"].includes(name) && childCompiler.hooks[(/** @type {keyof Compiler[\"hooks\"]} */name)]) {\n        childCompiler.hooks[(/** @type {keyof Compiler[\"hooks\"]} */\n        name)].taps = this.hooks[(/** @type {keyof Compiler[\"hooks\"]} */\n        name)].taps.slice();\n      }\n    }\n    compilation.hooks.childCompiler.call(childCompiler, compilerName, compilerIndex);\n    return childCompiler;\n  }\n  isChild() {\n    return Boolean(this.parentCompilation);\n  }\n\n  /**\n   * @param {CompilationParams} params the compilation parameters\n   * @returns {Compilation} compilation\n   */\n  createCompilation(params) {\n    this._cleanupLastCompilation();\n    return this._lastCompilation = new Compilation(this, params);\n  }\n\n  /**\n   * @param {CompilationParams} params the compilation parameters\n   * @returns {Compilation} the created compilation\n   */\n  newCompilation(params) {\n    const compilation = this.createCompilation(params);\n    compilation.name = this.name;\n    compilation.records = this.records;\n    this.hooks.thisCompilation.call(compilation, params);\n    this.hooks.compilation.call(compilation, params);\n    return compilation;\n  }\n  createNormalModuleFactory() {\n    this._cleanupLastNormalModuleFactory();\n    const normalModuleFactory = new NormalModuleFactory({\n      context: this.options.context,\n      fs: (/** @type {InputFileSystem} */this.inputFileSystem),\n      resolverFactory: this.resolverFactory,\n      options: this.options.module,\n      associatedObjectForCache: this.root,\n      layers: this.options.experiments.layers\n    });\n    this._lastNormalModuleFactory = normalModuleFactory;\n    this.hooks.normalModuleFactory.call(normalModuleFactory);\n    return normalModuleFactory;\n  }\n  createContextModuleFactory() {\n    const contextModuleFactory = new ContextModuleFactory(this.resolverFactory);\n    this.hooks.contextModuleFactory.call(contextModuleFactory);\n    return contextModuleFactory;\n  }\n  newCompilationParams() {\n    const params = {\n      normalModuleFactory: this.createNormalModuleFactory(),\n      contextModuleFactory: this.createContextModuleFactory()\n    };\n    return params;\n  }\n\n  /**\n   * @param {RunCallback<Compilation>} callback signals when the compilation finishes\n   * @returns {void}\n   */\n  compile(callback) {\n    const params = this.newCompilationParams();\n    this.hooks.beforeCompile.callAsync(params, err => {\n      if (err) return callback(err);\n      this.hooks.compile.call(params);\n      const compilation = this.newCompilation(params);\n      const logger = compilation.getLogger(\"webpack.Compiler\");\n      logger.time(\"make hook\");\n      this.hooks.make.callAsync(compilation, err => {\n        logger.timeEnd(\"make hook\");\n        if (err) return callback(err);\n        logger.time(\"finish make hook\");\n        this.hooks.finishMake.callAsync(compilation, err => {\n          logger.timeEnd(\"finish make hook\");\n          if (err) return callback(err);\n          process.nextTick(() => {\n            logger.time(\"finish compilation\");\n            compilation.finish(err => {\n              logger.timeEnd(\"finish compilation\");\n              if (err) return callback(err);\n              logger.time(\"seal compilation\");\n              compilation.seal(err => {\n                logger.timeEnd(\"seal compilation\");\n                if (err) return callback(err);\n                logger.time(\"afterCompile hook\");\n                this.hooks.afterCompile.callAsync(compilation, err => {\n                  logger.timeEnd(\"afterCompile hook\");\n                  if (err) return callback(err);\n                  return callback(null, compilation);\n                });\n              });\n            });\n          });\n        });\n      });\n    });\n  }\n\n  /**\n   * @param {RunCallback<void>} callback signals when the compiler closes\n   * @returns {void}\n   */\n  close(callback) {\n    if (this.watching) {\n      // When there is still an active watching, close this first\n      this.watching.close(err => {\n        this.close(callback);\n      });\n      return;\n    }\n    this.hooks.shutdown.callAsync(err => {\n      if (err) return callback(err);\n      // Get rid of reference to last compilation to avoid leaking memory\n      // We can't run this._cleanupLastCompilation() as the Stats to this compilation\n      // might be still in use. We try to get rid of the reference to the cache instead.\n      this._lastCompilation = undefined;\n      this._lastNormalModuleFactory = undefined;\n      this.cache.shutdown(callback);\n    });\n  }\n}\nmodule.exports = Compiler;","map":{"version":3,"names":["parseJson","require","asyncLib","SyncHook","SyncBailHook","AsyncParallelHook","AsyncSeriesHook","SizeOnlySource","webpack","Cache","CacheFacade","ChunkGraph","Compilation","ConcurrentCompilationError","ContextModuleFactory","ModuleGraph","NormalModuleFactory","RequestShortener","ResolverFactory","Stats","Watching","WebpackError","Logger","join","dirname","mkdirp","makePathsRelative","isSourceEqual","isSorted","array","i","length","sortObject","obj","keys","o","k","sort","includesHash","filename","hashes","Array","isArray","some","hash","includes","Compiler","constructor","context","options","hooks","Object","freeze","initialize","shouldEmit","done","afterDone","additionalPass","beforeRun","run","emit","assetEmitted","afterEmit","thisCompilation","compilation","normalModuleFactory","contextModuleFactory","beforeCompile","compile","make","finishMake","afterCompile","readRecords","emitRecords","watchRun","failed","invalid","watchClose","shutdown","infrastructureLog","environment","afterEnvironment","afterPlugins","afterResolvers","entryOption","name","undefined","parentCompilation","root","outputPath","watching","outputFileSystem","intermediateFileSystem","inputFileSystem","watchFileSystem","recordsInputPath","recordsOutputPath","records","managedPaths","Set","unmanagedPaths","immutablePaths","modifiedFiles","removedFiles","fileTimestamps","contextTimestamps","fsStartTime","resolverFactory","infrastructureLogger","platform","web","browser","webworker","node","nwjs","electron","requestShortener","cache","moduleMemCaches","compilerPath","running","idle","watchMode","_backCompat","experiments","backCompat","_lastCompilation","_lastNormalModuleFactory","_assetEmittingSourceCache","WeakMap","_assetEmittingWrittenFiles","Map","_assetEmittingPreviousFiles","getCache","output","hashFunction","getInfrastructureLogger","TypeError","type","args","call","childName","_cleanupLastCompilation","childCompilation","children","module","modules","clearChunkGraphForModule","clearModuleGraphForModule","cleanupForCache","chunk","chunks","clearChunkGraphForChunk","_cleanupLastNormalModuleFactory","watch","watchOptions","handler","callback","logger","finalCallback","err","stats","time","beginIdle","timeEnd","startTime","Date","now","onCompiled","_compilation","endTime","callAsync","process","nextTick","getLogger","emitAssets","needAdditionalPass","storeBuildDependencies","buildDependencies","endIdle","runAsChild","entries","runAsChildErr","details","stack","errors","push","source","info","getAssets","emitAsset","ep","entrypoints","values","purgeInputFileSystem","purge","emitFiles","assets","caseInsensitiveMap","allTargetPaths","forEachLimit","file","targetFile","immutable","queryStringIdx","indexOf","slice","contenthash","chunkhash","modulehash","fullhash","writeOut","targetPath","add","targetFileGeneration","get","cacheEntry","sizeOnlySource","writtenTo","set","similarEntry","checkSimilarFile","caseInsensitiveTargetPath","toLowerCase","path","other","otherSource","size","updateWithReplacementSource","waiting","alreadyWritten","getContent","buffer","bufferOrString","Buffer","isBuffer","from","newGeneration","doWrite","content","writeFile","emittedAssets","updateFileWithReplacementSource","updateAsset","processExistingFile","comparedForEmitAssets","readFile","existingContent","equals","processMissingFile","writtenGeneration","has","compareBeforeEmit","stat","exists","isFile","test","fs","dir","clear","getPath","isUsed","parallel","cb","_emitRecords","bind","JSON","stringify","n","value","recordsOutputPathDirectory","_readRecords","toString","parseErr","Error","message","createChildCompiler","compilerName","compilerIndex","outputOptions","plugins","childCompiler","relativeCompilerName","plugin","apply","taps","isChild","Boolean","createCompilation","params","newCompilation","createNormalModuleFactory","associatedObjectForCache","layers","createContextModuleFactory","newCompilationParams","finish","seal","close","exports"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/webpack/lib/Compiler.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst parseJson = require(\"json-parse-even-better-errors\");\nconst asyncLib = require(\"neo-async\");\nconst {\n\tSyncHook,\n\tSyncBailHook,\n\tAsyncParallelHook,\n\tAsyncSeriesHook\n} = require(\"tapable\");\nconst { SizeOnlySource } = require(\"webpack-sources\");\nconst webpack = require(\".\");\nconst Cache = require(\"./Cache\");\nconst CacheFacade = require(\"./CacheFacade\");\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Compilation = require(\"./Compilation\");\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nconst ContextModuleFactory = require(\"./ContextModuleFactory\");\nconst ModuleGraph = require(\"./ModuleGraph\");\nconst NormalModuleFactory = require(\"./NormalModuleFactory\");\nconst RequestShortener = require(\"./RequestShortener\");\nconst ResolverFactory = require(\"./ResolverFactory\");\nconst Stats = require(\"./Stats\");\nconst Watching = require(\"./Watching\");\nconst WebpackError = require(\"./WebpackError\");\nconst { Logger } = require(\"./logging/Logger\");\nconst { join, dirname, mkdirp } = require(\"./util/fs\");\nconst { makePathsRelative } = require(\"./util/identifier\");\nconst { isSourceEqual } = require(\"./util/source\");\n\n/** @typedef {import(\"webpack-sources\").Source} Source */\n/** @typedef {import(\"../declarations/WebpackOptions\").EntryNormalized} Entry */\n/** @typedef {import(\"../declarations/WebpackOptions\").OutputNormalized} OutputOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackOptionsNormalized} WebpackOptions */\n/** @typedef {import(\"../declarations/WebpackOptions\").WebpackPluginInstance} WebpackPluginInstance */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Compilation\").References} References */\n/** @typedef {import(\"./Dependency\")} Dependency */\n/** @typedef {import(\"./FileSystemInfo\").FileSystemInfoEntry} FileSystemInfoEntry */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Module\").BuildInfo} BuildInfo */\n/** @typedef {import(\"./config/target\").PlatformTargetProperties} PlatformTargetProperties */\n/** @typedef {import(\"./logging/createConsoleLogger\").LoggingFunction} LoggingFunction */\n/** @typedef {import(\"./util/fs\").IStats} IStats */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @template {any[]} T\n * @template V\n * @typedef {import(\"./util/WeakTupleMap\")<T, V>} WeakTupleMap\n */\n\n/**\n * @typedef {object} CompilationParams\n * @property {NormalModuleFactory} normalModuleFactory\n * @property {ContextModuleFactory} contextModuleFactory\n */\n\n/**\n * @template T\n * @callback RunCallback\n * @param {Error | null} err\n * @param {T=} result\n */\n\n/**\n * @template T\n * @callback Callback\n * @param {(Error | null)=} err\n * @param {T=} result\n */\n\n/**\n * @callback RunAsChildCallback\n * @param {Error | null} err\n * @param {Chunk[]=} entries\n * @param {Compilation=} compilation\n */\n\n/**\n * @typedef {object} AssetEmittedInfo\n * @property {Buffer} content\n * @property {Source} source\n * @property {Compilation} compilation\n * @property {string} outputPath\n * @property {string} targetPath\n */\n\n/** @typedef {{ sizeOnlySource: SizeOnlySource | undefined, writtenTo: Map<string, number> }} CacheEntry */\n/** @typedef {{ path: string, source: Source, size: number | undefined, waiting: ({ cacheEntry: any, file: string }[] | undefined) }} SimilarEntry */\n\n/**\n * @param {string[]} array an array\n * @returns {boolean} true, if the array is sorted\n */\nconst isSorted = array => {\n\tfor (let i = 1; i < array.length; i++) {\n\t\tif (array[i - 1] > array[i]) return false;\n\t}\n\treturn true;\n};\n\n/**\n * @param {{[key: string]: any}} obj an object\n * @param {string[]} keys the keys of the object\n * @returns {{[key: string]: any}} the object with properties sorted by property name\n */\nconst sortObject = (obj, keys) => {\n\t/** @type {{[key: string]: any}} */\n\tconst o = {};\n\tfor (const k of keys.sort()) {\n\t\to[k] = obj[k];\n\t}\n\treturn o;\n};\n\n/**\n * @param {string} filename filename\n * @param {string | string[] | undefined} hashes list of hashes\n * @returns {boolean} true, if the filename contains any hash\n */\nconst includesHash = (filename, hashes) => {\n\tif (!hashes) return false;\n\tif (Array.isArray(hashes)) {\n\t\treturn hashes.some(hash => filename.includes(hash));\n\t}\n\treturn filename.includes(hashes);\n};\n\nclass Compiler {\n\t/**\n\t * @param {string} context the compilation path\n\t * @param {WebpackOptions} options options\n\t */\n\tconstructor(context, options = /** @type {WebpackOptions} */ ({})) {\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\tinitialize: new SyncHook([]),\n\n\t\t\t/** @type {SyncBailHook<[Compilation], boolean | undefined>} */\n\t\t\tshouldEmit: new SyncBailHook([\"compilation\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Stats]>} */\n\t\t\tdone: new AsyncSeriesHook([\"stats\"]),\n\t\t\t/** @type {SyncHook<[Stats]>} */\n\t\t\tafterDone: new SyncHook([\"stats\"]),\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\tadditionalPass: new AsyncSeriesHook([]),\n\t\t\t/** @type {AsyncSeriesHook<[Compiler]>} */\n\t\t\tbeforeRun: new AsyncSeriesHook([\"compiler\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compiler]>} */\n\t\t\trun: new AsyncSeriesHook([\"compiler\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compilation]>} */\n\t\t\temit: new AsyncSeriesHook([\"compilation\"]),\n\t\t\t/** @type {AsyncSeriesHook<[string, AssetEmittedInfo]>} */\n\t\t\tassetEmitted: new AsyncSeriesHook([\"file\", \"info\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compilation]>} */\n\t\t\tafterEmit: new AsyncSeriesHook([\"compilation\"]),\n\n\t\t\t/** @type {SyncHook<[Compilation, CompilationParams]>} */\n\t\t\tthisCompilation: new SyncHook([\"compilation\", \"params\"]),\n\t\t\t/** @type {SyncHook<[Compilation, CompilationParams]>} */\n\t\t\tcompilation: new SyncHook([\"compilation\", \"params\"]),\n\t\t\t/** @type {SyncHook<[NormalModuleFactory]>} */\n\t\t\tnormalModuleFactory: new SyncHook([\"normalModuleFactory\"]),\n\t\t\t/** @type {SyncHook<[ContextModuleFactory]>}  */\n\t\t\tcontextModuleFactory: new SyncHook([\"contextModuleFactory\"]),\n\n\t\t\t/** @type {AsyncSeriesHook<[CompilationParams]>} */\n\t\t\tbeforeCompile: new AsyncSeriesHook([\"params\"]),\n\t\t\t/** @type {SyncHook<[CompilationParams]>} */\n\t\t\tcompile: new SyncHook([\"params\"]),\n\t\t\t/** @type {AsyncParallelHook<[Compilation]>} */\n\t\t\tmake: new AsyncParallelHook([\"compilation\"]),\n\t\t\t/** @type {AsyncParallelHook<[Compilation]>} */\n\t\t\tfinishMake: new AsyncSeriesHook([\"compilation\"]),\n\t\t\t/** @type {AsyncSeriesHook<[Compilation]>} */\n\t\t\tafterCompile: new AsyncSeriesHook([\"compilation\"]),\n\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\treadRecords: new AsyncSeriesHook([]),\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\temitRecords: new AsyncSeriesHook([]),\n\n\t\t\t/** @type {AsyncSeriesHook<[Compiler]>} */\n\t\t\twatchRun: new AsyncSeriesHook([\"compiler\"]),\n\t\t\t/** @type {SyncHook<[Error]>} */\n\t\t\tfailed: new SyncHook([\"error\"]),\n\t\t\t/** @type {SyncHook<[string | null, number]>} */\n\t\t\tinvalid: new SyncHook([\"filename\", \"changeTime\"]),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\twatchClose: new SyncHook([]),\n\t\t\t/** @type {AsyncSeriesHook<[]>} */\n\t\t\tshutdown: new AsyncSeriesHook([]),\n\n\t\t\t/** @type {SyncBailHook<[string, string, any[] | undefined], true>} */\n\t\t\tinfrastructureLog: new SyncBailHook([\"origin\", \"type\", \"args\"]),\n\n\t\t\t// TODO the following hooks are weirdly located here\n\t\t\t// TODO move them for webpack 5\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\tenvironment: new SyncHook([]),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\tafterEnvironment: new SyncHook([]),\n\t\t\t/** @type {SyncHook<[Compiler]>} */\n\t\t\tafterPlugins: new SyncHook([\"compiler\"]),\n\t\t\t/** @type {SyncHook<[Compiler]>} */\n\t\t\tafterResolvers: new SyncHook([\"compiler\"]),\n\t\t\t/** @type {SyncBailHook<[string, Entry], boolean>} */\n\t\t\tentryOption: new SyncBailHook([\"context\", \"entry\"])\n\t\t});\n\n\t\tthis.webpack = webpack;\n\n\t\t/** @type {string | undefined} */\n\t\tthis.name = undefined;\n\t\t/** @type {Compilation | undefined} */\n\t\tthis.parentCompilation = undefined;\n\t\t/** @type {Compiler} */\n\t\tthis.root = this;\n\t\t/** @type {string} */\n\t\tthis.outputPath = \"\";\n\t\t/** @type {Watching | undefined} */\n\t\tthis.watching = undefined;\n\n\t\t/** @type {OutputFileSystem | null} */\n\t\tthis.outputFileSystem = null;\n\t\t/** @type {IntermediateFileSystem | null} */\n\t\tthis.intermediateFileSystem = null;\n\t\t/** @type {InputFileSystem | null} */\n\t\tthis.inputFileSystem = null;\n\t\t/** @type {WatchFileSystem | null} */\n\t\tthis.watchFileSystem = null;\n\n\t\t/** @type {string|null} */\n\t\tthis.recordsInputPath = null;\n\t\t/** @type {string|null} */\n\t\tthis.recordsOutputPath = null;\n\t\t/** @type {Record<string, TODO>} */\n\t\tthis.records = {};\n\t\t/** @type {Set<string | RegExp>} */\n\t\tthis.managedPaths = new Set();\n\t\t/** @type {Set<string | RegExp>} */\n\t\tthis.unmanagedPaths = new Set();\n\t\t/** @type {Set<string | RegExp>} */\n\t\tthis.immutablePaths = new Set();\n\n\t\t/** @type {ReadonlySet<string> | undefined} */\n\t\tthis.modifiedFiles = undefined;\n\t\t/** @type {ReadonlySet<string> | undefined} */\n\t\tthis.removedFiles = undefined;\n\t\t/** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null> | undefined} */\n\t\tthis.fileTimestamps = undefined;\n\t\t/** @type {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null> | undefined} */\n\t\tthis.contextTimestamps = undefined;\n\t\t/** @type {number | undefined} */\n\t\tthis.fsStartTime = undefined;\n\n\t\t/** @type {ResolverFactory} */\n\t\tthis.resolverFactory = new ResolverFactory();\n\n\t\t/** @type {LoggingFunction | undefined} */\n\t\tthis.infrastructureLogger = undefined;\n\n\t\t/** @type {Readonly<PlatformTargetProperties>} */\n\t\tthis.platform = {\n\t\t\tweb: null,\n\t\t\tbrowser: null,\n\t\t\twebworker: null,\n\t\t\tnode: null,\n\t\t\tnwjs: null,\n\t\t\telectron: null\n\t\t};\n\n\t\tthis.options = options;\n\n\t\tthis.context = context;\n\n\t\tthis.requestShortener = new RequestShortener(context, this.root);\n\n\t\tthis.cache = new Cache();\n\n\t\t/** @type {Map<Module, { buildInfo: BuildInfo, references: References | undefined, memCache: WeakTupleMap<any, any> }> | undefined} */\n\t\tthis.moduleMemCaches = undefined;\n\n\t\tthis.compilerPath = \"\";\n\n\t\t/** @type {boolean} */\n\t\tthis.running = false;\n\n\t\t/** @type {boolean} */\n\t\tthis.idle = false;\n\n\t\t/** @type {boolean} */\n\t\tthis.watchMode = false;\n\n\t\tthis._backCompat = this.options.experiments.backCompat !== false;\n\n\t\t/** @type {Compilation | undefined} */\n\t\tthis._lastCompilation = undefined;\n\t\t/** @type {NormalModuleFactory | undefined} */\n\t\tthis._lastNormalModuleFactory = undefined;\n\n\t\t/**\n\t\t * @private\n\t\t * @type {WeakMap<Source, CacheEntry>}\n\t\t */\n\t\tthis._assetEmittingSourceCache = new WeakMap();\n\t\t/**\n\t\t * @private\n\t\t * @type {Map<string, number>}\n\t\t */\n\t\tthis._assetEmittingWrittenFiles = new Map();\n\t\t/**\n\t\t * @private\n\t\t * @type {Set<string>}\n\t\t */\n\t\tthis._assetEmittingPreviousFiles = new Set();\n\t}\n\n\t/**\n\t * @param {string} name cache name\n\t * @returns {CacheFacade} the cache facade instance\n\t */\n\tgetCache(name) {\n\t\treturn new CacheFacade(\n\t\t\tthis.cache,\n\t\t\t`${this.compilerPath}${name}`,\n\t\t\tthis.options.output.hashFunction\n\t\t);\n\t}\n\n\t/**\n\t * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n\t * @returns {Logger} a logger with that name\n\t */\n\tgetInfrastructureLogger(name) {\n\t\tif (!name) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"Compiler.getInfrastructureLogger(name) called without a name\"\n\t\t\t);\n\t\t}\n\t\treturn new Logger(\n\t\t\t(type, args) => {\n\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\tname = name();\n\t\t\t\t\tif (!name) {\n\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tthis.hooks.infrastructureLog.call(name, type, args) === undefined &&\n\t\t\t\t\tthis.infrastructureLogger !== undefined\n\t\t\t\t) {\n\t\t\t\t\tthis.infrastructureLogger(name, type, args);\n\t\t\t\t}\n\t\t\t},\n\t\t\tchildName => {\n\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\t\treturn this.getInfrastructureLogger(() => {\n\t\t\t\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\t\t\t\tname = name();\n\t\t\t\t\t\t\t\tif (!name) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\t\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\t\t\t\tchildName = childName();\n\t\t\t\t\t\t\t\tif (!childName) {\n\t\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\t\"Logger.getChildLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn `${name}/${childName}`;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn this.getInfrastructureLogger(() => {\n\t\t\t\t\t\tif (typeof name === \"function\") {\n\t\t\t\t\t\t\tname = name();\n\t\t\t\t\t\t\tif (!name) {\n\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\"Compiler.getInfrastructureLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `${name}/${childName}`;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\treturn this.getInfrastructureLogger(() => {\n\t\t\t\t\t\tif (typeof childName === \"function\") {\n\t\t\t\t\t\t\tchildName = childName();\n\t\t\t\t\t\t\tif (!childName) {\n\t\t\t\t\t\t\t\tthrow new TypeError(\n\t\t\t\t\t\t\t\t\t\"Logger.getChildLogger(name) called with a function not returning a name\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn `${name}/${childName}`;\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this.getInfrastructureLogger(`${name}/${childName}`);\n\t\t\t}\n\t\t);\n\t}\n\n\t// TODO webpack 6: solve this in a better way\n\t// e.g. move compilation specific info from Modules into ModuleGraph\n\t_cleanupLastCompilation() {\n\t\tif (this._lastCompilation !== undefined) {\n\t\t\tfor (const childCompilation of this._lastCompilation.children) {\n\t\t\t\tfor (const module of childCompilation.modules) {\n\t\t\t\t\tChunkGraph.clearChunkGraphForModule(module);\n\t\t\t\t\tModuleGraph.clearModuleGraphForModule(module);\n\t\t\t\t\tmodule.cleanupForCache();\n\t\t\t\t}\n\t\t\t\tfor (const chunk of childCompilation.chunks) {\n\t\t\t\t\tChunkGraph.clearChunkGraphForChunk(chunk);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const module of this._lastCompilation.modules) {\n\t\t\t\tChunkGraph.clearChunkGraphForModule(module);\n\t\t\t\tModuleGraph.clearModuleGraphForModule(module);\n\t\t\t\tmodule.cleanupForCache();\n\t\t\t}\n\t\t\tfor (const chunk of this._lastCompilation.chunks) {\n\t\t\t\tChunkGraph.clearChunkGraphForChunk(chunk);\n\t\t\t}\n\t\t\tthis._lastCompilation = undefined;\n\t\t}\n\t}\n\n\t// TODO webpack 6: solve this in a better way\n\t_cleanupLastNormalModuleFactory() {\n\t\tif (this._lastNormalModuleFactory !== undefined) {\n\t\t\tthis._lastNormalModuleFactory.cleanupForCache();\n\t\t\tthis._lastNormalModuleFactory = undefined;\n\t\t}\n\t}\n\n\t/**\n\t * @param {WatchOptions} watchOptions the watcher's options\n\t * @param {RunCallback<Stats>} handler signals when the call finishes\n\t * @returns {Watching} a compiler watcher\n\t */\n\twatch(watchOptions, handler) {\n\t\tif (this.running) {\n\t\t\treturn handler(new ConcurrentCompilationError());\n\t\t}\n\n\t\tthis.running = true;\n\t\tthis.watchMode = true;\n\t\tthis.watching = new Watching(this, watchOptions, handler);\n\t\treturn this.watching;\n\t}\n\n\t/**\n\t * @param {RunCallback<Stats>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\trun(callback) {\n\t\tif (this.running) {\n\t\t\treturn callback(new ConcurrentCompilationError());\n\t\t}\n\n\t\t/** @type {Logger | undefined} */\n\t\tlet logger;\n\n\t\t/**\n\t\t * @param {Error | null} err error\n\t\t * @param {Stats=} stats stats\n\t\t */\n\t\tconst finalCallback = (err, stats) => {\n\t\t\tif (logger) logger.time(\"beginIdle\");\n\t\t\tthis.idle = true;\n\t\t\tthis.cache.beginIdle();\n\t\t\tthis.idle = true;\n\t\t\tif (logger) logger.timeEnd(\"beginIdle\");\n\t\t\tthis.running = false;\n\t\t\tif (err) {\n\t\t\t\tthis.hooks.failed.call(err);\n\t\t\t}\n\t\t\tif (callback !== undefined) callback(err, stats);\n\t\t\tthis.hooks.afterDone.call(/** @type {Stats} */ (stats));\n\t\t};\n\n\t\tconst startTime = Date.now();\n\n\t\tthis.running = true;\n\n\t\t/**\n\t\t * @param {Error | null} err error\n\t\t * @param {Compilation=} _compilation compilation\n\t\t * @returns {void}\n\t\t */\n\t\tconst onCompiled = (err, _compilation) => {\n\t\t\tif (err) return finalCallback(err);\n\n\t\t\tconst compilation = /** @type {Compilation} */ (_compilation);\n\n\t\t\tif (this.hooks.shouldEmit.call(compilation) === false) {\n\t\t\t\tcompilation.startTime = startTime;\n\t\t\t\tcompilation.endTime = Date.now();\n\t\t\t\tconst stats = new Stats(compilation);\n\t\t\t\tthis.hooks.done.callAsync(stats, err => {\n\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\treturn finalCallback(null, stats);\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tprocess.nextTick(() => {\n\t\t\t\tlogger = compilation.getLogger(\"webpack.Compiler\");\n\t\t\t\tlogger.time(\"emitAssets\");\n\t\t\t\tthis.emitAssets(compilation, err => {\n\t\t\t\t\t/** @type {Logger} */\n\t\t\t\t\t(logger).timeEnd(\"emitAssets\");\n\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\tif (compilation.hooks.needAdditionalPass.call()) {\n\t\t\t\t\t\tcompilation.needAdditionalPass = true;\n\n\t\t\t\t\t\tcompilation.startTime = startTime;\n\t\t\t\t\t\tcompilation.endTime = Date.now();\n\t\t\t\t\t\t/** @type {Logger} */\n\t\t\t\t\t\t(logger).time(\"done hook\");\n\t\t\t\t\t\tconst stats = new Stats(compilation);\n\t\t\t\t\t\tthis.hooks.done.callAsync(stats, err => {\n\t\t\t\t\t\t\t/** @type {Logger} */\n\t\t\t\t\t\t\t(logger).timeEnd(\"done hook\");\n\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\t\t\tthis.hooks.additionalPass.callAsync(err => {\n\t\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\t\t\t\tthis.compile(onCompiled);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {Logger} */\n\t\t\t\t\t(logger).time(\"emitRecords\");\n\t\t\t\t\tthis.emitRecords(err => {\n\t\t\t\t\t\t/** @type {Logger} */\n\t\t\t\t\t\t(logger).timeEnd(\"emitRecords\");\n\t\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\t\tcompilation.startTime = startTime;\n\t\t\t\t\t\tcompilation.endTime = Date.now();\n\t\t\t\t\t\t/** @type {Logger} */\n\t\t\t\t\t\t(logger).time(\"done hook\");\n\t\t\t\t\t\tconst stats = new Stats(compilation);\n\t\t\t\t\t\tthis.hooks.done.callAsync(stats, err => {\n\t\t\t\t\t\t\t/** @type {Logger} */\n\t\t\t\t\t\t\t(logger).timeEnd(\"done hook\");\n\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\t\t\tthis.cache.storeBuildDependencies(\n\t\t\t\t\t\t\t\tcompilation.buildDependencies,\n\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\tif (err) return finalCallback(err);\n\t\t\t\t\t\t\t\t\treturn finalCallback(null, stats);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\tconst run = () => {\n\t\t\tthis.hooks.beforeRun.callAsync(this, err => {\n\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\tthis.hooks.run.callAsync(this, err => {\n\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\tthis.readRecords(err => {\n\t\t\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\t\t\tthis.compile(onCompiled);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\tif (this.idle) {\n\t\t\tthis.cache.endIdle(err => {\n\t\t\t\tif (err) return finalCallback(err);\n\n\t\t\t\tthis.idle = false;\n\t\t\t\trun();\n\t\t\t});\n\t\t} else {\n\t\t\trun();\n\t\t}\n\t}\n\n\t/**\n\t * @param {RunAsChildCallback} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\trunAsChild(callback) {\n\t\tconst startTime = Date.now();\n\n\t\t/**\n\t\t * @param {Error | null} err error\n\t\t * @param {Chunk[]=} entries entries\n\t\t * @param {Compilation=} compilation compilation\n\t\t */\n\t\tconst finalCallback = (err, entries, compilation) => {\n\t\t\ttry {\n\t\t\t\tcallback(err, entries, compilation);\n\t\t\t} catch (runAsChildErr) {\n\t\t\t\tconst err = new WebpackError(\n\t\t\t\t\t`compiler.runAsChild callback error: ${runAsChildErr}`\n\t\t\t\t);\n\t\t\t\terr.details = /** @type {Error} */ (runAsChildErr).stack;\n\t\t\t\t/** @type {Compilation} */\n\t\t\t\t(this.parentCompilation).errors.push(err);\n\t\t\t}\n\t\t};\n\n\t\tthis.compile((err, _compilation) => {\n\t\t\tif (err) return finalCallback(err);\n\n\t\t\tconst compilation = /** @type {Compilation} */ (_compilation);\n\t\t\tconst parentCompilation = /** @type {Compilation} */ (\n\t\t\t\tthis.parentCompilation\n\t\t\t);\n\n\t\t\tparentCompilation.children.push(compilation);\n\n\t\t\tfor (const { name, source, info } of compilation.getAssets()) {\n\t\t\t\tparentCompilation.emitAsset(name, source, info);\n\t\t\t}\n\n\t\t\t/** @type {Chunk[]} */\n\t\t\tconst entries = [];\n\n\t\t\tfor (const ep of compilation.entrypoints.values()) {\n\t\t\t\tentries.push(...ep.chunks);\n\t\t\t}\n\n\t\t\tcompilation.startTime = startTime;\n\t\t\tcompilation.endTime = Date.now();\n\n\t\t\treturn finalCallback(null, entries, compilation);\n\t\t});\n\t}\n\n\tpurgeInputFileSystem() {\n\t\tif (this.inputFileSystem && this.inputFileSystem.purge) {\n\t\t\tthis.inputFileSystem.purge();\n\t\t}\n\t}\n\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @param {Callback<void>} callback signals when the assets are emitted\n\t * @returns {void}\n\t */\n\temitAssets(compilation, callback) {\n\t\t/** @type {string} */\n\t\tlet outputPath;\n\n\t\t/**\n\t\t * @param {Error=} err error\n\t\t * @returns {void}\n\t\t */\n\t\tconst emitFiles = err => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tconst assets = compilation.getAssets();\n\t\t\tcompilation.assets = { ...compilation.assets };\n\t\t\t/** @type {Map<string, SimilarEntry>} */\n\t\t\tconst caseInsensitiveMap = new Map();\n\t\t\t/** @type {Set<string>} */\n\t\t\tconst allTargetPaths = new Set();\n\t\t\tasyncLib.forEachLimit(\n\t\t\t\tassets,\n\t\t\t\t15,\n\t\t\t\t({ name: file, source, info }, callback) => {\n\t\t\t\t\tlet targetFile = file;\n\t\t\t\t\tlet immutable = info.immutable;\n\t\t\t\t\tconst queryStringIdx = targetFile.indexOf(\"?\");\n\t\t\t\t\tif (queryStringIdx >= 0) {\n\t\t\t\t\t\ttargetFile = targetFile.slice(0, queryStringIdx);\n\t\t\t\t\t\t// We may remove the hash, which is in the query string\n\t\t\t\t\t\t// So we recheck if the file is immutable\n\t\t\t\t\t\t// This doesn't cover all cases, but immutable is only a performance optimization anyway\n\t\t\t\t\t\timmutable =\n\t\t\t\t\t\t\timmutable &&\n\t\t\t\t\t\t\t(includesHash(targetFile, info.contenthash) ||\n\t\t\t\t\t\t\t\tincludesHash(targetFile, info.chunkhash) ||\n\t\t\t\t\t\t\t\tincludesHash(targetFile, info.modulehash) ||\n\t\t\t\t\t\t\t\tincludesHash(targetFile, info.fullhash));\n\t\t\t\t\t}\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Error=} err error\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst writeOut = err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tconst targetPath = join(\n\t\t\t\t\t\t\t/** @type {OutputFileSystem} */\n\t\t\t\t\t\t\t(this.outputFileSystem),\n\t\t\t\t\t\t\toutputPath,\n\t\t\t\t\t\t\ttargetFile\n\t\t\t\t\t\t);\n\t\t\t\t\t\tallTargetPaths.add(targetPath);\n\n\t\t\t\t\t\t// check if the target file has already been written by this Compiler\n\t\t\t\t\t\tconst targetFileGeneration =\n\t\t\t\t\t\t\tthis._assetEmittingWrittenFiles.get(targetPath);\n\n\t\t\t\t\t\t// create an cache entry for this Source if not already existing\n\t\t\t\t\t\tlet cacheEntry = this._assetEmittingSourceCache.get(source);\n\t\t\t\t\t\tif (cacheEntry === undefined) {\n\t\t\t\t\t\t\tcacheEntry = {\n\t\t\t\t\t\t\t\tsizeOnlySource: undefined,\n\t\t\t\t\t\t\t\twrittenTo: new Map()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tthis._assetEmittingSourceCache.set(source, cacheEntry);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/** @type {SimilarEntry | undefined} */\n\t\t\t\t\t\tlet similarEntry;\n\n\t\t\t\t\t\tconst checkSimilarFile = () => {\n\t\t\t\t\t\t\tconst caseInsensitiveTargetPath = targetPath.toLowerCase();\n\t\t\t\t\t\t\tsimilarEntry = caseInsensitiveMap.get(caseInsensitiveTargetPath);\n\t\t\t\t\t\t\tif (similarEntry !== undefined) {\n\t\t\t\t\t\t\t\tconst { path: other, source: otherSource } = similarEntry;\n\t\t\t\t\t\t\t\tif (isSourceEqual(otherSource, source)) {\n\t\t\t\t\t\t\t\t\t// Size may or may not be available at this point.\n\t\t\t\t\t\t\t\t\t// If it's not available add to \"waiting\" list and it will be updated once available\n\t\t\t\t\t\t\t\t\tif (similarEntry.size !== undefined) {\n\t\t\t\t\t\t\t\t\t\tupdateWithReplacementSource(similarEntry.size);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tif (!similarEntry.waiting) similarEntry.waiting = [];\n\t\t\t\t\t\t\t\t\t\tsimilarEntry.waiting.push({ file, cacheEntry });\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\talreadyWritten();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst err =\n\t\t\t\t\t\t\t\t\t\tnew WebpackError(`Prevent writing to file that only differs in casing or query string from already written file.\nThis will lead to a race-condition and corrupted files on case-insensitive file systems.\n${targetPath}\n${other}`);\n\t\t\t\t\t\t\t\t\terr.file = file;\n\t\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcaseInsensitiveMap.set(\n\t\t\t\t\t\t\t\tcaseInsensitiveTargetPath,\n\t\t\t\t\t\t\t\t(similarEntry = /** @type {SimilarEntry} */ ({\n\t\t\t\t\t\t\t\t\tpath: targetPath,\n\t\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\t\tsize: undefined,\n\t\t\t\t\t\t\t\t\twaiting: undefined\n\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * get the binary (Buffer) content from the Source\n\t\t\t\t\t\t * @returns {Buffer} content for the source\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst getContent = () => {\n\t\t\t\t\t\t\tif (typeof source.buffer === \"function\") {\n\t\t\t\t\t\t\t\treturn source.buffer();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst bufferOrString = source.source();\n\t\t\t\t\t\t\tif (Buffer.isBuffer(bufferOrString)) {\n\t\t\t\t\t\t\t\treturn bufferOrString;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn Buffer.from(bufferOrString, \"utf8\");\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst alreadyWritten = () => {\n\t\t\t\t\t\t\t// cache the information that the Source has been already been written to that location\n\t\t\t\t\t\t\tif (targetFileGeneration === undefined) {\n\t\t\t\t\t\t\t\tconst newGeneration = 1;\n\t\t\t\t\t\t\t\tthis._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t\t/** @type {CacheEntry} */\n\t\t\t\t\t\t\t\t(cacheEntry).writtenTo.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t/** @type {CacheEntry} */\n\t\t\t\t\t\t\t\t(cacheEntry).writtenTo.set(targetPath, targetFileGeneration);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Write the file to output file system\n\t\t\t\t\t\t * @param {Buffer} content content to be written\n\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst doWrite = content => {\n\t\t\t\t\t\t\t/** @type {OutputFileSystem} */\n\t\t\t\t\t\t\t(this.outputFileSystem).writeFile(targetPath, content, err => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t// information marker that the asset has been emitted\n\t\t\t\t\t\t\t\tcompilation.emittedAssets.add(file);\n\n\t\t\t\t\t\t\t\t// cache the information that the Source has been written to that location\n\t\t\t\t\t\t\t\tconst newGeneration =\n\t\t\t\t\t\t\t\t\ttargetFileGeneration === undefined\n\t\t\t\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t\t\t\t: targetFileGeneration + 1;\n\t\t\t\t\t\t\t\t/** @type {CacheEntry} */\n\t\t\t\t\t\t\t\t(cacheEntry).writtenTo.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t\tthis._assetEmittingWrittenFiles.set(targetPath, newGeneration);\n\t\t\t\t\t\t\t\tthis.hooks.assetEmitted.callAsync(\n\t\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\t\t\toutputPath,\n\t\t\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\t\t\ttargetPath\n\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {number} size size\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst updateWithReplacementSource = size => {\n\t\t\t\t\t\t\tupdateFileWithReplacementSource(\n\t\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\t\t/** @type {CacheEntry} */ (cacheEntry),\n\t\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t/** @type {SimilarEntry} */\n\t\t\t\t\t\t\t(similarEntry).size = size;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t/** @type {SimilarEntry} */ (similarEntry).waiting !== undefined\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tfor (const { file, cacheEntry } of /** @type {SimilarEntry} */ (\n\t\t\t\t\t\t\t\t\tsimilarEntry\n\t\t\t\t\t\t\t\t).waiting) {\n\t\t\t\t\t\t\t\t\tupdateFileWithReplacementSource(file, cacheEntry, size);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {string} file file\n\t\t\t\t\t\t * @param {CacheEntry} cacheEntry cache entry\n\t\t\t\t\t\t * @param {number} size size\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst updateFileWithReplacementSource = (\n\t\t\t\t\t\t\tfile,\n\t\t\t\t\t\t\tcacheEntry,\n\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t) => {\n\t\t\t\t\t\t\t// Create a replacement resource which only allows to ask for size\n\t\t\t\t\t\t\t// This allows to GC all memory allocated by the Source\n\t\t\t\t\t\t\t// (expect when the Source is stored in any other cache)\n\t\t\t\t\t\t\tif (!cacheEntry.sizeOnlySource) {\n\t\t\t\t\t\t\t\tcacheEntry.sizeOnlySource = new SizeOnlySource(size);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcompilation.updateAsset(file, cacheEntry.sizeOnlySource, {\n\t\t\t\t\t\t\t\tsize\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {IStats} stats stats\n\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst processExistingFile = stats => {\n\t\t\t\t\t\t\t// skip emitting if it's already there and an immutable file\n\t\t\t\t\t\t\tif (immutable) {\n\t\t\t\t\t\t\t\tupdateWithReplacementSource(/** @type {number} */ (stats.size));\n\t\t\t\t\t\t\t\treturn alreadyWritten();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst content = getContent();\n\n\t\t\t\t\t\t\tupdateWithReplacementSource(content.length);\n\n\t\t\t\t\t\t\t// if it exists and content on disk matches content\n\t\t\t\t\t\t\t// skip writing the same content again\n\t\t\t\t\t\t\t// (to keep mtime and don't trigger watchers)\n\t\t\t\t\t\t\t// for a fast negative match file size is compared first\n\t\t\t\t\t\t\tif (content.length === stats.size) {\n\t\t\t\t\t\t\t\tcompilation.comparedForEmitAssets.add(file);\n\t\t\t\t\t\t\t\treturn /** @type {OutputFileSystem} */ (\n\t\t\t\t\t\t\t\t\tthis.outputFileSystem\n\t\t\t\t\t\t\t\t).readFile(targetPath, (err, existingContent) => {\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\terr ||\n\t\t\t\t\t\t\t\t\t\t!content.equals(/** @type {Buffer} */ (existingContent))\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn doWrite(content);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn alreadyWritten();\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn doWrite(content);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tconst processMissingFile = () => {\n\t\t\t\t\t\t\tconst content = getContent();\n\n\t\t\t\t\t\t\tupdateWithReplacementSource(content.length);\n\n\t\t\t\t\t\t\treturn doWrite(content);\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// if the target file has already been written\n\t\t\t\t\t\tif (targetFileGeneration !== undefined) {\n\t\t\t\t\t\t\t// check if the Source has been written to this target file\n\t\t\t\t\t\t\tconst writtenGeneration = /** @type {CacheEntry} */ (\n\t\t\t\t\t\t\t\tcacheEntry\n\t\t\t\t\t\t\t).writtenTo.get(targetPath);\n\t\t\t\t\t\t\tif (writtenGeneration === targetFileGeneration) {\n\t\t\t\t\t\t\t\t// if yes, we may skip writing the file\n\t\t\t\t\t\t\t\t// if it's already there\n\t\t\t\t\t\t\t\t// (we assume one doesn't modify files while the Compiler is running, other then removing them)\n\n\t\t\t\t\t\t\t\tif (this._assetEmittingPreviousFiles.has(targetPath)) {\n\t\t\t\t\t\t\t\t\tconst sizeOnlySource = /** @type {SizeOnlySource} */ (\n\t\t\t\t\t\t\t\t\t\t/** @type {CacheEntry} */ (cacheEntry).sizeOnlySource\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t// We assume that assets from the last compilation say intact on disk (they are not removed)\n\t\t\t\t\t\t\t\t\tcompilation.updateAsset(file, sizeOnlySource, {\n\t\t\t\t\t\t\t\t\t\tsize: sizeOnlySource.size()\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Settings immutable will make it accept file content without comparing when file exist\n\t\t\t\t\t\t\t\timmutable = true;\n\t\t\t\t\t\t\t} else if (!immutable) {\n\t\t\t\t\t\t\t\tif (checkSimilarFile()) return;\n\t\t\t\t\t\t\t\t// We wrote to this file before which has very likely a different content\n\t\t\t\t\t\t\t\t// skip comparing and assume content is different for performance\n\t\t\t\t\t\t\t\t// This case happens often during watch mode.\n\t\t\t\t\t\t\t\treturn processMissingFile();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (checkSimilarFile()) return;\n\t\t\t\t\t\tif (this.options.output.compareBeforeEmit) {\n\t\t\t\t\t\t\t/** @type {OutputFileSystem} */\n\t\t\t\t\t\t\t(this.outputFileSystem).stat(targetPath, (err, stats) => {\n\t\t\t\t\t\t\t\tconst exists = !err && /** @type {IStats} */ (stats).isFile();\n\n\t\t\t\t\t\t\t\tif (exists) {\n\t\t\t\t\t\t\t\t\tprocessExistingFile(/** @type {IStats} */ (stats));\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tprocessMissingFile();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprocessMissingFile();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\tif (/\\/|\\\\/.test(targetFile)) {\n\t\t\t\t\t\tconst fs = /** @type {OutputFileSystem} */ (this.outputFileSystem);\n\t\t\t\t\t\tconst dir = dirname(fs, join(fs, outputPath, targetFile));\n\t\t\t\t\t\tmkdirp(fs, dir, writeOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\twriteOut();\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\terr => {\n\t\t\t\t\t// Clear map to free up memory\n\t\t\t\t\tcaseInsensitiveMap.clear();\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tthis._assetEmittingPreviousFiles.clear();\n\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._assetEmittingPreviousFiles = allTargetPaths;\n\n\t\t\t\t\tthis.hooks.afterEmit.callAsync(compilation, err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t);\n\t\t};\n\n\t\tthis.hooks.emit.callAsync(compilation, err => {\n\t\t\tif (err) return callback(err);\n\t\t\toutputPath = compilation.getPath(this.outputPath, {});\n\t\t\tmkdirp(\n\t\t\t\t/** @type {OutputFileSystem} */ (this.outputFileSystem),\n\t\t\t\toutputPath,\n\t\t\t\temitFiles\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\temitRecords(callback) {\n\t\tif (this.hooks.emitRecords.isUsed()) {\n\t\t\tif (this.recordsOutputPath) {\n\t\t\t\tasyncLib.parallel(\n\t\t\t\t\t[\n\t\t\t\t\t\tcb => this.hooks.emitRecords.callAsync(cb),\n\t\t\t\t\t\tthis._emitRecords.bind(this)\n\t\t\t\t\t],\n\t\t\t\t\terr => callback(err)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.hooks.emitRecords.callAsync(callback);\n\t\t\t}\n\t\t} else if (this.recordsOutputPath) {\n\t\t\tthis._emitRecords(callback);\n\t\t} else {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\t_emitRecords(callback) {\n\t\tconst writeFile = () => {\n\t\t\t/** @type {OutputFileSystem} */\n\t\t\t(this.outputFileSystem).writeFile(\n\t\t\t\t/** @type {string} */ (this.recordsOutputPath),\n\t\t\t\tJSON.stringify(\n\t\t\t\t\tthis.records,\n\t\t\t\t\t(n, value) => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\ttypeof value === \"object\" &&\n\t\t\t\t\t\t\tvalue !== null &&\n\t\t\t\t\t\t\t!Array.isArray(value)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tconst keys = Object.keys(value);\n\t\t\t\t\t\t\tif (!isSorted(keys)) {\n\t\t\t\t\t\t\t\treturn sortObject(value, keys);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t},\n\t\t\t\t\t2\n\t\t\t\t),\n\t\t\t\tcallback\n\t\t\t);\n\t\t};\n\n\t\tconst recordsOutputPathDirectory = dirname(\n\t\t\t/** @type {OutputFileSystem} */ (this.outputFileSystem),\n\t\t\t/** @type {string} */ (this.recordsOutputPath)\n\t\t);\n\t\tif (!recordsOutputPathDirectory) {\n\t\t\treturn writeFile();\n\t\t}\n\t\tmkdirp(\n\t\t\t/** @type {OutputFileSystem} */ (this.outputFileSystem),\n\t\t\trecordsOutputPathDirectory,\n\t\t\terr => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\twriteFile();\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\treadRecords(callback) {\n\t\tif (this.hooks.readRecords.isUsed()) {\n\t\t\tif (this.recordsInputPath) {\n\t\t\t\tasyncLib.parallel(\n\t\t\t\t\t[\n\t\t\t\t\t\tcb => this.hooks.readRecords.callAsync(cb),\n\t\t\t\t\t\tthis._readRecords.bind(this)\n\t\t\t\t\t],\n\t\t\t\t\terr => callback(err)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.records = {};\n\t\t\t\tthis.hooks.readRecords.callAsync(callback);\n\t\t\t}\n\t\t} else if (this.recordsInputPath) {\n\t\t\tthis._readRecords(callback);\n\t\t} else {\n\t\t\tthis.records = {};\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\t_readRecords(callback) {\n\t\tif (!this.recordsInputPath) {\n\t\t\tthis.records = {};\n\t\t\treturn callback();\n\t\t}\n\t\t/** @type {InputFileSystem} */\n\t\t(this.inputFileSystem).stat(this.recordsInputPath, err => {\n\t\t\t// It doesn't exist\n\t\t\t// We can ignore this.\n\t\t\tif (err) return callback();\n\n\t\t\t/** @type {InputFileSystem} */\n\t\t\t(this.inputFileSystem).readFile(\n\t\t\t\t/** @type {string} */ (this.recordsInputPath),\n\t\t\t\t(err, content) => {\n\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.records = parseJson(\n\t\t\t\t\t\t\t/** @type {Buffer} */ (content).toString(\"utf-8\")\n\t\t\t\t\t\t);\n\t\t\t\t\t} catch (parseErr) {\n\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t`Cannot parse records: ${/** @type {Error} */ (parseErr).message}`\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @param {string} compilerName the compiler's name\n\t * @param {number} compilerIndex the compiler's index\n\t * @param {OutputOptions=} outputOptions the output options\n\t * @param {WebpackPluginInstance[]=} plugins the plugins to apply\n\t * @returns {Compiler} a child compiler\n\t */\n\tcreateChildCompiler(\n\t\tcompilation,\n\t\tcompilerName,\n\t\tcompilerIndex,\n\t\toutputOptions,\n\t\tplugins\n\t) {\n\t\tconst childCompiler = new Compiler(this.context, {\n\t\t\t...this.options,\n\t\t\toutput: {\n\t\t\t\t...this.options.output,\n\t\t\t\t...outputOptions\n\t\t\t}\n\t\t});\n\t\tchildCompiler.name = compilerName;\n\t\tchildCompiler.outputPath = this.outputPath;\n\t\tchildCompiler.inputFileSystem = this.inputFileSystem;\n\t\tchildCompiler.outputFileSystem = null;\n\t\tchildCompiler.resolverFactory = this.resolverFactory;\n\t\tchildCompiler.modifiedFiles = this.modifiedFiles;\n\t\tchildCompiler.removedFiles = this.removedFiles;\n\t\tchildCompiler.fileTimestamps = this.fileTimestamps;\n\t\tchildCompiler.contextTimestamps = this.contextTimestamps;\n\t\tchildCompiler.fsStartTime = this.fsStartTime;\n\t\tchildCompiler.cache = this.cache;\n\t\tchildCompiler.compilerPath = `${this.compilerPath}${compilerName}|${compilerIndex}|`;\n\t\tchildCompiler._backCompat = this._backCompat;\n\n\t\tconst relativeCompilerName = makePathsRelative(\n\t\t\tthis.context,\n\t\t\tcompilerName,\n\t\t\tthis.root\n\t\t);\n\t\tif (!this.records[relativeCompilerName]) {\n\t\t\tthis.records[relativeCompilerName] = [];\n\t\t}\n\t\tif (this.records[relativeCompilerName][compilerIndex]) {\n\t\t\tchildCompiler.records = this.records[relativeCompilerName][compilerIndex];\n\t\t} else {\n\t\t\tthis.records[relativeCompilerName].push((childCompiler.records = {}));\n\t\t}\n\n\t\tchildCompiler.parentCompilation = compilation;\n\t\tchildCompiler.root = this.root;\n\t\tif (Array.isArray(plugins)) {\n\t\t\tfor (const plugin of plugins) {\n\t\t\t\tif (plugin) {\n\t\t\t\t\tplugin.apply(childCompiler);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const name in this.hooks) {\n\t\t\tif (\n\t\t\t\t![\n\t\t\t\t\t\"make\",\n\t\t\t\t\t\"compile\",\n\t\t\t\t\t\"emit\",\n\t\t\t\t\t\"afterEmit\",\n\t\t\t\t\t\"invalid\",\n\t\t\t\t\t\"done\",\n\t\t\t\t\t\"thisCompilation\"\n\t\t\t\t].includes(name) &&\n\t\t\t\tchildCompiler.hooks[/** @type {keyof Compiler[\"hooks\"]} */ (name)]\n\t\t\t) {\n\t\t\t\tchildCompiler.hooks[\n\t\t\t\t\t/** @type {keyof Compiler[\"hooks\"]} */\n\t\t\t\t\t(name)\n\t\t\t\t].taps =\n\t\t\t\t\tthis.hooks[\n\t\t\t\t\t\t/** @type {keyof Compiler[\"hooks\"]} */\n\t\t\t\t\t\t(name)\n\t\t\t\t\t].taps.slice();\n\t\t\t}\n\t\t}\n\n\t\tcompilation.hooks.childCompiler.call(\n\t\t\tchildCompiler,\n\t\t\tcompilerName,\n\t\t\tcompilerIndex\n\t\t);\n\n\t\treturn childCompiler;\n\t}\n\n\tisChild() {\n\t\treturn Boolean(this.parentCompilation);\n\t}\n\n\t/**\n\t * @param {CompilationParams} params the compilation parameters\n\t * @returns {Compilation} compilation\n\t */\n\tcreateCompilation(params) {\n\t\tthis._cleanupLastCompilation();\n\t\treturn (this._lastCompilation = new Compilation(this, params));\n\t}\n\n\t/**\n\t * @param {CompilationParams} params the compilation parameters\n\t * @returns {Compilation} the created compilation\n\t */\n\tnewCompilation(params) {\n\t\tconst compilation = this.createCompilation(params);\n\t\tcompilation.name = this.name;\n\t\tcompilation.records = this.records;\n\t\tthis.hooks.thisCompilation.call(compilation, params);\n\t\tthis.hooks.compilation.call(compilation, params);\n\t\treturn compilation;\n\t}\n\n\tcreateNormalModuleFactory() {\n\t\tthis._cleanupLastNormalModuleFactory();\n\t\tconst normalModuleFactory = new NormalModuleFactory({\n\t\t\tcontext: this.options.context,\n\t\t\tfs: /** @type {InputFileSystem} */ (this.inputFileSystem),\n\t\t\tresolverFactory: this.resolverFactory,\n\t\t\toptions: this.options.module,\n\t\t\tassociatedObjectForCache: this.root,\n\t\t\tlayers: this.options.experiments.layers\n\t\t});\n\t\tthis._lastNormalModuleFactory = normalModuleFactory;\n\t\tthis.hooks.normalModuleFactory.call(normalModuleFactory);\n\t\treturn normalModuleFactory;\n\t}\n\n\tcreateContextModuleFactory() {\n\t\tconst contextModuleFactory = new ContextModuleFactory(this.resolverFactory);\n\t\tthis.hooks.contextModuleFactory.call(contextModuleFactory);\n\t\treturn contextModuleFactory;\n\t}\n\n\tnewCompilationParams() {\n\t\tconst params = {\n\t\t\tnormalModuleFactory: this.createNormalModuleFactory(),\n\t\t\tcontextModuleFactory: this.createContextModuleFactory()\n\t\t};\n\t\treturn params;\n\t}\n\n\t/**\n\t * @param {RunCallback<Compilation>} callback signals when the compilation finishes\n\t * @returns {void}\n\t */\n\tcompile(callback) {\n\t\tconst params = this.newCompilationParams();\n\t\tthis.hooks.beforeCompile.callAsync(params, err => {\n\t\t\tif (err) return callback(err);\n\n\t\t\tthis.hooks.compile.call(params);\n\n\t\t\tconst compilation = this.newCompilation(params);\n\n\t\t\tconst logger = compilation.getLogger(\"webpack.Compiler\");\n\n\t\t\tlogger.time(\"make hook\");\n\t\t\tthis.hooks.make.callAsync(compilation, err => {\n\t\t\t\tlogger.timeEnd(\"make hook\");\n\t\t\t\tif (err) return callback(err);\n\n\t\t\t\tlogger.time(\"finish make hook\");\n\t\t\t\tthis.hooks.finishMake.callAsync(compilation, err => {\n\t\t\t\t\tlogger.timeEnd(\"finish make hook\");\n\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\t\tlogger.time(\"finish compilation\");\n\t\t\t\t\t\tcompilation.finish(err => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"finish compilation\");\n\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\tlogger.time(\"seal compilation\");\n\t\t\t\t\t\t\tcompilation.seal(err => {\n\t\t\t\t\t\t\t\tlogger.timeEnd(\"seal compilation\");\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\tlogger.time(\"afterCompile hook\");\n\t\t\t\t\t\t\t\tthis.hooks.afterCompile.callAsync(compilation, err => {\n\t\t\t\t\t\t\t\t\tlogger.timeEnd(\"afterCompile hook\");\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\t\t\t\treturn callback(null, compilation);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * @param {RunCallback<void>} callback signals when the compiler closes\n\t * @returns {void}\n\t */\n\tclose(callback) {\n\t\tif (this.watching) {\n\t\t\t// When there is still an active watching, close this first\n\t\t\tthis.watching.close(err => {\n\t\t\t\tthis.close(callback);\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tthis.hooks.shutdown.callAsync(err => {\n\t\t\tif (err) return callback(err);\n\t\t\t// Get rid of reference to last compilation to avoid leaking memory\n\t\t\t// We can't run this._cleanupLastCompilation() as the Stats to this compilation\n\t\t\t// might be still in use. We try to get rid of the reference to the cache instead.\n\t\t\tthis._lastCompilation = undefined;\n\t\t\tthis._lastNormalModuleFactory = undefined;\n\t\t\tthis.cache.shutdown(callback);\n\t\t});\n\t}\n}\n\nmodule.exports = Compiler;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}