{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst {\n  AsyncSeriesWaterfallHook,\n  SyncWaterfallHook\n} = require(\"tapable\");\nconst ContextModule = require(\"./ContextModule\");\nconst ModuleFactory = require(\"./ModuleFactory\");\nconst ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\nconst LazySet = require(\"./util/LazySet\");\nconst {\n  cachedSetProperty\n} = require(\"./util/cleverMerge\");\nconst {\n  createFakeHook\n} = require(\"./util/deprecation\");\nconst {\n  join\n} = require(\"./util/fs\");\n\n/** @typedef {import(\"./ContextModule\").ContextModuleOptions} ContextModuleOptions */\n/** @typedef {import(\"./ContextModule\").ResolveDependenciesCallback} ResolveDependenciesCallback */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryCreateData} ModuleFactoryCreateData */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryResult} ModuleFactoryResult */\n/** @typedef {import(\"./ResolverFactory\")} ResolverFactory */\n/** @typedef {import(\"./dependencies/ContextDependency\")} ContextDependency */\n/** @typedef {import(\"enhanced-resolve\").ResolveRequest} ResolveRequest */\n/**\n * @template T\n * @typedef {import(\"./util/deprecation\").FakeHook<T>} FakeHook<T>\n */\n/** @typedef {import(\"./util/fs\").IStats} IStats */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {{ context: string, request: string }} ContextAlternativeRequest */\n\nconst EMPTY_RESOLVE_OPTIONS = {};\nmodule.exports = class ContextModuleFactory extends ModuleFactory {\n  /**\n   * @param {ResolverFactory} resolverFactory resolverFactory\n   */\n  constructor(resolverFactory) {\n    super();\n    /** @type {AsyncSeriesWaterfallHook<[ContextAlternativeRequest[], ContextModuleOptions]>} */\n    const alternativeRequests = new AsyncSeriesWaterfallHook([\"modules\", \"options\"]);\n    this.hooks = Object.freeze({\n      /** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n      beforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n      /** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n      afterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n      /** @type {SyncWaterfallHook<[string[]]>} */\n      contextModuleFiles: new SyncWaterfallHook([\"files\"]),\n      /** @type {FakeHook<Pick<AsyncSeriesWaterfallHook<[ContextAlternativeRequest[]]>, \"tap\" | \"tapAsync\" | \"tapPromise\" | \"name\">>} */\n      alternatives: createFakeHook({\n        name: \"alternatives\",\n        /** @type {AsyncSeriesWaterfallHook<[ContextAlternativeRequest[]]>[\"intercept\"]} */\n        intercept: interceptor => {\n          throw new Error(\"Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead\");\n        },\n        /** @type {AsyncSeriesWaterfallHook<[ContextAlternativeRequest[]]>[\"tap\"]} */\n        tap: (options, fn) => {\n          alternativeRequests.tap(options, fn);\n        },\n        /** @type {AsyncSeriesWaterfallHook<[ContextAlternativeRequest[]]>[\"tapAsync\"]} */\n        tapAsync: (options, fn) => {\n          alternativeRequests.tapAsync(options, (items, _options, callback) => fn(items, callback));\n        },\n        /** @type {AsyncSeriesWaterfallHook<[ContextAlternativeRequest[]]>[\"tapPromise\"]} */\n        tapPromise: (options, fn) => {\n          alternativeRequests.tapPromise(options, fn);\n        }\n      }, \"ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.\", \"DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES\"),\n      alternativeRequests\n    });\n    this.resolverFactory = resolverFactory;\n  }\n\n  /**\n   * @param {ModuleFactoryCreateData} data data object\n   * @param {function((Error | null)=, ModuleFactoryResult=): void} callback callback\n   * @returns {void}\n   */\n  create(data, callback) {\n    const context = data.context;\n    const dependencies = data.dependencies;\n    const resolveOptions = data.resolveOptions;\n    const dependency = /** @type {ContextDependency} */dependencies[0];\n    const fileDependencies = new LazySet();\n    const missingDependencies = new LazySet();\n    const contextDependencies = new LazySet();\n    this.hooks.beforeResolve.callAsync({\n      context,\n      dependencies,\n      layer: data.contextInfo.issuerLayer,\n      resolveOptions,\n      fileDependencies,\n      missingDependencies,\n      contextDependencies,\n      ...dependency.options\n    }, (err, beforeResolveResult) => {\n      if (err) {\n        return callback(err, {\n          fileDependencies,\n          missingDependencies,\n          contextDependencies\n        });\n      }\n\n      // Ignored\n      if (!beforeResolveResult) {\n        return callback(null, {\n          fileDependencies,\n          missingDependencies,\n          contextDependencies\n        });\n      }\n      const context = beforeResolveResult.context;\n      const request = beforeResolveResult.request;\n      const resolveOptions = beforeResolveResult.resolveOptions;\n      let loaders;\n      let resource;\n      let loadersPrefix = \"\";\n      const idx = request.lastIndexOf(\"!\");\n      if (idx >= 0) {\n        let loadersRequest = request.slice(0, idx + 1);\n        let i;\n        for (i = 0; i < loadersRequest.length && loadersRequest[i] === \"!\"; i++) {\n          loadersPrefix += \"!\";\n        }\n        loadersRequest = loadersRequest.slice(i).replace(/!+$/, \"\").replace(/!!+/g, \"!\");\n        loaders = loadersRequest === \"\" ? [] : loadersRequest.split(\"!\");\n        resource = request.slice(idx + 1);\n      } else {\n        loaders = [];\n        resource = request;\n      }\n      const contextResolver = this.resolverFactory.get(\"context\", dependencies.length > 0 ? cachedSetProperty(resolveOptions || EMPTY_RESOLVE_OPTIONS, \"dependencyType\", dependencies[0].category) : resolveOptions);\n      const loaderResolver = this.resolverFactory.get(\"loader\");\n      asyncLib.parallel([callback => {\n        const results = /** @type ResolveRequest[] */[];\n        /**\n         * @param {ResolveRequest} obj obj\n         * @returns {void}\n         */\n        const yield_ = obj => {\n          results.push(obj);\n        };\n        contextResolver.resolve({}, context, resource, {\n          fileDependencies,\n          missingDependencies,\n          contextDependencies,\n          yield: yield_\n        }, err => {\n          if (err) return callback(err);\n          callback(null, results);\n        });\n      }, callback => {\n        asyncLib.map(loaders, (loader, callback) => {\n          loaderResolver.resolve({}, context, loader, {\n            fileDependencies,\n            missingDependencies,\n            contextDependencies\n          }, (err, result) => {\n            if (err) return callback(err);\n            callback(null, /** @type {string} */result);\n          });\n        }, callback);\n      }], (err, result) => {\n        if (err) {\n          return callback(err, {\n            fileDependencies,\n            missingDependencies,\n            contextDependencies\n          });\n        }\n        let [contextResult, loaderResult] = /** @type {[ResolveRequest[], string[]]} */result;\n        if (contextResult.length > 1) {\n          const first = contextResult[0];\n          contextResult = contextResult.filter(r => r.path);\n          if (contextResult.length === 0) contextResult.push(first);\n        }\n        this.hooks.afterResolve.callAsync({\n          addon: loadersPrefix + loaderResult.join(\"!\") + (loaderResult.length > 0 ? \"!\" : \"\"),\n          resource: contextResult.length > 1 ? contextResult.map(r => r.path) : contextResult[0].path,\n          resolveDependencies: this.resolveDependencies.bind(this),\n          resourceQuery: contextResult[0].query,\n          resourceFragment: contextResult[0].fragment,\n          ...beforeResolveResult\n        }, (err, result) => {\n          if (err) {\n            return callback(err, {\n              fileDependencies,\n              missingDependencies,\n              contextDependencies\n            });\n          }\n\n          // Ignored\n          if (!result) {\n            return callback(null, {\n              fileDependencies,\n              missingDependencies,\n              contextDependencies\n            });\n          }\n          return callback(null, {\n            module: new ContextModule(result.resolveDependencies, result),\n            fileDependencies,\n            missingDependencies,\n            contextDependencies\n          });\n        });\n      });\n    });\n  }\n\n  /**\n   * @param {InputFileSystem} fs file system\n   * @param {ContextModuleOptions} options options\n   * @param {ResolveDependenciesCallback} callback callback function\n   * @returns {void}\n   */\n  resolveDependencies(fs, options, callback) {\n    const cmf = this;\n    const {\n      resource,\n      resourceQuery,\n      resourceFragment,\n      recursive,\n      regExp,\n      include,\n      exclude,\n      referencedExports,\n      category,\n      typePrefix,\n      attributes\n    } = options;\n    if (!regExp || !resource) return callback(null, []);\n\n    /**\n     * @param {string} ctx context\n     * @param {string} directory directory\n     * @param {Set<string>} visited visited\n     * @param {ResolveDependenciesCallback} callback callback\n     */\n    const addDirectoryChecked = (ctx, directory, visited, callback) => {\n      /** @type {NonNullable<InputFileSystem[\"realpath\"]>} */\n      fs.realpath(directory, (err, _realPath) => {\n        if (err) return callback(err);\n        const realPath = /** @type {string} */_realPath;\n        if (visited.has(realPath)) return callback(null, []);\n        /** @type {Set<string> | undefined} */\n        let recursionStack;\n        addDirectory(ctx, directory, (_, dir, callback) => {\n          if (recursionStack === undefined) {\n            recursionStack = new Set(visited);\n            recursionStack.add(realPath);\n          }\n          addDirectoryChecked(ctx, dir, recursionStack, callback);\n        }, callback);\n      });\n    };\n\n    /**\n     * @param {string} ctx context\n     * @param {string} directory directory\n     * @param {function(string, string, function(): void): void} addSubDirectory addSubDirectoryFn\n     * @param {ResolveDependenciesCallback} callback callback\n     */\n    const addDirectory = (ctx, directory, addSubDirectory, callback) => {\n      fs.readdir(directory, (err, files) => {\n        if (err) return callback(err);\n        const processedFiles = cmf.hooks.contextModuleFiles.call(/** @type {string[]} */files.map(file => file.normalize(\"NFC\")));\n        if (!processedFiles || processedFiles.length === 0) return callback(null, []);\n        asyncLib.map(processedFiles.filter(p => p.indexOf(\".\") !== 0), (segment, callback) => {\n          const subResource = join(fs, directory, segment);\n          if (!exclude || !subResource.match(exclude)) {\n            fs.stat(subResource, (err, _stat) => {\n              if (err) {\n                if (err.code === \"ENOENT\") {\n                  // ENOENT is ok here because the file may have been deleted between\n                  // the readdir and stat calls.\n                  return callback();\n                }\n                return callback(err);\n              }\n              const stat = /** @type {IStats} */_stat;\n              if (stat.isDirectory()) {\n                if (!recursive) return callback();\n                addSubDirectory(ctx, subResource, callback);\n              } else if (stat.isFile() && (!include || subResource.match(include))) {\n                /** @type {{ context: string, request: string }} */\n                const obj = {\n                  context: ctx,\n                  request: `.${subResource.slice(ctx.length).replace(/\\\\/g, \"/\")}`\n                };\n                this.hooks.alternativeRequests.callAsync([obj], options, (err, alternatives) => {\n                  if (err) return callback(err);\n                  callback(null, /** @type {ContextAlternativeRequest[]} */\n                  alternatives.filter(obj => regExp.test(/** @type {string} */obj.request)).map(obj => {\n                    const dep = new ContextElementDependency(`${obj.request}${resourceQuery}${resourceFragment}`, obj.request, typePrefix, /** @type {string} */\n                    category, referencedExports, /** @type {TODO} */\n                    obj.context, attributes);\n                    dep.optional = true;\n                    return dep;\n                  }));\n                });\n              } else {\n                callback();\n              }\n            });\n          } else {\n            callback();\n          }\n        }, (err, result) => {\n          if (err) return callback(err);\n          if (!result) return callback(null, []);\n          const flattenedResult = [];\n          for (const item of result) {\n            if (item) flattenedResult.push(...item);\n          }\n          callback(null, flattenedResult);\n        });\n      });\n    };\n\n    /**\n     * @param {string} ctx context\n     * @param {string} dir dir\n     * @param {ResolveDependenciesCallback} callback callback\n     * @returns {void}\n     */\n    const addSubDirectory = (ctx, dir, callback) => addDirectory(ctx, dir, addSubDirectory, callback);\n\n    /**\n     * @param {string} resource resource\n     * @param {ResolveDependenciesCallback} callback callback\n     */\n    const visitResource = (resource, callback) => {\n      if (typeof fs.realpath === \"function\") {\n        addDirectoryChecked(resource, resource, new Set(), callback);\n      } else {\n        addDirectory(resource, resource, addSubDirectory, callback);\n      }\n    };\n    if (typeof resource === \"string\") {\n      visitResource(resource, callback);\n    } else {\n      asyncLib.map(resource, visitResource, (err, _result) => {\n        if (err) return callback(err);\n        const result = /** @type {ContextElementDependency[][]} */_result;\n\n        // result dependencies should have unique userRequest\n        // ordered by resolve result\n        /** @type {Set<string>} */\n        const temp = new Set();\n        /** @type {ContextElementDependency[]} */\n        const res = [];\n        for (let i = 0; i < result.length; i++) {\n          const inner = result[i];\n          for (const el of inner) {\n            if (temp.has(el.userRequest)) continue;\n            res.push(el);\n            temp.add(el.userRequest);\n          }\n        }\n        callback(null, res);\n      });\n    }\n  }\n};","map":{"version":3,"names":["asyncLib","require","AsyncSeriesWaterfallHook","SyncWaterfallHook","ContextModule","ModuleFactory","ContextElementDependency","LazySet","cachedSetProperty","createFakeHook","join","EMPTY_RESOLVE_OPTIONS","module","exports","ContextModuleFactory","constructor","resolverFactory","alternativeRequests","hooks","Object","freeze","beforeResolve","afterResolve","contextModuleFiles","alternatives","name","intercept","interceptor","Error","tap","options","fn","tapAsync","items","_options","callback","tapPromise","create","data","context","dependencies","resolveOptions","dependency","fileDependencies","missingDependencies","contextDependencies","callAsync","layer","contextInfo","issuerLayer","err","beforeResolveResult","request","loaders","resource","loadersPrefix","idx","lastIndexOf","loadersRequest","slice","i","length","replace","split","contextResolver","get","category","loaderResolver","parallel","results","yield_","obj","push","resolve","yield","map","loader","result","contextResult","loaderResult","first","filter","r","path","addon","resolveDependencies","bind","resourceQuery","query","resourceFragment","fragment","fs","cmf","recursive","regExp","include","exclude","referencedExports","typePrefix","attributes","addDirectoryChecked","ctx","directory","visited","realpath","_realPath","realPath","has","recursionStack","addDirectory","_","dir","undefined","Set","add","addSubDirectory","readdir","files","processedFiles","call","file","normalize","p","indexOf","segment","subResource","match","stat","_stat","code","isDirectory","isFile","test","dep","optional","flattenedResult","item","visitResource","_result","temp","res","inner","el","userRequest"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/webpack/lib/ContextModuleFactory.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { AsyncSeriesWaterfallHook, SyncWaterfallHook } = require(\"tapable\");\nconst ContextModule = require(\"./ContextModule\");\nconst ModuleFactory = require(\"./ModuleFactory\");\nconst ContextElementDependency = require(\"./dependencies/ContextElementDependency\");\nconst LazySet = require(\"./util/LazySet\");\nconst { cachedSetProperty } = require(\"./util/cleverMerge\");\nconst { createFakeHook } = require(\"./util/deprecation\");\nconst { join } = require(\"./util/fs\");\n\n/** @typedef {import(\"./ContextModule\").ContextModuleOptions} ContextModuleOptions */\n/** @typedef {import(\"./ContextModule\").ResolveDependenciesCallback} ResolveDependenciesCallback */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryCreateData} ModuleFactoryCreateData */\n/** @typedef {import(\"./ModuleFactory\").ModuleFactoryResult} ModuleFactoryResult */\n/** @typedef {import(\"./ResolverFactory\")} ResolverFactory */\n/** @typedef {import(\"./dependencies/ContextDependency\")} ContextDependency */\n/** @typedef {import(\"enhanced-resolve\").ResolveRequest} ResolveRequest */\n/**\n * @template T\n * @typedef {import(\"./util/deprecation\").FakeHook<T>} FakeHook<T>\n */\n/** @typedef {import(\"./util/fs\").IStats} IStats */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {{ context: string, request: string }} ContextAlternativeRequest */\n\nconst EMPTY_RESOLVE_OPTIONS = {};\n\nmodule.exports = class ContextModuleFactory extends ModuleFactory {\n\t/**\n\t * @param {ResolverFactory} resolverFactory resolverFactory\n\t */\n\tconstructor(resolverFactory) {\n\t\tsuper();\n\t\t/** @type {AsyncSeriesWaterfallHook<[ContextAlternativeRequest[], ContextModuleOptions]>} */\n\t\tconst alternativeRequests = new AsyncSeriesWaterfallHook([\n\t\t\t\"modules\",\n\t\t\t\"options\"\n\t\t]);\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n\t\t\tbeforeResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\t\t\t/** @type {AsyncSeriesWaterfallHook<[TODO]>} */\n\t\t\tafterResolve: new AsyncSeriesWaterfallHook([\"data\"]),\n\t\t\t/** @type {SyncWaterfallHook<[string[]]>} */\n\t\t\tcontextModuleFiles: new SyncWaterfallHook([\"files\"]),\n\t\t\t/** @type {FakeHook<Pick<AsyncSeriesWaterfallHook<[ContextAlternativeRequest[]]>, \"tap\" | \"tapAsync\" | \"tapPromise\" | \"name\">>} */\n\t\t\talternatives: createFakeHook(\n\t\t\t\t{\n\t\t\t\t\tname: \"alternatives\",\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[ContextAlternativeRequest[]]>[\"intercept\"]} */\n\t\t\t\t\tintercept: interceptor => {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\"Intercepting fake hook ContextModuleFactory.hooks.alternatives is not possible, use ContextModuleFactory.hooks.alternativeRequests instead\"\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[ContextAlternativeRequest[]]>[\"tap\"]} */\n\t\t\t\t\ttap: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tap(options, fn);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[ContextAlternativeRequest[]]>[\"tapAsync\"]} */\n\t\t\t\t\ttapAsync: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tapAsync(options, (items, _options, callback) =>\n\t\t\t\t\t\t\tfn(items, callback)\n\t\t\t\t\t\t);\n\t\t\t\t\t},\n\t\t\t\t\t/** @type {AsyncSeriesWaterfallHook<[ContextAlternativeRequest[]]>[\"tapPromise\"]} */\n\t\t\t\t\ttapPromise: (options, fn) => {\n\t\t\t\t\t\talternativeRequests.tapPromise(options, fn);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"ContextModuleFactory.hooks.alternatives has deprecated in favor of ContextModuleFactory.hooks.alternativeRequests with an additional options argument.\",\n\t\t\t\t\"DEP_WEBPACK_CONTEXT_MODULE_FACTORY_ALTERNATIVES\"\n\t\t\t),\n\t\t\talternativeRequests\n\t\t});\n\t\tthis.resolverFactory = resolverFactory;\n\t}\n\n\t/**\n\t * @param {ModuleFactoryCreateData} data data object\n\t * @param {function((Error | null)=, ModuleFactoryResult=): void} callback callback\n\t * @returns {void}\n\t */\n\tcreate(data, callback) {\n\t\tconst context = data.context;\n\t\tconst dependencies = data.dependencies;\n\t\tconst resolveOptions = data.resolveOptions;\n\t\tconst dependency = /** @type {ContextDependency} */ (dependencies[0]);\n\t\tconst fileDependencies = new LazySet();\n\t\tconst missingDependencies = new LazySet();\n\t\tconst contextDependencies = new LazySet();\n\t\tthis.hooks.beforeResolve.callAsync(\n\t\t\t{\n\t\t\t\tcontext,\n\t\t\t\tdependencies,\n\t\t\t\tlayer: data.contextInfo.issuerLayer,\n\t\t\t\tresolveOptions,\n\t\t\t\tfileDependencies,\n\t\t\t\tmissingDependencies,\n\t\t\t\tcontextDependencies,\n\t\t\t\t...dependency.options\n\t\t\t},\n\t\t\t(err, beforeResolveResult) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t// Ignored\n\t\t\t\tif (!beforeResolveResult) {\n\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tconst context = beforeResolveResult.context;\n\t\t\t\tconst request = beforeResolveResult.request;\n\t\t\t\tconst resolveOptions = beforeResolveResult.resolveOptions;\n\n\t\t\t\tlet loaders;\n\t\t\t\tlet resource;\n\t\t\t\tlet loadersPrefix = \"\";\n\t\t\t\tconst idx = request.lastIndexOf(\"!\");\n\t\t\t\tif (idx >= 0) {\n\t\t\t\t\tlet loadersRequest = request.slice(0, idx + 1);\n\t\t\t\t\tlet i;\n\t\t\t\t\tfor (\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t\ti < loadersRequest.length && loadersRequest[i] === \"!\";\n\t\t\t\t\t\ti++\n\t\t\t\t\t) {\n\t\t\t\t\t\tloadersPrefix += \"!\";\n\t\t\t\t\t}\n\t\t\t\t\tloadersRequest = loadersRequest\n\t\t\t\t\t\t.slice(i)\n\t\t\t\t\t\t.replace(/!+$/, \"\")\n\t\t\t\t\t\t.replace(/!!+/g, \"!\");\n\t\t\t\t\tloaders = loadersRequest === \"\" ? [] : loadersRequest.split(\"!\");\n\t\t\t\t\tresource = request.slice(idx + 1);\n\t\t\t\t} else {\n\t\t\t\t\tloaders = [];\n\t\t\t\t\tresource = request;\n\t\t\t\t}\n\n\t\t\t\tconst contextResolver = this.resolverFactory.get(\n\t\t\t\t\t\"context\",\n\t\t\t\t\tdependencies.length > 0\n\t\t\t\t\t\t? cachedSetProperty(\n\t\t\t\t\t\t\t\tresolveOptions || EMPTY_RESOLVE_OPTIONS,\n\t\t\t\t\t\t\t\t\"dependencyType\",\n\t\t\t\t\t\t\t\tdependencies[0].category\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t: resolveOptions\n\t\t\t\t);\n\t\t\t\tconst loaderResolver = this.resolverFactory.get(\"loader\");\n\n\t\t\t\tasyncLib.parallel(\n\t\t\t\t\t[\n\t\t\t\t\t\tcallback => {\n\t\t\t\t\t\t\tconst results = /** @type ResolveRequest[] */ ([]);\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {ResolveRequest} obj obj\n\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst yield_ = obj => {\n\t\t\t\t\t\t\t\tresults.push(obj);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tcontextResolver.resolve(\n\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\tresource,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies,\n\t\t\t\t\t\t\t\t\tyield: yield_\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\tcallback(null, results);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcallback => {\n\t\t\t\t\t\t\tasyncLib.map(\n\t\t\t\t\t\t\t\tloaders,\n\t\t\t\t\t\t\t\t(loader, callback) => {\n\t\t\t\t\t\t\t\t\tloaderResolver.resolve(\n\t\t\t\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\tloader,\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, /** @type {string} */ (result));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet [contextResult, loaderResult] =\n\t\t\t\t\t\t\t/** @type {[ResolveRequest[], string[]]} */ (result);\n\t\t\t\t\t\tif (contextResult.length > 1) {\n\t\t\t\t\t\t\tconst first = contextResult[0];\n\t\t\t\t\t\t\tcontextResult = contextResult.filter(r => r.path);\n\t\t\t\t\t\t\tif (contextResult.length === 0) contextResult.push(first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.hooks.afterResolve.callAsync(\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\taddon:\n\t\t\t\t\t\t\t\t\tloadersPrefix +\n\t\t\t\t\t\t\t\t\tloaderResult.join(\"!\") +\n\t\t\t\t\t\t\t\t\t(loaderResult.length > 0 ? \"!\" : \"\"),\n\t\t\t\t\t\t\t\tresource:\n\t\t\t\t\t\t\t\t\tcontextResult.length > 1\n\t\t\t\t\t\t\t\t\t\t? contextResult.map(r => r.path)\n\t\t\t\t\t\t\t\t\t\t: contextResult[0].path,\n\t\t\t\t\t\t\t\tresolveDependencies: this.resolveDependencies.bind(this),\n\t\t\t\t\t\t\t\tresourceQuery: contextResult[0].query,\n\t\t\t\t\t\t\t\tresourceFragment: contextResult[0].fragment,\n\t\t\t\t\t\t\t\t...beforeResolveResult\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\treturn callback(err, {\n\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Ignored\n\t\t\t\t\t\t\t\tif (!result) {\n\t\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\tmodule: new ContextModule(result.resolveDependencies, result),\n\t\t\t\t\t\t\t\t\tfileDependencies,\n\t\t\t\t\t\t\t\t\tmissingDependencies,\n\t\t\t\t\t\t\t\t\tcontextDependencies\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {InputFileSystem} fs file system\n\t * @param {ContextModuleOptions} options options\n\t * @param {ResolveDependenciesCallback} callback callback function\n\t * @returns {void}\n\t */\n\tresolveDependencies(fs, options, callback) {\n\t\tconst cmf = this;\n\t\tconst {\n\t\t\tresource,\n\t\t\tresourceQuery,\n\t\t\tresourceFragment,\n\t\t\trecursive,\n\t\t\tregExp,\n\t\t\tinclude,\n\t\t\texclude,\n\t\t\treferencedExports,\n\t\t\tcategory,\n\t\t\ttypePrefix,\n\t\t\tattributes\n\t\t} = options;\n\t\tif (!regExp || !resource) return callback(null, []);\n\n\t\t/**\n\t\t * @param {string} ctx context\n\t\t * @param {string} directory directory\n\t\t * @param {Set<string>} visited visited\n\t\t * @param {ResolveDependenciesCallback} callback callback\n\t\t */\n\t\tconst addDirectoryChecked = (ctx, directory, visited, callback) => {\n\t\t\t/** @type {NonNullable<InputFileSystem[\"realpath\"]>} */\n\t\t\t(fs.realpath)(directory, (err, _realPath) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tconst realPath = /** @type {string} */ (_realPath);\n\t\t\t\tif (visited.has(realPath)) return callback(null, []);\n\t\t\t\t/** @type {Set<string> | undefined} */\n\t\t\t\tlet recursionStack;\n\t\t\t\taddDirectory(\n\t\t\t\t\tctx,\n\t\t\t\t\tdirectory,\n\t\t\t\t\t(_, dir, callback) => {\n\t\t\t\t\t\tif (recursionStack === undefined) {\n\t\t\t\t\t\t\trecursionStack = new Set(visited);\n\t\t\t\t\t\t\trecursionStack.add(realPath);\n\t\t\t\t\t\t}\n\t\t\t\t\t\taddDirectoryChecked(ctx, dir, recursionStack, callback);\n\t\t\t\t\t},\n\t\t\t\t\tcallback\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * @param {string} ctx context\n\t\t * @param {string} directory directory\n\t\t * @param {function(string, string, function(): void): void} addSubDirectory addSubDirectoryFn\n\t\t * @param {ResolveDependenciesCallback} callback callback\n\t\t */\n\t\tconst addDirectory = (ctx, directory, addSubDirectory, callback) => {\n\t\t\tfs.readdir(directory, (err, files) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tconst processedFiles = cmf.hooks.contextModuleFiles.call(\n\t\t\t\t\t/** @type {string[]} */ (files).map(file => file.normalize(\"NFC\"))\n\t\t\t\t);\n\t\t\t\tif (!processedFiles || processedFiles.length === 0)\n\t\t\t\t\treturn callback(null, []);\n\t\t\t\tasyncLib.map(\n\t\t\t\t\tprocessedFiles.filter(p => p.indexOf(\".\") !== 0),\n\t\t\t\t\t(segment, callback) => {\n\t\t\t\t\t\tconst subResource = join(fs, directory, segment);\n\n\t\t\t\t\t\tif (!exclude || !subResource.match(exclude)) {\n\t\t\t\t\t\t\tfs.stat(subResource, (err, _stat) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\t\t\t\t\t\t// ENOENT is ok here because the file may have been deleted between\n\t\t\t\t\t\t\t\t\t\t// the readdir and stat calls.\n\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst stat = /** @type {IStats} */ (_stat);\n\n\t\t\t\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\t\t\t\tif (!recursive) return callback();\n\t\t\t\t\t\t\t\t\taddSubDirectory(ctx, subResource, callback);\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tstat.isFile() &&\n\t\t\t\t\t\t\t\t\t(!include || subResource.match(include))\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t/** @type {{ context: string, request: string }} */\n\t\t\t\t\t\t\t\t\tconst obj = {\n\t\t\t\t\t\t\t\t\t\tcontext: ctx,\n\t\t\t\t\t\t\t\t\t\trequest: `.${subResource.slice(ctx.length).replace(/\\\\/g, \"/\")}`\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\tthis.hooks.alternativeRequests.callAsync(\n\t\t\t\t\t\t\t\t\t\t[obj],\n\t\t\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t\t\t\t(err, alternatives) => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\tcallback(\n\t\t\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {ContextAlternativeRequest[]} */\n\t\t\t\t\t\t\t\t\t\t\t\t(alternatives)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.filter(obj =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tregExp.test(/** @type {string} */ (obj.request))\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.map(obj => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst dep = new ContextElementDependency(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${obj.request}${resourceQuery}${resourceFragment}`,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tobj.request,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttypePrefix,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/** @type {string} */\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(category),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treferencedExports,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/** @type {TODO} */\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(obj.context),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tattributes\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdep.optional = true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn dep;\n\t\t\t\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t(err, result) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\tif (!result) return callback(null, []);\n\n\t\t\t\t\t\tconst flattenedResult = [];\n\n\t\t\t\t\t\tfor (const item of result) {\n\t\t\t\t\t\t\tif (item) flattenedResult.push(...item);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcallback(null, flattenedResult);\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t * @param {string} ctx context\n\t\t * @param {string} dir dir\n\t\t * @param {ResolveDependenciesCallback} callback callback\n\t\t * @returns {void}\n\t\t */\n\t\tconst addSubDirectory = (ctx, dir, callback) =>\n\t\t\taddDirectory(ctx, dir, addSubDirectory, callback);\n\n\t\t/**\n\t\t * @param {string} resource resource\n\t\t * @param {ResolveDependenciesCallback} callback callback\n\t\t */\n\t\tconst visitResource = (resource, callback) => {\n\t\t\tif (typeof fs.realpath === \"function\") {\n\t\t\t\taddDirectoryChecked(resource, resource, new Set(), callback);\n\t\t\t} else {\n\t\t\t\taddDirectory(resource, resource, addSubDirectory, callback);\n\t\t\t}\n\t\t};\n\n\t\tif (typeof resource === \"string\") {\n\t\t\tvisitResource(resource, callback);\n\t\t} else {\n\t\t\tasyncLib.map(resource, visitResource, (err, _result) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tconst result = /** @type {ContextElementDependency[][]} */ (_result);\n\n\t\t\t\t// result dependencies should have unique userRequest\n\t\t\t\t// ordered by resolve result\n\t\t\t\t/** @type {Set<string>} */\n\t\t\t\tconst temp = new Set();\n\t\t\t\t/** @type {ContextElementDependency[]} */\n\t\t\t\tconst res = [];\n\t\t\t\tfor (let i = 0; i < result.length; i++) {\n\t\t\t\t\tconst inner = result[i];\n\t\t\t\t\tfor (const el of inner) {\n\t\t\t\t\t\tif (temp.has(el.userRequest)) continue;\n\t\t\t\t\t\tres.push(el);\n\t\t\t\t\t\ttemp.add(el.userRequest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback(null, res);\n\t\t\t});\n\t\t}\n\t}\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}