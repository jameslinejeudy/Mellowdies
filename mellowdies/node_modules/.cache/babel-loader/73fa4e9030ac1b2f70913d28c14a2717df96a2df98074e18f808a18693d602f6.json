{"ast":null,"code":"/**\r\n * AudioBuffer class\r\n *\r\n * @module audio-buffer/buffer\r\n */\n'use strict';\n\nvar getContext = require('audio-context');\nmodule.exports = AudioBuffer;\n\n/**\r\n * @constructor\r\n */\nfunction AudioBuffer(context, options) {\n  if (!(this instanceof AudioBuffer)) return new AudioBuffer(context, options);\n\n  //if no options passed\n  if (!options) {\n    options = context;\n    context = options && options.context;\n  }\n  if (!options) options = {};\n  if (context === undefined) context = getContext();\n\n  //detect params\n  if (options.numberOfChannels == null) {\n    options.numberOfChannels = 1;\n  }\n  if (options.sampleRate == null) {\n    options.sampleRate = context && context.sampleRate || this.sampleRate;\n  }\n  if (options.length == null) {\n    if (options.duration != null) {\n      options.length = options.duration * options.sampleRate;\n    } else {\n      options.length = 1;\n    }\n  }\n\n  //if existing context\n  if (context && context.createBuffer) {\n    //create WAA buffer\n    return context.createBuffer(options.numberOfChannels, Math.ceil(options.length), options.sampleRate);\n  }\n\n  //exposed properties\n  this.length = Math.ceil(options.length);\n  this.numberOfChannels = options.numberOfChannels;\n  this.sampleRate = options.sampleRate;\n  this.duration = this.length / this.sampleRate;\n\n  //data is stored as a planar sequence\n  this._data = new Float32Array(this.length * this.numberOfChannels);\n\n  //channels data is cached as subarrays\n  this._channelData = [];\n  for (var c = 0; c < this.numberOfChannels; c++) {\n    this._channelData.push(this._data.subarray(c * this.length, (c + 1) * this.length));\n  }\n}\n\n/**\r\n * Default params\r\n */\nAudioBuffer.prototype.numberOfChannels = 1;\nAudioBuffer.prototype.sampleRate = 44100;\n\n/**\r\n * Return data associated with the channel.\r\n *\r\n * @return {Array} Array containing the data\r\n */\nAudioBuffer.prototype.getChannelData = function (channel) {\n  if (channel >= this.numberOfChannels || channel < 0 || channel == null) throw Error('Cannot getChannelData: channel number (' + channel + ') exceeds number of channels (' + this.numberOfChannels + ')');\n  return this._channelData[channel];\n};\n\n/**\r\n * Place data to the destination buffer, starting from the position\r\n */\nAudioBuffer.prototype.copyFromChannel = function (destination, channelNumber, startInChannel) {\n  if (startInChannel == null) startInChannel = 0;\n  var data = this._channelData[channelNumber];\n  for (var i = startInChannel, j = 0; i < this.length && j < destination.length; i++, j++) {\n    destination[j] = data[i];\n  }\n};\n\n/**\r\n * Place data from the source to the channel, starting (in self) from the position\r\n */\nAudioBuffer.prototype.copyToChannel = function (source, channelNumber, startInChannel) {\n  var data = this._channelData[channelNumber];\n  if (!startInChannel) startInChannel = 0;\n  for (var i = startInChannel, j = 0; i < this.length && j < source.length; i++, j++) {\n    data[i] = source[j];\n  }\n};","map":{"version":3,"names":["getContext","require","module","exports","AudioBuffer","context","options","undefined","numberOfChannels","sampleRate","length","duration","createBuffer","Math","ceil","_data","Float32Array","_channelData","c","push","subarray","prototype","getChannelData","channel","Error","copyFromChannel","destination","channelNumber","startInChannel","data","i","j","copyToChannel","source"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/audio-buffer/index.js"],"sourcesContent":["/**\r\n * AudioBuffer class\r\n *\r\n * @module audio-buffer/buffer\r\n */\r\n'use strict'\r\n\r\nvar getContext = require('audio-context')\r\n\r\nmodule.exports = AudioBuffer\r\n\r\n\r\n/**\r\n * @constructor\r\n */\r\nfunction AudioBuffer (context, options) {\r\n\tif (!(this instanceof AudioBuffer)) return new AudioBuffer(context, options);\r\n\r\n\t//if no options passed\r\n\tif (!options) {\r\n\t\toptions = context\r\n\t\tcontext = options && options.context\r\n\t}\r\n\r\n\tif (!options) options = {}\r\n\r\n\tif (context === undefined) context = getContext()\r\n\r\n\t//detect params\r\n\tif (options.numberOfChannels == null) {\r\n\t\toptions.numberOfChannels = 1\r\n\t}\r\n\tif (options.sampleRate == null) {\r\n\t\toptions.sampleRate = context && context.sampleRate || this.sampleRate\r\n\t}\r\n\tif (options.length == null) {\r\n\t\tif (options.duration != null) {\r\n\t\t\toptions.length = options.duration * options.sampleRate\r\n\t\t}\r\n\t\telse {\r\n\t\t\toptions.length = 1\r\n\t\t}\r\n\t}\r\n\r\n\t//if existing context\r\n\tif (context && context.createBuffer) {\r\n\t\t//create WAA buffer\r\n\t\treturn context.createBuffer(options.numberOfChannels, Math.ceil(options.length), options.sampleRate)\r\n\t}\r\n\r\n\t//exposed properties\r\n\tthis.length = Math.ceil(options.length)\r\n\tthis.numberOfChannels = options.numberOfChannels\r\n\tthis.sampleRate = options.sampleRate\r\n\tthis.duration = this.length / this.sampleRate\r\n\r\n\t//data is stored as a planar sequence\r\n\tthis._data = new Float32Array(this.length * this.numberOfChannels)\r\n\r\n\t//channels data is cached as subarrays\r\n\tthis._channelData = []\r\n\tfor (var c = 0; c < this.numberOfChannels; c++) {\r\n\t\tthis._channelData.push(this._data.subarray(c * this.length, (c+1) * this.length ))\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Default params\r\n */\r\nAudioBuffer.prototype.numberOfChannels = 1;\r\nAudioBuffer.prototype.sampleRate = 44100;\r\n\r\n\r\n/**\r\n * Return data associated with the channel.\r\n *\r\n * @return {Array} Array containing the data\r\n */\r\nAudioBuffer.prototype.getChannelData = function (channel) {\r\n\tif (channel >= this.numberOfChannels || channel < 0 || channel == null) throw Error('Cannot getChannelData: channel number (' + channel + ') exceeds number of channels (' + this.numberOfChannels + ')');\r\n\r\n\treturn this._channelData[channel]\r\n};\r\n\r\n\r\n/**\r\n * Place data to the destination buffer, starting from the position\r\n */\r\nAudioBuffer.prototype.copyFromChannel = function (destination, channelNumber, startInChannel) {\r\n\tif (startInChannel == null) startInChannel = 0;\r\n\tvar data = this._channelData[channelNumber]\r\n\tfor (var i = startInChannel, j = 0; i < this.length && j < destination.length; i++, j++) {\r\n\t\tdestination[j] = data[i];\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Place data from the source to the channel, starting (in self) from the position\r\n */\r\nAudioBuffer.prototype.copyToChannel = function (source, channelNumber, startInChannel) {\r\n\tvar data = this._channelData[channelNumber]\r\n\r\n\tif (!startInChannel) startInChannel = 0;\r\n\r\n\tfor (var i = startInChannel, j = 0; i < this.length && j < source.length; i++, j++) {\r\n\t\tdata[i] = source[j];\r\n\t}\r\n};\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}