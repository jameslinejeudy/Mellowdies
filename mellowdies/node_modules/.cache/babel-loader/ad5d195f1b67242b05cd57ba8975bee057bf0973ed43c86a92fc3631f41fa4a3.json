{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport EventEmitter from './event-emitter.js';\n/**\n * A Web Audio buffer player emulating the behavior of an HTML5 Audio element.\n */\nclass WebAudioPlayer extends EventEmitter {\n  constructor(audioContext = new AudioContext()) {\n    super();\n    this.bufferNode = null;\n    this.playStartTime = 0;\n    this.playedDuration = 0;\n    this._muted = false;\n    this._playbackRate = 1;\n    this._duration = undefined;\n    this.buffer = null;\n    this.currentSrc = '';\n    this.paused = true;\n    this.crossOrigin = null;\n    this.seeking = false;\n    this.autoplay = false;\n    /** Subscribe to an event. Returns an unsubscribe function. */\n    this.addEventListener = this.on;\n    /** Unsubscribe from an event */\n    this.removeEventListener = this.un;\n    this.audioContext = audioContext;\n    this.gainNode = this.audioContext.createGain();\n    this.gainNode.connect(this.audioContext.destination);\n  }\n  load() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return;\n    });\n  }\n  get src() {\n    return this.currentSrc;\n  }\n  set src(value) {\n    this.currentSrc = value;\n    this._duration = undefined;\n    if (!value) {\n      this.buffer = null;\n      this.emit('emptied');\n      return;\n    }\n    fetch(value).then(response => {\n      if (response.status >= 400) {\n        throw new Error(`Failed to fetch ${value}: ${response.status} (${response.statusText})`);\n      }\n      return response.arrayBuffer();\n    }).then(arrayBuffer => {\n      if (this.currentSrc !== value) return null;\n      return this.audioContext.decodeAudioData(arrayBuffer);\n    }).then(audioBuffer => {\n      if (this.currentSrc !== value) return;\n      this.buffer = audioBuffer;\n      this.emit('loadedmetadata');\n      this.emit('canplay');\n      if (this.autoplay) this.play();\n    });\n  }\n  _play() {\n    var _a;\n    if (!this.paused) return;\n    this.paused = false;\n    (_a = this.bufferNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n    this.bufferNode = this.audioContext.createBufferSource();\n    if (this.buffer) {\n      this.bufferNode.buffer = this.buffer;\n    }\n    this.bufferNode.playbackRate.value = this._playbackRate;\n    this.bufferNode.connect(this.gainNode);\n    let currentPos = this.playedDuration * this._playbackRate;\n    if (currentPos >= this.duration) {\n      currentPos = 0;\n      this.playedDuration = 0;\n    }\n    this.bufferNode.start(this.audioContext.currentTime, currentPos);\n    this.playStartTime = this.audioContext.currentTime;\n    this.bufferNode.onended = () => {\n      if (this.currentTime >= this.duration) {\n        this.pause();\n        this.emit('ended');\n      }\n    };\n  }\n  _pause() {\n    var _a;\n    this.paused = true;\n    (_a = this.bufferNode) === null || _a === void 0 ? void 0 : _a.stop();\n    this.playedDuration += this.audioContext.currentTime - this.playStartTime;\n  }\n  play() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.paused) return;\n      this._play();\n      this.emit('play');\n    });\n  }\n  pause() {\n    if (this.paused) return;\n    this._pause();\n    this.emit('pause');\n  }\n  stopAt(timeSeconds) {\n    var _a, _b;\n    const delay = timeSeconds - this.currentTime;\n    (_a = this.bufferNode) === null || _a === void 0 ? void 0 : _a.stop(this.audioContext.currentTime + delay);\n    (_b = this.bufferNode) === null || _b === void 0 ? void 0 : _b.addEventListener('ended', () => {\n      this.bufferNode = null;\n      this.pause();\n    }, {\n      once: true\n    });\n  }\n  setSinkId(deviceId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const ac = this.audioContext;\n      return ac.setSinkId(deviceId);\n    });\n  }\n  get playbackRate() {\n    return this._playbackRate;\n  }\n  set playbackRate(value) {\n    this._playbackRate = value;\n    if (this.bufferNode) {\n      this.bufferNode.playbackRate.value = value;\n    }\n  }\n  get currentTime() {\n    const time = this.paused ? this.playedDuration : this.playedDuration + (this.audioContext.currentTime - this.playStartTime);\n    return time * this._playbackRate;\n  }\n  set currentTime(value) {\n    const wasPlaying = !this.paused;\n    wasPlaying && this._pause();\n    this.playedDuration = value / this._playbackRate;\n    wasPlaying && this._play();\n    this.emit('seeking');\n    this.emit('timeupdate');\n  }\n  get duration() {\n    var _a, _b;\n    return (_a = this._duration) !== null && _a !== void 0 ? _a : ((_b = this.buffer) === null || _b === void 0 ? void 0 : _b.duration) || 0;\n  }\n  set duration(value) {\n    this._duration = value;\n  }\n  get volume() {\n    return this.gainNode.gain.value;\n  }\n  set volume(value) {\n    this.gainNode.gain.value = value;\n    this.emit('volumechange');\n  }\n  get muted() {\n    return this._muted;\n  }\n  set muted(value) {\n    if (this._muted === value) return;\n    this._muted = value;\n    if (this._muted) {\n      this.gainNode.disconnect();\n    } else {\n      this.gainNode.connect(this.audioContext.destination);\n    }\n  }\n  canPlayType(mimeType) {\n    return /^(audio|video)\\//.test(mimeType);\n  }\n  /** Get the GainNode used to play the audio. Can be used to attach filters. */\n  getGainNode() {\n    return this.gainNode;\n  }\n  /** Get decoded audio */\n  getChannelData() {\n    const channels = [];\n    if (!this.buffer) return channels;\n    const numChannels = this.buffer.numberOfChannels;\n    for (let i = 0; i < numChannels; i++) {\n      channels.push(this.buffer.getChannelData(i));\n    }\n    return channels;\n  }\n}\nexport default WebAudioPlayer;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","EventEmitter","WebAudioPlayer","constructor","audioContext","AudioContext","bufferNode","playStartTime","playedDuration","_muted","_playbackRate","_duration","undefined","buffer","currentSrc","paused","crossOrigin","seeking","autoplay","addEventListener","on","removeEventListener","un","gainNode","createGain","connect","destination","load","src","emit","fetch","response","status","Error","statusText","arrayBuffer","decodeAudioData","audioBuffer","play","_play","_a","disconnect","createBufferSource","playbackRate","currentPos","duration","start","currentTime","onended","pause","_pause","stop","stopAt","timeSeconds","_b","delay","once","setSinkId","deviceId","ac","time","wasPlaying","volume","gain","muted","canPlayType","mimeType","test","getGainNode","getChannelData","channels","numChannels","numberOfChannels","i","push"],"sources":["C:/Users/elect/Documents/CIS/4914/Mellowdies/mellowdies/node_modules/wavesurfer.js/dist/webaudio.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport EventEmitter from './event-emitter.js';\n/**\n * A Web Audio buffer player emulating the behavior of an HTML5 Audio element.\n */\nclass WebAudioPlayer extends EventEmitter {\n    constructor(audioContext = new AudioContext()) {\n        super();\n        this.bufferNode = null;\n        this.playStartTime = 0;\n        this.playedDuration = 0;\n        this._muted = false;\n        this._playbackRate = 1;\n        this._duration = undefined;\n        this.buffer = null;\n        this.currentSrc = '';\n        this.paused = true;\n        this.crossOrigin = null;\n        this.seeking = false;\n        this.autoplay = false;\n        /** Subscribe to an event. Returns an unsubscribe function. */\n        this.addEventListener = this.on;\n        /** Unsubscribe from an event */\n        this.removeEventListener = this.un;\n        this.audioContext = audioContext;\n        this.gainNode = this.audioContext.createGain();\n        this.gainNode.connect(this.audioContext.destination);\n    }\n    load() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return;\n        });\n    }\n    get src() {\n        return this.currentSrc;\n    }\n    set src(value) {\n        this.currentSrc = value;\n        this._duration = undefined;\n        if (!value) {\n            this.buffer = null;\n            this.emit('emptied');\n            return;\n        }\n        fetch(value)\n            .then((response) => {\n            if (response.status >= 400) {\n                throw new Error(`Failed to fetch ${value}: ${response.status} (${response.statusText})`);\n            }\n            return response.arrayBuffer();\n        })\n            .then((arrayBuffer) => {\n            if (this.currentSrc !== value)\n                return null;\n            return this.audioContext.decodeAudioData(arrayBuffer);\n        })\n            .then((audioBuffer) => {\n            if (this.currentSrc !== value)\n                return;\n            this.buffer = audioBuffer;\n            this.emit('loadedmetadata');\n            this.emit('canplay');\n            if (this.autoplay)\n                this.play();\n        });\n    }\n    _play() {\n        var _a;\n        if (!this.paused)\n            return;\n        this.paused = false;\n        (_a = this.bufferNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n        this.bufferNode = this.audioContext.createBufferSource();\n        if (this.buffer) {\n            this.bufferNode.buffer = this.buffer;\n        }\n        this.bufferNode.playbackRate.value = this._playbackRate;\n        this.bufferNode.connect(this.gainNode);\n        let currentPos = this.playedDuration * this._playbackRate;\n        if (currentPos >= this.duration) {\n            currentPos = 0;\n            this.playedDuration = 0;\n        }\n        this.bufferNode.start(this.audioContext.currentTime, currentPos);\n        this.playStartTime = this.audioContext.currentTime;\n        this.bufferNode.onended = () => {\n            if (this.currentTime >= this.duration) {\n                this.pause();\n                this.emit('ended');\n            }\n        };\n    }\n    _pause() {\n        var _a;\n        this.paused = true;\n        (_a = this.bufferNode) === null || _a === void 0 ? void 0 : _a.stop();\n        this.playedDuration += this.audioContext.currentTime - this.playStartTime;\n    }\n    play() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.paused)\n                return;\n            this._play();\n            this.emit('play');\n        });\n    }\n    pause() {\n        if (this.paused)\n            return;\n        this._pause();\n        this.emit('pause');\n    }\n    stopAt(timeSeconds) {\n        var _a, _b;\n        const delay = timeSeconds - this.currentTime;\n        (_a = this.bufferNode) === null || _a === void 0 ? void 0 : _a.stop(this.audioContext.currentTime + delay);\n        (_b = this.bufferNode) === null || _b === void 0 ? void 0 : _b.addEventListener('ended', () => {\n            this.bufferNode = null;\n            this.pause();\n        }, { once: true });\n    }\n    setSinkId(deviceId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const ac = this.audioContext;\n            return ac.setSinkId(deviceId);\n        });\n    }\n    get playbackRate() {\n        return this._playbackRate;\n    }\n    set playbackRate(value) {\n        this._playbackRate = value;\n        if (this.bufferNode) {\n            this.bufferNode.playbackRate.value = value;\n        }\n    }\n    get currentTime() {\n        const time = this.paused\n            ? this.playedDuration\n            : this.playedDuration + (this.audioContext.currentTime - this.playStartTime);\n        return time * this._playbackRate;\n    }\n    set currentTime(value) {\n        const wasPlaying = !this.paused;\n        wasPlaying && this._pause();\n        this.playedDuration = value / this._playbackRate;\n        wasPlaying && this._play();\n        this.emit('seeking');\n        this.emit('timeupdate');\n    }\n    get duration() {\n        var _a, _b;\n        return (_a = this._duration) !== null && _a !== void 0 ? _a : (((_b = this.buffer) === null || _b === void 0 ? void 0 : _b.duration) || 0);\n    }\n    set duration(value) {\n        this._duration = value;\n    }\n    get volume() {\n        return this.gainNode.gain.value;\n    }\n    set volume(value) {\n        this.gainNode.gain.value = value;\n        this.emit('volumechange');\n    }\n    get muted() {\n        return this._muted;\n    }\n    set muted(value) {\n        if (this._muted === value)\n            return;\n        this._muted = value;\n        if (this._muted) {\n            this.gainNode.disconnect();\n        }\n        else {\n            this.gainNode.connect(this.audioContext.destination);\n        }\n    }\n    canPlayType(mimeType) {\n        return /^(audio|video)\\//.test(mimeType);\n    }\n    /** Get the GainNode used to play the audio. Can be used to attach filters. */\n    getGainNode() {\n        return this.gainNode;\n    }\n    /** Get decoded audio */\n    getChannelData() {\n        const channels = [];\n        if (!this.buffer)\n            return channels;\n        const numChannels = this.buffer.numberOfChannels;\n        for (let i = 0; i < numChannels; i++) {\n            channels.push(this.buffer.getChannelData(i));\n        }\n        return channels;\n    }\n}\nexport default WebAudioPlayer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}