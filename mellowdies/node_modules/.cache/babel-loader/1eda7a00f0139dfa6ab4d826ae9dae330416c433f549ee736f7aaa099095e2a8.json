{"ast":null,"code":"/**\r\n * @module  audio-buffer-utils\r\n */\n\n'use strict';\n\nvar AudioBuffer = require('audio-buffer');\nvar isAudioBuffer = require('is-audio-buffer');\nvar isBrowser = require('is-browser');\nvar clamp = require('clamp');\nvar AudioContext = require('audio-context');\nvar isBuffer = require('is-buffer');\nvar createBuffer = require('audio-buffer-from');\nvar isNeg = function (number) {\n  return number === 0 && 1 / number === -Infinity;\n};\nvar nidx = function negIdx(idx, length) {\n  return idx == null ? 0 : isNeg(idx) ? length : idx <= -length ? 0 : idx < 0 ? length + idx % length : Math.min(length, idx);\n};\nvar context;\nvar utils = {\n  create: create,\n  copy: copy,\n  shallow: shallow,\n  clone: clone,\n  reverse: reverse,\n  invert: invert,\n  zero: zero,\n  noise: noise,\n  equal: equal,\n  fill: fill,\n  slice: slice,\n  concat: concat,\n  resize: resize,\n  pad: pad,\n  padLeft: padLeft,\n  padRight: padRight,\n  rotate: rotate,\n  shift: shift,\n  normalize: normalize,\n  removeStatic: removeStatic,\n  trim: trim,\n  trimLeft: trimLeft,\n  trimRight: trimRight,\n  mix: mix,\n  size: size,\n  data: data,\n  subbuffer: subbuffer,\n  repeat: repeat\n};\nObject.defineProperty(utils, 'context', {\n  get: function () {\n    if (!context) context = AudioContext();\n    return context;\n  }\n});\nmodule.exports = utils;\n\n/**\r\n * Create buffer from any argument.\r\n * Better constructor than audio-buffer.\r\n */\nfunction create(src, options, sampleRate) {\n  var length, data;\n  if (typeof options === 'number') {\n    options = {\n      channels: options\n    };\n  } else if (typeof options === 'string') {\n    options = {\n      format: options\n    };\n  } else if (!options) {\n    options = {};\n  }\n  if (sampleRate) {\n    options.sampleRate = sampleRate;\n  }\n  options.context = utils.context;\n  return createBuffer(src, options);\n}\n\n/**\r\n * Copy data from buffer A to buffer B\r\n */\nfunction copy(from, to, offset) {\n  validate(from);\n  validate(to);\n  offset = offset || 0;\n  for (var channel = 0, l = Math.min(from.numberOfChannels, to.numberOfChannels); channel < l; channel++) {\n    to.getChannelData(channel).set(from.getChannelData(channel), offset);\n  }\n  return to;\n}\n\n/**\r\n * Assert argument is AudioBuffer, throw error otherwise.\r\n */\nfunction validate(buffer) {\n  if (!isAudioBuffer(buffer)) throw new Error('Argument should be an AudioBuffer instance.');\n}\n\n/**\r\n * Create a buffer with the same characteristics as inBuffer, without copying\r\n * the data. Contents of resulting buffer are undefined.\r\n */\nfunction shallow(buffer) {\n  validate(buffer);\n\n  //workaround for faster browser creation\n  //avoid extra checks & copying inside of AudioBuffer class\n  if (isBrowser) {\n    return utils.context.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);\n  }\n  return create(buffer.length, buffer.numberOfChannels, buffer.sampleRate);\n}\n\n/**\r\n * Create clone of a buffer\r\n */\nfunction clone(buffer) {\n  return copy(buffer, shallow(buffer));\n}\n\n/**\r\n * Reverse samples in each channel\r\n */\nfunction reverse(buffer, target, start, end) {\n  validate(buffer);\n\n  //if target buffer is passed\n  if (!isAudioBuffer(target) && target != null) {\n    end = start;\n    start = target;\n    target = null;\n  }\n  if (target) {\n    validate(target);\n    copy(buffer, target);\n  } else {\n    target = buffer;\n  }\n  start = start == null ? 0 : nidx(start, buffer.length);\n  end = end == null ? buffer.length : nidx(end, buffer.length);\n  for (var i = 0, c = target.numberOfChannels; i < c; ++i) {\n    target.getChannelData(i).subarray(start, end).reverse();\n  }\n  return target;\n}\n\n/**\r\n * Invert amplitude of samples in each channel\r\n */\nfunction invert(buffer, target, start, end) {\n  //if target buffer is passed\n  if (!isAudioBuffer(target) && target != null) {\n    end = start;\n    start = target;\n    target = null;\n  }\n  return fill(buffer, target, function (sample) {\n    return -sample;\n  }, start, end);\n}\n\n/**\r\n * Fill with zeros\r\n */\nfunction zero(buffer, target, start, end) {\n  return fill(buffer, target, 0, start, end);\n}\n\n/**\r\n * Fill with white noise\r\n */\nfunction noise(buffer, target, start, end) {\n  return fill(buffer, target, function (sample) {\n    return Math.random() * 2 - 1;\n  }, start, end);\n}\n\n/**\r\n * Test whether two buffers are the same\r\n */\nfunction equal(bufferA, bufferB) {\n  //walk by all the arguments\n  if (arguments.length > 2) {\n    for (var i = 0, l = arguments.length - 1; i < l; i++) {\n      if (!equal(arguments[i], arguments[i + 1])) return false;\n    }\n    return true;\n  }\n  validate(bufferA);\n  validate(bufferB);\n  if (bufferA.length !== bufferB.length || bufferA.numberOfChannels !== bufferB.numberOfChannels) return false;\n  for (var channel = 0; channel < bufferA.numberOfChannels; channel++) {\n    var dataA = bufferA.getChannelData(channel);\n    var dataB = bufferB.getChannelData(channel);\n    for (var i = 0; i < dataA.length; i++) {\n      if (dataA[i] !== dataB[i]) return false;\n    }\n  }\n  return true;\n}\n\n/**\r\n * Generic in-place fill/transform\r\n */\nfunction fill(buffer, target, value, start, end) {\n  validate(buffer);\n\n  //if target buffer is passed\n  if (!isAudioBuffer(target) && target != null) {\n    //target is bad argument\n    if (typeof value == 'function') {\n      target = null;\n    } else {\n      end = start;\n      start = value;\n      value = target;\n      target = null;\n    }\n  }\n  if (target) {\n    validate(target);\n  } else {\n    target = buffer;\n  }\n\n  //resolve optional start/end args\n  start = start == null ? 0 : nidx(start, buffer.length);\n  end = end == null ? buffer.length : nidx(end, buffer.length);\n  //resolve type of value\n  if (!(value instanceof Function)) {\n    for (var channel = 0, c = buffer.numberOfChannels; channel < c; channel++) {\n      var targetData = target.getChannelData(channel);\n      for (var i = start; i < end; i++) {\n        targetData[i] = value;\n      }\n    }\n  } else {\n    for (var channel = 0, c = buffer.numberOfChannels; channel < c; channel++) {\n      var data = buffer.getChannelData(channel),\n        targetData = target.getChannelData(channel);\n      for (var i = start; i < end; i++) {\n        targetData[i] = value.call(buffer, data[i], i, channel, data);\n      }\n    }\n  }\n  return target;\n}\n\n/**\r\n * Repeat buffer\r\n */\nfunction repeat(buffer, times) {\n  validate(buffer);\n  if (!times || times < 0) return new AudioBuffer(null, {\n    length: 0,\n    numberOfChannels: buffer.numberOfChannels,\n    sampleRate: buffer.sampleRate\n  });\n  if (times === 1) return buffer;\n  var bufs = [];\n  for (var i = 0; i < times; i++) {\n    bufs.push(buffer);\n  }\n  return concat(bufs);\n}\n\n/**\r\n * Return sliced buffer\r\n */\nfunction slice(buffer, start, end) {\n  validate(buffer);\n  start = start == null ? 0 : nidx(start, buffer.length);\n  end = end == null ? buffer.length : nidx(end, buffer.length);\n  var data = [];\n  for (var channel = 0; channel < buffer.numberOfChannels; channel++) {\n    var channelData = buffer.getChannelData(channel);\n    data.push(channelData.slice(start, end));\n  }\n  return create(data, buffer.numberOfChannels, buffer.sampleRate);\n}\n\n/**\r\n * Create handle for a buffer from subarrays\r\n */\nfunction subbuffer(buffer, start, end, channels) {\n  validate(buffer);\n  if (Array.isArray(start)) {\n    channels = start;\n    start = 0;\n    end = -0;\n  } else if (Array.isArray(end)) {\n    channels = end;\n    end = -0;\n  }\n  if (!Array.isArray(channels)) {\n    channels = Array(buffer.numberOfChannels);\n    for (var c = 0; c < buffer.numberOfChannels; c++) {\n      channels[c] = c;\n    }\n  }\n  start = start == null ? 0 : nidx(start, buffer.length);\n  end = end == null ? buffer.length : nidx(end, buffer.length);\n  var data = [];\n  for (var i = 0; i < channels.length; i++) {\n    var channel = channels[i];\n    var channelData = buffer.getChannelData(channel);\n    data.push(channelData.subarray(start, end));\n  }\n\n  //null-context buffer covers web-audio-api buffer functions\n  var buf = new AudioBuffer(null, {\n    length: 0,\n    sampleRate: buffer.sampleRate,\n    numberOfChannels: buffer.numberOfChannels\n  });\n\n  //FIXME: not reliable hack to replace data. Mb use audio-buffer-list?\n  buf.length = data[0].length;\n  buf._data = null;\n  buf._channelData = data;\n  buf.duration = buf.length / buf.sampleRate;\n  return buf;\n}\n\n/**\r\n * Concat buffer with other buffer(s)\r\n */\nfunction concat() {\n  var list = [];\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    var arg = arguments[i];\n    if (Array.isArray(arg)) {\n      for (var j = 0; j < arg.length; j++) {\n        list.push(arg[j]);\n      }\n    } else {\n      list.push(arg);\n    }\n  }\n  var channels = 1;\n  var length = 0;\n  //FIXME: there might be required more thoughtful resampling, but now I'm lazy sry :(\n  var sampleRate = 0;\n  for (var i = 0; i < list.length; i++) {\n    var buf = list[i];\n    validate(buf);\n    length += buf.length;\n    channels = Math.max(buf.numberOfChannels, channels);\n    sampleRate = Math.max(buf.sampleRate, sampleRate);\n  }\n  var data = [];\n  for (var channel = 0; channel < channels; channel++) {\n    var channelData = new Float32Array(length),\n      offset = 0;\n    for (var i = 0; i < list.length; i++) {\n      var buf = list[i];\n      if (channel < buf.numberOfChannels) {\n        channelData.set(buf.getChannelData(channel), offset);\n      }\n      offset += buf.length;\n    }\n    data.push(channelData);\n  }\n  return create(data, channels, sampleRate);\n}\n\n/**\r\n * Change the length of the buffer, by trimming or filling with zeros\r\n */\nfunction resize(buffer, length) {\n  validate(buffer);\n  if (length < buffer.length) return slice(buffer, 0, length);\n  return concat(buffer, create(length - buffer.length, buffer.numberOfChannels));\n}\n\n/**\r\n * Pad buffer to required size\r\n */\nfunction pad(a, b, value) {\n  var buffer, length;\n  if (typeof a === 'number') {\n    buffer = b;\n    length = a;\n  } else {\n    buffer = a;\n    length = b;\n  }\n  value = value || 0;\n  validate(buffer);\n\n  //no need to pad\n  if (length < buffer.length) return buffer;\n\n  //left-pad\n  if (buffer === b) {\n    return concat(fill(create(length - buffer.length, buffer.numberOfChannels), value), buffer);\n  }\n\n  //right-pad\n  return concat(buffer, fill(create(length - buffer.length, buffer.numberOfChannels), value));\n}\nfunction padLeft(data, len, value) {\n  return pad(len, data, value);\n}\nfunction padRight(data, len, value) {\n  return pad(data, len, value);\n}\n\n/**\r\n * Shift content of the buffer in circular fashion\r\n */\nfunction rotate(buffer, offset) {\n  validate(buffer);\n  for (var channel = 0; channel < buffer.numberOfChannels; channel++) {\n    var cData = buffer.getChannelData(channel);\n    var srcData = cData.slice();\n    for (var i = 0, l = cData.length, idx; i < l; i++) {\n      idx = (offset + (offset + i < 0 ? l + i : i)) % l;\n      cData[idx] = srcData[i];\n    }\n  }\n  return buffer;\n}\n\n/**\r\n * Shift content of the buffer\r\n */\nfunction shift(buffer, offset) {\n  validate(buffer);\n  for (var channel = 0; channel < buffer.numberOfChannels; channel++) {\n    var cData = buffer.getChannelData(channel);\n    if (offset > 0) {\n      for (var i = cData.length - offset; i--;) {\n        cData[i + offset] = cData[i];\n      }\n    } else {\n      for (var i = -offset, l = cData.length - offset; i < l; i++) {\n        cData[i + offset] = cData[i] || 0;\n      }\n    }\n  }\n  return buffer;\n}\n\n/**\r\n * Normalize buffer by the maximum value,\r\n * limit values by the -1..1 range\r\n */\nfunction normalize(buffer, target, start, end) {\n  //resolve optional target arg\n  if (!isAudioBuffer(target)) {\n    end = start;\n    start = target;\n    target = null;\n  }\n  start = start == null ? 0 : nidx(start, buffer.length);\n  end = end == null ? buffer.length : nidx(end, buffer.length);\n\n  //for every channel bring it to max-min amplitude range\n  var max = 0;\n  for (var c = 0; c < buffer.numberOfChannels; c++) {\n    var data = buffer.getChannelData(c);\n    for (var i = start; i < end; i++) {\n      max = Math.max(Math.abs(data[i]), max);\n    }\n  }\n  var amp = Math.max(1 / max, 1);\n  return fill(buffer, target, function (value, i, ch) {\n    return clamp(value * amp, -1, 1);\n  }, start, end);\n}\n\n/**\r\n * remove DC offset\r\n */\nfunction removeStatic(buffer, target, start, end) {\n  var means = mean(buffer, start, end);\n  return fill(buffer, target, function (value, i, ch) {\n    return value - means[ch];\n  }, start, end);\n}\n\n/**\r\n * Get average level per-channel\r\n */\nfunction mean(buffer, start, end) {\n  validate(buffer);\n  start = start == null ? 0 : nidx(start, buffer.length);\n  end = end == null ? buffer.length : nidx(end, buffer.length);\n  if (end - start < 1) return [];\n  var result = [];\n  for (var c = 0; c < buffer.numberOfChannels; c++) {\n    var sum = 0;\n    var data = buffer.getChannelData(c);\n    for (var i = start; i < end; i++) {\n      sum += data[i];\n    }\n    result.push(sum / (end - start));\n  }\n  return result;\n}\n\n/**\r\n * Trim sound (remove zeros from the beginning and the end)\r\n */\nfunction trim(buffer, level) {\n  return trimInternal(buffer, level, true, true);\n}\nfunction trimLeft(buffer, level) {\n  return trimInternal(buffer, level, true, false);\n}\nfunction trimRight(buffer, level) {\n  return trimInternal(buffer, level, false, true);\n}\nfunction trimInternal(buffer, level, trimLeft, trimRight) {\n  validate(buffer);\n  level = level == null ? 0 : Math.abs(level);\n  var start, end;\n  if (trimLeft) {\n    start = buffer.length;\n    //FIXME: replace with indexOF\n    for (var channel = 0, c = buffer.numberOfChannels; channel < c; channel++) {\n      var data = buffer.getChannelData(channel);\n      for (var i = 0; i < data.length; i++) {\n        if (i > start) break;\n        if (Math.abs(data[i]) > level) {\n          start = i;\n          break;\n        }\n      }\n    }\n  } else {\n    start = 0;\n  }\n  if (trimRight) {\n    end = 0;\n    //FIXME: replace with lastIndexOf\n    for (var channel = 0, c = buffer.numberOfChannels; channel < c; channel++) {\n      var data = buffer.getChannelData(channel);\n      for (var i = data.length - 1; i >= 0; i--) {\n        if (i < end) break;\n        if (Math.abs(data[i]) > level) {\n          end = i + 1;\n          break;\n        }\n      }\n    }\n  } else {\n    end = buffer.length;\n  }\n  return slice(buffer, start, end);\n}\n\n/**\r\n * Mix current buffer with the other one.\r\n * The reason to modify bufferA instead of returning the new buffer\r\n * is reduced amount of calculations and flexibility.\r\n * If required, the cloning can be done before mixing, which will be the same.\r\n */\nfunction mix(bufferA, bufferB, ratio, offset) {\n  validate(bufferA);\n  validate(bufferB);\n  if (ratio == null) ratio = 0.5;\n  var fn = ratio instanceof Function ? ratio : function (a, b) {\n    return a * (1 - ratio) + b * ratio;\n  };\n  if (offset == null) offset = 0;else if (offset < 0) offset += bufferA.length;\n  for (var channel = 0; channel < bufferA.numberOfChannels; channel++) {\n    var aData = bufferA.getChannelData(channel);\n    var bData = bufferB.getChannelData(channel);\n    for (var i = offset, j = 0; i < bufferA.length && j < bufferB.length; i++, j++) {\n      aData[i] = fn.call(bufferA, aData[i], bData[j], j, channel);\n    }\n  }\n  return bufferA;\n}\n\n/**\r\n * Size of a buffer, in bytes\r\n */\nfunction size(buffer) {\n  validate(buffer);\n  return buffer.numberOfChannels * buffer.getChannelData(0).byteLength;\n}\n\n/**\r\n * Return array with buffer’s per-channel data\r\n */\nfunction data(buffer, data) {\n  validate(buffer);\n\n  //ensure output data array, if not defined\n  data = data || [];\n\n  //transfer data per-channel\n  for (var channel = 0; channel < buffer.numberOfChannels; channel++) {\n    if (ArrayBuffer.isView(data[channel])) {\n      data[channel].set(buffer.getChannelData(channel));\n    } else {\n      data[channel] = buffer.getChannelData(channel);\n    }\n  }\n  return data;\n}","map":{"version":3,"names":["AudioBuffer","require","isAudioBuffer","isBrowser","clamp","AudioContext","isBuffer","createBuffer","isNeg","number","Infinity","nidx","negIdx","idx","length","Math","min","context","utils","create","copy","shallow","clone","reverse","invert","zero","noise","equal","fill","slice","concat","resize","pad","padLeft","padRight","rotate","shift","normalize","removeStatic","trim","trimLeft","trimRight","mix","size","data","subbuffer","repeat","Object","defineProperty","get","module","exports","src","options","sampleRate","channels","format","from","to","offset","validate","channel","l","numberOfChannels","getChannelData","set","buffer","Error","target","start","end","i","c","subarray","sample","random","bufferA","bufferB","arguments","dataA","dataB","value","Function","targetData","call","times","bufs","push","channelData","Array","isArray","buf","_data","_channelData","duration","list","arg","j","max","Float32Array","a","b","len","cData","srcData","abs","amp","ch","means","mean","result","sum","level","trimInternal","ratio","fn","aData","bData","byteLength","ArrayBuffer","isView"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/audio-buffer-utils/index.js"],"sourcesContent":["/**\r\n * @module  audio-buffer-utils\r\n */\r\n\r\n'use strict'\r\n\r\nvar AudioBuffer = require('audio-buffer')\r\nvar isAudioBuffer = require('is-audio-buffer')\r\nvar isBrowser = require('is-browser')\r\nvar clamp = require('clamp')\r\nvar AudioContext = require('audio-context')\r\nvar isBuffer = require('is-buffer')\r\nvar createBuffer = require('audio-buffer-from')\r\n\r\nvar isNeg = function (number) {\r\n\treturn number === 0 && (1 / number) === -Infinity;\r\n};\r\n\r\nvar nidx = function negIdx (idx, length) {\r\n\treturn idx == null ? 0 : isNeg(idx) ? length : idx <= -length ? 0 : idx < 0 ? (length + (idx % length)) : Math.min(length, idx);\r\n}\r\n\r\nvar context\r\n\r\nvar utils = {\r\n\tcreate: create,\r\n\tcopy: copy,\r\n\tshallow: shallow,\r\n\tclone: clone,\r\n\treverse: reverse,\r\n\tinvert: invert,\r\n\tzero: zero,\r\n\tnoise: noise,\r\n\tequal: equal,\r\n\tfill: fill,\r\n\tslice: slice,\r\n\tconcat: concat,\r\n\tresize: resize,\r\n\tpad: pad,\r\n\tpadLeft: padLeft,\r\n\tpadRight: padRight,\r\n\trotate: rotate,\r\n\tshift: shift,\r\n\tnormalize: normalize,\r\n\tremoveStatic: removeStatic,\r\n\ttrim: trim,\r\n\ttrimLeft: trimLeft,\r\n\ttrimRight: trimRight,\r\n\tmix: mix,\r\n\tsize: size,\r\n\tdata: data,\r\n\tsubbuffer: subbuffer,\r\n\trepeat: repeat\r\n}\r\n\r\nObject.defineProperty(utils, 'context', {\r\n\tget: function () {\r\n\t\tif (!context) context = AudioContext()\r\n\t\treturn context\r\n\t}\r\n})\r\n\r\nmodule.exports = utils\r\n\r\n/**\r\n * Create buffer from any argument.\r\n * Better constructor than audio-buffer.\r\n */\r\nfunction create (src, options, sampleRate) {\r\n\tvar length, data\r\n\r\n\tif (typeof options === 'number') {\r\n\t\toptions = {channels: options}\r\n\t}\r\n\telse if (typeof options === 'string') {\r\n\t\toptions = {format: options}\r\n\t}\r\n\telse if (!options) {\r\n\t\toptions = {}\r\n\t}\r\n\tif (sampleRate) {\r\n\t\toptions.sampleRate = sampleRate\r\n\t}\r\n\toptions.context = utils.context\r\n\r\n\treturn createBuffer(src, options)\r\n}\r\n\r\n\r\n/**\r\n * Copy data from buffer A to buffer B\r\n */\r\nfunction copy (from, to, offset) {\r\n\tvalidate(from);\r\n\tvalidate(to);\r\n\r\n\toffset = offset || 0;\r\n\r\n\tfor (var channel = 0, l = Math.min(from.numberOfChannels, to.numberOfChannels); channel < l; channel++) {\r\n\t\tto.getChannelData(channel).set(from.getChannelData(channel), offset);\r\n\t}\r\n\r\n\treturn to;\r\n}\r\n\r\n\r\n/**\r\n * Assert argument is AudioBuffer, throw error otherwise.\r\n */\r\nfunction validate (buffer) {\r\n\tif (!isAudioBuffer(buffer)) throw new Error('Argument should be an AudioBuffer instance.');\r\n}\r\n\r\n\r\n\r\n/**\r\n * Create a buffer with the same characteristics as inBuffer, without copying\r\n * the data. Contents of resulting buffer are undefined.\r\n */\r\nfunction shallow (buffer) {\r\n\tvalidate(buffer);\r\n\r\n\t//workaround for faster browser creation\r\n\t//avoid extra checks & copying inside of AudioBuffer class\r\n\tif (isBrowser) {\r\n\t\treturn utils.context.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);\r\n\t}\r\n\r\n\treturn create(buffer.length, buffer.numberOfChannels, buffer.sampleRate);\r\n}\r\n\r\n\r\n/**\r\n * Create clone of a buffer\r\n */\r\nfunction clone (buffer) {\r\n\treturn copy(buffer, shallow(buffer));\r\n}\r\n\r\n\r\n/**\r\n * Reverse samples in each channel\r\n */\r\nfunction reverse (buffer, target, start, end) {\r\n\tvalidate(buffer);\r\n\r\n\t//if target buffer is passed\r\n\tif (!isAudioBuffer(target) && target != null) {\r\n\t\tend = start;\r\n\t\tstart = target;\r\n\t\ttarget = null;\r\n\t}\r\n\r\n\tif (target) {\r\n\t\tvalidate(target);\r\n\t\tcopy(buffer, target);\r\n\t}\r\n\telse {\r\n\t\ttarget = buffer;\r\n\t}\r\n\r\n\tstart = start == null ? 0 : nidx(start, buffer.length);\r\n\tend = end == null ? buffer.length : nidx(end, buffer.length);\r\n\r\n\tfor (var i = 0, c = target.numberOfChannels; i < c; ++i) {\r\n\t\ttarget.getChannelData(i).subarray(start, end).reverse();\r\n\t}\r\n\r\n\treturn target;\r\n}\r\n\r\n\r\n/**\r\n * Invert amplitude of samples in each channel\r\n */\r\nfunction invert (buffer, target, start, end) {\r\n\t//if target buffer is passed\r\n\tif (!isAudioBuffer(target) && target != null) {\r\n\t\tend = start;\r\n\t\tstart = target;\r\n\t\ttarget = null;\r\n\t}\r\n\r\n\treturn fill(buffer, target, function (sample) { return -sample; }, start, end);\r\n}\r\n\r\n\r\n/**\r\n * Fill with zeros\r\n */\r\nfunction zero (buffer, target, start, end) {\r\n\treturn fill(buffer, target, 0, start, end);\r\n}\r\n\r\n\r\n/**\r\n * Fill with white noise\r\n */\r\nfunction noise (buffer, target, start, end) {\r\n\treturn fill(buffer, target, function (sample) { return Math.random() * 2 - 1; }, start, end);\r\n}\r\n\r\n\r\n/**\r\n * Test whether two buffers are the same\r\n */\r\nfunction equal (bufferA, bufferB) {\r\n\t//walk by all the arguments\r\n\tif (arguments.length > 2) {\r\n\t\tfor (var i = 0, l = arguments.length - 1; i < l; i++) {\r\n\t\t\tif (!equal(arguments[i], arguments[i + 1])) return false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\tvalidate(bufferA);\r\n\tvalidate(bufferB);\r\n\r\n\tif (bufferA.length !== bufferB.length || bufferA.numberOfChannels !== bufferB.numberOfChannels) return false;\r\n\r\n\tfor (var channel = 0; channel < bufferA.numberOfChannels; channel++) {\r\n\t\tvar dataA = bufferA.getChannelData(channel);\r\n\t\tvar dataB = bufferB.getChannelData(channel);\r\n\r\n\t\tfor (var i = 0; i < dataA.length; i++) {\r\n\t\t\tif (dataA[i] !== dataB[i]) return false;\r\n\t\t}\r\n\t}\r\n\r\n\treturn true;\r\n}\r\n\r\n\r\n\r\n/**\r\n * Generic in-place fill/transform\r\n */\r\nfunction fill (buffer, target, value, start, end) {\r\n\tvalidate(buffer);\r\n\r\n\t//if target buffer is passed\r\n\tif (!isAudioBuffer(target) && target != null) {\r\n\t\t//target is bad argument\r\n\t\tif (typeof value == 'function') {\r\n\t\t\ttarget = null;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tend = start;\r\n\t\t\tstart = value;\r\n\t\t\tvalue = target;\r\n\t\t\ttarget = null;\r\n\t\t}\r\n\t}\r\n\r\n\tif (target) {\r\n\t\tvalidate(target);\r\n\t}\r\n\telse {\r\n\t\ttarget = buffer;\r\n\t}\r\n\r\n\t//resolve optional start/end args\r\n\tstart = start == null ? 0 : nidx(start, buffer.length);\r\n\tend = end == null ? buffer.length : nidx(end, buffer.length);\r\n\t//resolve type of value\r\n\tif (!(value instanceof Function)) {\r\n\t\tfor (var channel = 0, c = buffer.numberOfChannels; channel < c; channel++) {\r\n\t\t\tvar targetData = target.getChannelData(channel);\r\n\t\t\tfor (var i = start; i < end; i++) {\r\n\t\t\t\ttargetData[i] = value\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\telse {\r\n\t\tfor (var channel = 0, c = buffer.numberOfChannels; channel < c; channel++) {\r\n\t\t\tvar data = buffer.getChannelData(channel),\r\n\t\t\t\ttargetData = target.getChannelData(channel);\r\n\t\t\tfor (var i = start; i < end; i++) {\r\n\t\t\t\ttargetData[i] = value.call(buffer, data[i], i, channel, data);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn target;\r\n}\r\n\r\n/**\r\n * Repeat buffer\r\n */\r\nfunction repeat (buffer, times) {\r\n\tvalidate(buffer);\r\n\r\n\tif (!times || times < 0) return new AudioBuffer(null, {length: 0, numberOfChannels: buffer.numberOfChannels, sampleRate: buffer.sampleRate})\r\n\r\n\tif (times === 1) return buffer\r\n\r\n\tvar bufs = []\r\n\tfor (var i = 0; i < times; i++) {\r\n\t\tbufs.push(buffer)\r\n\t}\r\n\r\n\treturn concat(bufs)\r\n}\r\n\r\n/**\r\n * Return sliced buffer\r\n */\r\nfunction slice (buffer, start, end) {\r\n\tvalidate(buffer);\r\n\r\n\tstart = start == null ? 0 : nidx(start, buffer.length);\r\n\tend = end == null ? buffer.length : nidx(end, buffer.length);\r\n\r\n\tvar data = [];\r\n\tfor (var channel = 0; channel < buffer.numberOfChannels; channel++) {\r\n\t\tvar channelData = buffer.getChannelData(channel)\r\n\t\tdata.push(channelData.slice(start, end));\r\n\t}\r\n\treturn create(data, buffer.numberOfChannels, buffer.sampleRate);\r\n}\r\n\r\n/**\r\n * Create handle for a buffer from subarrays\r\n */\r\nfunction subbuffer (buffer, start, end, channels) {\r\n\tvalidate(buffer);\r\n\r\n\tif (Array.isArray(start)) {\r\n\t\tchannels = start\r\n\t\tstart = 0;\r\n\t\tend = -0;\r\n\t}\r\n\telse if (Array.isArray(end)) {\r\n\t\tchannels = end\r\n\t\tend = -0;\r\n\t}\r\n\r\n\tif (!Array.isArray(channels)) {\r\n\t\tchannels = Array(buffer.numberOfChannels)\r\n\t\tfor (var c = 0; c < buffer.numberOfChannels; c++) {\r\n\t\t\tchannels[c] = c\r\n\t\t}\r\n\t}\r\n\r\n\tstart = start == null ? 0 : nidx(start, buffer.length);\r\n\tend = end == null ? buffer.length : nidx(end, buffer.length);\r\n\r\n\tvar data = [];\r\n\tfor (var i = 0; i < channels.length; i++) {\r\n\t\tvar channel = channels[i]\r\n\t\tvar channelData = buffer.getChannelData(channel)\r\n\t\tdata.push(channelData.subarray(start, end));\r\n\t}\r\n\r\n\t//null-context buffer covers web-audio-api buffer functions\r\n\tvar buf = new AudioBuffer(null, {length: 0, sampleRate: buffer.sampleRate, numberOfChannels: buffer.numberOfChannels})\r\n\r\n\t//FIXME: not reliable hack to replace data. Mb use audio-buffer-list?\r\n\tbuf.length = data[0].length\r\n\tbuf._data = null\r\n\tbuf._channelData = data\r\n\tbuf.duration = buf.length / buf.sampleRate\r\n\r\n\treturn buf\r\n}\r\n\r\n/**\r\n * Concat buffer with other buffer(s)\r\n */\r\nfunction concat () {\r\n\tvar list = []\r\n\r\n\tfor (var i = 0, l = arguments.length; i < l; i++) {\r\n\t\tvar arg = arguments[i]\r\n\t\tif (Array.isArray(arg)) {\r\n\t\t\tfor (var j = 0; j < arg.length; j++) {\r\n\t\t\t\tlist.push(arg[j])\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tlist.push(arg)\r\n\t\t}\r\n\t}\r\n\r\n\tvar channels = 1;\r\n\tvar length = 0;\r\n\t//FIXME: there might be required more thoughtful resampling, but now I'm lazy sry :(\r\n\tvar sampleRate = 0;\r\n\r\n\tfor (var i = 0; i < list.length; i++) {\r\n\t\tvar buf = list[i]\r\n\t\tvalidate(buf)\r\n\t\tlength += buf.length\r\n\t\tchannels = Math.max(buf.numberOfChannels, channels)\r\n\t\tsampleRate = Math.max(buf.sampleRate, sampleRate)\r\n\t}\r\n\r\n\tvar data = [];\r\n\tfor (var channel = 0; channel < channels; channel++) {\r\n\t\tvar channelData = new Float32Array(length), offset = 0\r\n\r\n\t\tfor (var i = 0; i < list.length; i++) {\r\n\t\t\tvar buf = list[i]\r\n\t\t\tif (channel < buf.numberOfChannels) {\r\n\t\t\t\tchannelData.set(buf.getChannelData(channel), offset);\r\n\t\t\t}\r\n\t\t\toffset += buf.length\r\n\t\t}\r\n\r\n\t\tdata.push(channelData);\r\n\t}\r\n\r\n\treturn create(data, channels, sampleRate);\r\n}\r\n\r\n\r\n/**\r\n * Change the length of the buffer, by trimming or filling with zeros\r\n */\r\nfunction resize (buffer, length) {\r\n\tvalidate(buffer);\r\n\r\n\tif (length < buffer.length) return slice(buffer, 0, length);\r\n\r\n\treturn concat(buffer, create(length - buffer.length, buffer.numberOfChannels));\r\n}\r\n\r\n\r\n/**\r\n * Pad buffer to required size\r\n */\r\nfunction pad (a, b, value) {\r\n\tvar buffer, length;\r\n\r\n\tif (typeof a === 'number') {\r\n\t\tbuffer = b;\r\n\t\tlength = a;\r\n\t} else {\r\n\t\tbuffer = a;\r\n\t\tlength = b;\r\n\t}\r\n\r\n\tvalue = value || 0;\r\n\r\n\tvalidate(buffer);\r\n\r\n\t//no need to pad\r\n\tif (length < buffer.length) return buffer;\r\n\r\n\t//left-pad\r\n\tif (buffer === b) {\r\n\t\treturn concat(fill(create(length - buffer.length, buffer.numberOfChannels), value), buffer);\r\n\t}\r\n\r\n\t//right-pad\r\n\treturn concat(buffer, fill(create(length - buffer.length, buffer.numberOfChannels), value));\r\n}\r\nfunction padLeft (data, len, value) {\r\n\treturn pad(len, data, value)\r\n}\r\nfunction padRight (data, len, value) {\r\n\treturn pad(data, len, value)\r\n}\r\n\r\n\r\n\r\n/**\r\n * Shift content of the buffer in circular fashion\r\n */\r\nfunction rotate (buffer, offset) {\r\n\tvalidate(buffer);\r\n\r\n\tfor (var channel = 0; channel < buffer.numberOfChannels; channel++) {\r\n\t\tvar cData = buffer.getChannelData(channel);\r\n\t\tvar srcData = cData.slice();\r\n\t\tfor (var i = 0, l = cData.length, idx; i < l; i++) {\r\n\t\t\tidx = (offset + (offset + i < 0 ? l + i : i )) % l;\r\n\t\t\tcData[idx] = srcData[i];\r\n\t\t}\r\n\t}\r\n\r\n\treturn buffer;\r\n}\r\n\r\n\r\n/**\r\n * Shift content of the buffer\r\n */\r\nfunction shift (buffer, offset) {\r\n\tvalidate(buffer);\r\n\r\n\tfor (var channel = 0; channel < buffer.numberOfChannels; channel++) {\r\n\t\tvar cData = buffer.getChannelData(channel);\r\n\t\tif (offset > 0) {\r\n\t\t\tfor (var i = cData.length - offset; i--;) {\r\n\t\t\t\tcData[i + offset] = cData[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tfor (var i = -offset, l = cData.length - offset; i < l; i++) {\r\n\t\t\t\tcData[i + offset] = cData[i] || 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn buffer;\r\n}\r\n\r\n\r\n/**\r\n * Normalize buffer by the maximum value,\r\n * limit values by the -1..1 range\r\n */\r\nfunction normalize (buffer, target, start, end) {\r\n\t//resolve optional target arg\r\n\tif (!isAudioBuffer(target)) {\r\n\t\tend = start;\r\n\t\tstart = target;\r\n\t\ttarget = null;\r\n\t}\r\n\r\n\tstart = start == null ? 0 : nidx(start, buffer.length);\r\n\tend = end == null ? buffer.length : nidx(end, buffer.length);\r\n\r\n\t//for every channel bring it to max-min amplitude range\r\n\tvar max = 0\r\n\r\n\tfor (var c = 0; c < buffer.numberOfChannels; c++) {\r\n\t\tvar data = buffer.getChannelData(c)\r\n\t\tfor (var i = start; i < end; i++) {\r\n\t\t\tmax = Math.max(Math.abs(data[i]), max)\r\n\t\t}\r\n\t}\r\n\r\n\tvar amp = Math.max(1 / max, 1)\r\n\r\n\treturn fill(buffer, target, function (value, i, ch) {\r\n\t\treturn clamp(value * amp, -1, 1)\r\n\t}, start, end);\r\n}\r\n\r\n/**\r\n * remove DC offset\r\n */\r\nfunction removeStatic (buffer, target, start, end) {\r\n\tvar means = mean(buffer, start, end)\r\n\r\n\treturn fill(buffer, target, function (value, i, ch) {\r\n\t\treturn value - means[ch];\r\n\t}, start, end);\r\n}\r\n\r\n/**\r\n * Get average level per-channel\r\n */\r\nfunction mean (buffer, start, end) {\r\n\tvalidate(buffer)\r\n\r\n\tstart = start == null ? 0 : nidx(start, buffer.length);\r\n\tend = end == null ? buffer.length : nidx(end, buffer.length);\r\n\r\n\tif (end - start < 1) return []\r\n\r\n\tvar result = []\r\n\r\n\tfor (var c = 0; c < buffer.numberOfChannels; c++) {\r\n\t\tvar sum = 0\r\n\t\tvar data = buffer.getChannelData(c)\r\n\t\tfor (var i = start; i < end; i++) {\r\n\t\t\tsum += data[i]\r\n\t\t}\r\n\t\tresult.push(sum / (end - start))\r\n\t}\r\n\r\n\treturn result\r\n}\r\n\r\n\r\n/**\r\n * Trim sound (remove zeros from the beginning and the end)\r\n */\r\nfunction trim (buffer, level) {\r\n\treturn trimInternal(buffer, level, true, true);\r\n}\r\n\r\nfunction trimLeft (buffer, level) {\r\n\treturn trimInternal(buffer, level, true, false);\r\n}\r\n\r\nfunction trimRight (buffer, level) {\r\n\treturn trimInternal(buffer, level, false, true);\r\n}\r\n\r\nfunction trimInternal(buffer, level, trimLeft, trimRight) {\r\n\tvalidate(buffer);\r\n\r\n\tlevel = (level == null) ? 0 : Math.abs(level);\r\n\r\n\tvar start, end;\r\n\r\n\tif (trimLeft) {\r\n\t\tstart = buffer.length;\r\n\t\t//FIXME: replace with indexOF\r\n\t\tfor (var channel = 0, c = buffer.numberOfChannels; channel < c; channel++) {\r\n\t\t\tvar data = buffer.getChannelData(channel);\r\n\t\t\tfor (var i = 0; i < data.length; i++) {\r\n\t\t\t\tif (i > start) break;\r\n\t\t\t\tif (Math.abs(data[i]) > level) {\r\n\t\t\t\t\tstart = i;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tstart = 0;\r\n\t}\r\n\r\n\tif (trimRight) {\r\n\t\tend = 0;\r\n\t\t//FIXME: replace with lastIndexOf\r\n\t\tfor (var channel = 0, c = buffer.numberOfChannels; channel < c; channel++) {\r\n\t\t\tvar data = buffer.getChannelData(channel);\r\n\t\t\tfor (var i = data.length - 1; i >= 0; i--) {\r\n\t\t\t\tif (i < end) break;\r\n\t\t\t\tif (Math.abs(data[i]) > level) {\r\n\t\t\t\t\tend = i + 1;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t} else {\r\n\t\tend = buffer.length;\r\n\t}\r\n\r\n\treturn slice(buffer, start, end);\r\n}\r\n\r\n\r\n/**\r\n * Mix current buffer with the other one.\r\n * The reason to modify bufferA instead of returning the new buffer\r\n * is reduced amount of calculations and flexibility.\r\n * If required, the cloning can be done before mixing, which will be the same.\r\n */\r\nfunction mix (bufferA, bufferB, ratio, offset) {\r\n\tvalidate(bufferA);\r\n\tvalidate(bufferB);\r\n\r\n\tif (ratio == null) ratio = 0.5;\r\n\tvar fn = ratio instanceof Function ? ratio : function (a, b) {\r\n\t\treturn a * (1 - ratio) + b * ratio;\r\n\t};\r\n\r\n\tif (offset == null) offset = 0;\r\n\telse if (offset < 0) offset += bufferA.length;\r\n\r\n\tfor (var channel = 0; channel < bufferA.numberOfChannels; channel++) {\r\n\t\tvar aData = bufferA.getChannelData(channel);\r\n\t\tvar bData = bufferB.getChannelData(channel);\r\n\r\n\t\tfor (var i = offset, j = 0; i < bufferA.length && j < bufferB.length; i++, j++) {\r\n\t\t\taData[i] = fn.call(bufferA, aData[i], bData[j], j, channel);\r\n\t\t}\r\n\t}\r\n\r\n\treturn bufferA;\r\n}\r\n\r\n\r\n/**\r\n * Size of a buffer, in bytes\r\n */\r\nfunction size (buffer) {\r\n\tvalidate(buffer);\r\n\r\n\treturn buffer.numberOfChannels * buffer.getChannelData(0).byteLength;\r\n}\r\n\r\n\r\n/**\r\n * Return array with buffer’s per-channel data\r\n */\r\nfunction data (buffer, data) {\r\n\tvalidate(buffer);\r\n\r\n\t//ensure output data array, if not defined\r\n\tdata = data || [];\r\n\r\n\t//transfer data per-channel\r\n\tfor (var channel = 0; channel < buffer.numberOfChannels; channel++) {\r\n\t\tif (ArrayBuffer.isView(data[channel])) {\r\n\t\t\tdata[channel].set(buffer.getChannelData(channel));\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdata[channel] = buffer.getChannelData(channel);\r\n\t\t}\r\n\t}\r\n\r\n\treturn data;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}