{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"eslint-scope\").Reference} Reference */\n/** @typedef {import(\"eslint-scope\").Variable} Variable */\n/** @typedef {import(\"../javascript/JavascriptParser\").AnyNode} AnyNode */\n/** @typedef {import(\"../javascript/JavascriptParser\").Program} Program */\n\n/**\n * @param {Variable} variable variable\n * @returns {Reference[]} references\n */\nconst getAllReferences = variable => {\n  let set = variable.references;\n  // Look for inner scope variables too (like in class Foo { t() { Foo } })\n  const identifiers = new Set(variable.identifiers);\n  for (const scope of variable.scope.childScopes) {\n    for (const innerVar of scope.variables) {\n      if (innerVar.identifiers.some(id => identifiers.has(id))) {\n        set = set.concat(innerVar.references);\n        break;\n      }\n    }\n  }\n  return set;\n};\n\n/**\n * @param {Program | Program[]} ast ast\n * @param {AnyNode} node node\n * @returns {undefined | AnyNode[]} result\n */\nconst getPathInAst = (ast, node) => {\n  if (ast === node) {\n    return [];\n  }\n  const nr = node.range;\n  const enterNode = n => {\n    if (!n) return;\n    const r = n.range;\n    if (r && r[0] <= nr[0] && r[1] >= nr[1]) {\n      const path = getPathInAst(n, node);\n      if (path) {\n        path.push(n);\n        return path;\n      }\n    }\n  };\n  if (Array.isArray(ast)) {\n    for (let i = 0; i < ast.length; i++) {\n      const enterResult = enterNode(ast[i]);\n      if (enterResult !== undefined) return enterResult;\n    }\n  } else if (ast && typeof ast === \"object\") {\n    const keys = Object.keys(ast);\n    for (let i = 0; i < keys.length; i++) {\n      const value = ast[keys[i]];\n      if (Array.isArray(value)) {\n        const pathResult = getPathInAst(value, node);\n        if (pathResult !== undefined) return pathResult;\n      } else if (value && typeof value === \"object\") {\n        const enterResult = enterNode(value);\n        if (enterResult !== undefined) return enterResult;\n      }\n    }\n  }\n};\nmodule.exports = {\n  getAllReferences,\n  getPathInAst\n};","map":{"version":3,"names":["getAllReferences","variable","set","references","identifiers","Set","scope","childScopes","innerVar","variables","some","id","has","concat","getPathInAst","ast","node","nr","range","enterNode","n","r","path","push","Array","isArray","i","length","enterResult","undefined","keys","Object","value","pathResult","module","exports"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/webpack/lib/util/mergeScope.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/** @typedef {import(\"eslint-scope\").Reference} Reference */\n/** @typedef {import(\"eslint-scope\").Variable} Variable */\n/** @typedef {import(\"../javascript/JavascriptParser\").AnyNode} AnyNode */\n/** @typedef {import(\"../javascript/JavascriptParser\").Program} Program */\n\n/**\n * @param {Variable} variable variable\n * @returns {Reference[]} references\n */\nconst getAllReferences = variable => {\n\tlet set = variable.references;\n\t// Look for inner scope variables too (like in class Foo { t() { Foo } })\n\tconst identifiers = new Set(variable.identifiers);\n\tfor (const scope of variable.scope.childScopes) {\n\t\tfor (const innerVar of scope.variables) {\n\t\t\tif (innerVar.identifiers.some(id => identifiers.has(id))) {\n\t\t\t\tset = set.concat(innerVar.references);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn set;\n};\n\n/**\n * @param {Program | Program[]} ast ast\n * @param {AnyNode} node node\n * @returns {undefined | AnyNode[]} result\n */\nconst getPathInAst = (ast, node) => {\n\tif (ast === node) {\n\t\treturn [];\n\t}\n\n\tconst nr = node.range;\n\n\tconst enterNode = n => {\n\t\tif (!n) return;\n\t\tconst r = n.range;\n\t\tif (r && r[0] <= nr[0] && r[1] >= nr[1]) {\n\t\t\tconst path = getPathInAst(n, node);\n\t\t\tif (path) {\n\t\t\t\tpath.push(n);\n\t\t\t\treturn path;\n\t\t\t}\n\t\t}\n\t};\n\n\tif (Array.isArray(ast)) {\n\t\tfor (let i = 0; i < ast.length; i++) {\n\t\t\tconst enterResult = enterNode(ast[i]);\n\t\t\tif (enterResult !== undefined) return enterResult;\n\t\t}\n\t} else if (ast && typeof ast === \"object\") {\n\t\tconst keys = Object.keys(ast);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst value = ast[keys[i]];\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tconst pathResult = getPathInAst(value, node);\n\t\t\t\tif (pathResult !== undefined) return pathResult;\n\t\t\t} else if (value && typeof value === \"object\") {\n\t\t\t\tconst enterResult = enterNode(value);\n\t\t\t\tif (enterResult !== undefined) return enterResult;\n\t\t\t}\n\t\t}\n\t}\n};\n\nmodule.exports = { getAllReferences, getPathInAst };\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAMA,gBAAgB,GAAGC,QAAQ,IAAI;EACpC,IAAIC,GAAG,GAAGD,QAAQ,CAACE,UAAU;EAC7B;EACA,MAAMC,WAAW,GAAG,IAAIC,GAAG,CAACJ,QAAQ,CAACG,WAAW,CAAC;EACjD,KAAK,MAAME,KAAK,IAAIL,QAAQ,CAACK,KAAK,CAACC,WAAW,EAAE;IAC/C,KAAK,MAAMC,QAAQ,IAAIF,KAAK,CAACG,SAAS,EAAE;MACvC,IAAID,QAAQ,CAACJ,WAAW,CAACM,IAAI,CAACC,EAAE,IAAIP,WAAW,CAACQ,GAAG,CAACD,EAAE,CAAC,CAAC,EAAE;QACzDT,GAAG,GAAGA,GAAG,CAACW,MAAM,CAACL,QAAQ,CAACL,UAAU,CAAC;QACrC;MACD;IACD;EACD;EACA,OAAOD,GAAG;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMY,YAAY,GAAGA,CAACC,GAAG,EAAEC,IAAI,KAAK;EACnC,IAAID,GAAG,KAAKC,IAAI,EAAE;IACjB,OAAO,EAAE;EACV;EAEA,MAAMC,EAAE,GAAGD,IAAI,CAACE,KAAK;EAErB,MAAMC,SAAS,GAAGC,CAAC,IAAI;IACtB,IAAI,CAACA,CAAC,EAAE;IACR,MAAMC,CAAC,GAAGD,CAAC,CAACF,KAAK;IACjB,IAAIG,CAAC,IAAIA,CAAC,CAAC,CAAC,CAAC,IAAIJ,EAAE,CAAC,CAAC,CAAC,IAAII,CAAC,CAAC,CAAC,CAAC,IAAIJ,EAAE,CAAC,CAAC,CAAC,EAAE;MACxC,MAAMK,IAAI,GAAGR,YAAY,CAACM,CAAC,EAAEJ,IAAI,CAAC;MAClC,IAAIM,IAAI,EAAE;QACTA,IAAI,CAACC,IAAI,CAACH,CAAC,CAAC;QACZ,OAAOE,IAAI;MACZ;IACD;EACD,CAAC;EAED,IAAIE,KAAK,CAACC,OAAO,CAACV,GAAG,CAAC,EAAE;IACvB,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,GAAG,CAACY,MAAM,EAAED,CAAC,EAAE,EAAE;MACpC,MAAME,WAAW,GAAGT,SAAS,CAACJ,GAAG,CAACW,CAAC,CAAC,CAAC;MACrC,IAAIE,WAAW,KAAKC,SAAS,EAAE,OAAOD,WAAW;IAClD;EACD,CAAC,MAAM,IAAIb,GAAG,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;IAC1C,MAAMe,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACf,GAAG,CAAC;IAC7B,KAAK,IAAIW,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,IAAI,CAACH,MAAM,EAAED,CAAC,EAAE,EAAE;MACrC,MAAMM,KAAK,GAAGjB,GAAG,CAACe,IAAI,CAACJ,CAAC,CAAC,CAAC;MAC1B,IAAIF,KAAK,CAACC,OAAO,CAACO,KAAK,CAAC,EAAE;QACzB,MAAMC,UAAU,GAAGnB,YAAY,CAACkB,KAAK,EAAEhB,IAAI,CAAC;QAC5C,IAAIiB,UAAU,KAAKJ,SAAS,EAAE,OAAOI,UAAU;MAChD,CAAC,MAAM,IAAID,KAAK,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;QAC9C,MAAMJ,WAAW,GAAGT,SAAS,CAACa,KAAK,CAAC;QACpC,IAAIJ,WAAW,KAAKC,SAAS,EAAE,OAAOD,WAAW;MAClD;IACD;EACD;AACD,CAAC;AAEDM,MAAM,CAACC,OAAO,GAAG;EAAEnC,gBAAgB;EAAEc;AAAa,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}