{"ast":null,"code":"import require$$0 from \"stream\";\nimport require$$0$2 from \"zlib\";\nimport require$$0$1 from \"fs\";\nimport require$$1$1 from \"path\";\nimport require$$2 from \"os\";\nimport require$$0$3 from \"buffer\";\nimport require$$3 from \"net\";\nimport require$$4 from \"tls\";\nimport require$$5 from \"crypto\";\nimport require$$0$4 from \"events\";\nimport require$$1$2 from \"https\";\nimport require$$2$1 from \"http\";\nimport require$$7 from \"url\";\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nfunction getAugmentedNamespace(n) {\n  if (n.__esModule) return n;\n  var f = n.default;\n  if (typeof f == \"function\") {\n    var a = function a2() {\n      if (this instanceof a2) {\n        return Reflect.construct(f, arguments, this.constructor);\n      }\n      return f.apply(this, arguments);\n    };\n    a.prototype = f.prototype;\n  } else a = {};\n  Object.defineProperty(a, \"__esModule\", {\n    value: true\n  });\n  Object.keys(n).forEach(function (k) {\n    var d = Object.getOwnPropertyDescriptor(n, k);\n    Object.defineProperty(a, k, d.get ? d : {\n      enumerable: true,\n      get: function () {\n        return n[k];\n      }\n    });\n  });\n  return a;\n}\nconst {\n  Duplex\n} = require$$0;\nfunction emitClose$1(stream2) {\n  stream2.emit(\"close\");\n}\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\nfunction duplexOnError(err) {\n  this.removeListener(\"error\", duplexOnError);\n  this.destroy();\n  if (this.listenerCount(\"error\") === 0) {\n    this.emit(\"error\", err);\n  }\n}\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n  ws.on(\"message\", function message(msg, isBinary) {\n    const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n    if (!duplex.push(data)) ws.pause();\n  });\n  ws.once(\"error\", function error2(err) {\n    if (duplex.destroyed) return;\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n  ws.once(\"close\", function close() {\n    if (duplex.destroyed) return;\n    duplex.push(null);\n  });\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose$1, duplex);\n      return;\n    }\n    let called = false;\n    ws.once(\"error\", function error2(err2) {\n      called = true;\n      callback(err2);\n    });\n    ws.once(\"close\", function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose$1, duplex);\n    });\n    if (terminateOnDestroy) ws.terminate();\n  };\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once(\"open\", function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n    if (ws._socket === null) return;\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once(\"finish\", function finish() {\n        callback();\n      });\n      ws.close();\n    }\n  };\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once(\"open\", function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n    ws.send(chunk, callback);\n  };\n  duplex.on(\"end\", duplexOnEnd);\n  duplex.on(\"error\", duplexOnError);\n  return duplex;\n}\nvar stream = createWebSocketStream;\nconst stream$1 = /* @__PURE__ */getDefaultExportFromCjs(stream);\nvar bufferUtil$1 = {\n  exports: {}\n};\nvar constants = {\n  BINARY_TYPES: [\"nodebuffer\", \"arraybuffer\", \"fragments\"],\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\",\n  kForOnEventAttribute: Symbol(\"kIsForOnEventAttribute\"),\n  kListener: Symbol(\"kListener\"),\n  kStatusCode: Symbol(\"status-code\"),\n  kWebSocket: Symbol(\"websocket\"),\n  NOOP: () => {}\n};\nvar bufferutil = {\n  exports: {}\n};\nvar nodeGypBuild$1 = {\n  exports: {}\n};\nfunction commonjsRequire(path) {\n  throw new Error('Could not dynamically require \"' + path + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n}\nvar nodeGypBuild;\nvar hasRequiredNodeGypBuild$1;\nfunction requireNodeGypBuild$1() {\n  if (hasRequiredNodeGypBuild$1) return nodeGypBuild;\n  hasRequiredNodeGypBuild$1 = 1;\n  var fs = require$$0$1;\n  var path = require$$1$1;\n  var os = require$$2;\n  var runtimeRequire = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : commonjsRequire;\n  var vars = process.config && process.config.variables || {};\n  var prebuildsOnly = !!process.env.PREBUILDS_ONLY;\n  var abi = process.versions.modules;\n  var runtime = isElectron() ? \"electron\" : isNwjs() ? \"node-webkit\" : \"node\";\n  var arch = process.env.npm_config_arch || os.arch();\n  var platform = process.env.npm_config_platform || os.platform();\n  var libc = process.env.LIBC || (isAlpine(platform) ? \"musl\" : \"glibc\");\n  var armv = process.env.ARM_VERSION || (arch === \"arm64\" ? \"8\" : vars.arm_version) || \"\";\n  var uv = (process.versions.uv || \"\").split(\".\")[0];\n  nodeGypBuild = load;\n  function load(dir) {\n    return runtimeRequire(load.resolve(dir));\n  }\n  load.resolve = load.path = function (dir) {\n    dir = path.resolve(dir || \".\");\n    try {\n      var name = runtimeRequire(path.join(dir, \"package.json\")).name.toUpperCase().replace(/-/g, \"_\");\n      if (process.env[name + \"_PREBUILD\"]) dir = process.env[name + \"_PREBUILD\"];\n    } catch (err) {}\n    if (!prebuildsOnly) {\n      var release = getFirst(path.join(dir, \"build/Release\"), matchBuild);\n      if (release) return release;\n      var debug = getFirst(path.join(dir, \"build/Debug\"), matchBuild);\n      if (debug) return debug;\n    }\n    var prebuild = resolve(dir);\n    if (prebuild) return prebuild;\n    var nearby = resolve(path.dirname(process.execPath));\n    if (nearby) return nearby;\n    var target = [\"platform=\" + platform, \"arch=\" + arch, \"runtime=\" + runtime, \"abi=\" + abi, \"uv=\" + uv, armv ? \"armv=\" + armv : \"\", \"libc=\" + libc, \"node=\" + process.versions.node, process.versions.electron ? \"electron=\" + process.versions.electron : \"\", typeof __webpack_require__ === \"function\" ? \"webpack=true\" : \"\"\n    // eslint-disable-line\n    ].filter(Boolean).join(\" \");\n    throw new Error(\"No native build was found for \" + target + \"\\n    loaded from: \" + dir + \"\\n\");\n    function resolve(dir2) {\n      var tuples = readdirSync(path.join(dir2, \"prebuilds\")).map(parseTuple);\n      var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];\n      if (!tuple) return;\n      var prebuilds = path.join(dir2, \"prebuilds\", tuple.name);\n      var parsed = readdirSync(prebuilds).map(parseTags);\n      var candidates = parsed.filter(matchTags(runtime, abi));\n      var winner = candidates.sort(compareTags(runtime))[0];\n      if (winner) return path.join(prebuilds, winner.file);\n    }\n  };\n  function readdirSync(dir) {\n    try {\n      return fs.readdirSync(dir);\n    } catch (err) {\n      return [];\n    }\n  }\n  function getFirst(dir, filter) {\n    var files = readdirSync(dir).filter(filter);\n    return files[0] && path.join(dir, files[0]);\n  }\n  function matchBuild(name) {\n    return /\\.node$/.test(name);\n  }\n  function parseTuple(name) {\n    var arr = name.split(\"-\");\n    if (arr.length !== 2) return;\n    var platform2 = arr[0];\n    var architectures = arr[1].split(\"+\");\n    if (!platform2) return;\n    if (!architectures.length) return;\n    if (!architectures.every(Boolean)) return;\n    return {\n      name,\n      platform: platform2,\n      architectures\n    };\n  }\n  function matchTuple(platform2, arch2) {\n    return function (tuple) {\n      if (tuple == null) return false;\n      if (tuple.platform !== platform2) return false;\n      return tuple.architectures.includes(arch2);\n    };\n  }\n  function compareTuples(a, b) {\n    return a.architectures.length - b.architectures.length;\n  }\n  function parseTags(file) {\n    var arr = file.split(\".\");\n    var extension2 = arr.pop();\n    var tags = {\n      file,\n      specificity: 0\n    };\n    if (extension2 !== \"node\") return;\n    for (var i = 0; i < arr.length; i++) {\n      var tag = arr[i];\n      if (tag === \"node\" || tag === \"electron\" || tag === \"node-webkit\") {\n        tags.runtime = tag;\n      } else if (tag === \"napi\") {\n        tags.napi = true;\n      } else if (tag.slice(0, 3) === \"abi\") {\n        tags.abi = tag.slice(3);\n      } else if (tag.slice(0, 2) === \"uv\") {\n        tags.uv = tag.slice(2);\n      } else if (tag.slice(0, 4) === \"armv\") {\n        tags.armv = tag.slice(4);\n      } else if (tag === \"glibc\" || tag === \"musl\") {\n        tags.libc = tag;\n      } else {\n        continue;\n      }\n      tags.specificity++;\n    }\n    return tags;\n  }\n  function matchTags(runtime2, abi2) {\n    return function (tags) {\n      if (tags == null) return false;\n      if (tags.runtime !== runtime2 && !runtimeAgnostic(tags)) return false;\n      if (tags.abi !== abi2 && !tags.napi) return false;\n      if (tags.uv && tags.uv !== uv) return false;\n      if (tags.armv && tags.armv !== armv) return false;\n      if (tags.libc && tags.libc !== libc) return false;\n      return true;\n    };\n  }\n  function runtimeAgnostic(tags) {\n    return tags.runtime === \"node\" && tags.napi;\n  }\n  function compareTags(runtime2) {\n    return function (a, b) {\n      if (a.runtime !== b.runtime) {\n        return a.runtime === runtime2 ? -1 : 1;\n      } else if (a.abi !== b.abi) {\n        return a.abi ? -1 : 1;\n      } else if (a.specificity !== b.specificity) {\n        return a.specificity > b.specificity ? -1 : 1;\n      } else {\n        return 0;\n      }\n    };\n  }\n  function isNwjs() {\n    return !!(process.versions && process.versions.nw);\n  }\n  function isElectron() {\n    if (process.versions && process.versions.electron) return true;\n    if (process.env.ELECTRON_RUN_AS_NODE) return true;\n    return typeof window !== \"undefined\" && window.process && window.process.type === \"renderer\";\n  }\n  function isAlpine(platform2) {\n    return platform2 === \"linux\" && fs.existsSync(\"/etc/alpine-release\");\n  }\n  load.parseTags = parseTags;\n  load.matchTags = matchTags;\n  load.compareTags = compareTags;\n  load.parseTuple = parseTuple;\n  load.matchTuple = matchTuple;\n  load.compareTuples = compareTuples;\n  return nodeGypBuild;\n}\nvar hasRequiredNodeGypBuild;\nfunction requireNodeGypBuild() {\n  if (hasRequiredNodeGypBuild) return nodeGypBuild$1.exports;\n  hasRequiredNodeGypBuild = 1;\n  if (typeof process.addon === \"function\") {\n    nodeGypBuild$1.exports = process.addon.bind(process);\n  } else {\n    nodeGypBuild$1.exports = requireNodeGypBuild$1();\n  }\n  return nodeGypBuild$1.exports;\n}\nvar fallback;\nvar hasRequiredFallback;\nfunction requireFallback() {\n  if (hasRequiredFallback) return fallback;\n  hasRequiredFallback = 1;\n  const mask2 = (source, mask3, output, offset, length) => {\n    for (var i = 0; i < length; i++) {\n      output[offset + i] = source[i] ^ mask3[i & 3];\n    }\n  };\n  const unmask2 = (buffer, mask3) => {\n    const length = buffer.length;\n    for (var i = 0; i < length; i++) {\n      buffer[i] ^= mask3[i & 3];\n    }\n  };\n  fallback = {\n    mask: mask2,\n    unmask: unmask2\n  };\n  return fallback;\n}\nvar hasRequiredBufferutil;\nfunction requireBufferutil() {\n  if (hasRequiredBufferutil) return bufferutil.exports;\n  hasRequiredBufferutil = 1;\n  try {\n    bufferutil.exports = requireNodeGypBuild()(__dirname);\n  } catch (e) {\n    bufferutil.exports = requireFallback();\n  }\n  return bufferutil.exports;\n}\nvar unmask$1;\nvar mask;\nconst {\n  EMPTY_BUFFER: EMPTY_BUFFER$3\n} = constants;\nconst FastBuffer$2 = Buffer[Symbol.species];\nfunction concat$1(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER$3;\n  if (list.length === 1) return list[0];\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n  if (offset < totalLength) {\n    return new FastBuffer$2(target.buffer, target.byteOffset, offset);\n  }\n  return target;\n}\nfunction _mask(source, mask2, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask2[i & 3];\n  }\n}\nfunction _unmask(buffer, mask2) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask2[i & 3];\n  }\n}\nfunction toArrayBuffer$1(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\nfunction toBuffer$2(data) {\n  toBuffer$2.readOnly = true;\n  if (Buffer.isBuffer(data)) return data;\n  let buf;\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer$2(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer$2(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer$2.readOnly = false;\n  }\n  return buf;\n}\nbufferUtil$1.exports = {\n  concat: concat$1,\n  mask: _mask,\n  toArrayBuffer: toArrayBuffer$1,\n  toBuffer: toBuffer$2,\n  unmask: _unmask\n};\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil2 = requireBufferutil();\n    mask = bufferUtil$1.exports.mask = function (source, mask2, output, offset, length) {\n      if (length < 48) _mask(source, mask2, output, offset, length);else bufferUtil2.mask(source, mask2, output, offset, length);\n    };\n    unmask$1 = bufferUtil$1.exports.unmask = function (buffer, mask2) {\n      if (buffer.length < 32) _unmask(buffer, mask2);else bufferUtil2.unmask(buffer, mask2);\n    };\n  } catch (e) {}\n}\nvar bufferUtilExports = bufferUtil$1.exports;\nconst kDone = Symbol(\"kDone\");\nconst kRun = Symbol(\"kRun\");\nlet Limiter$1 = class Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n};\nvar limiter = Limiter$1;\nconst zlib = require$$0$2;\nconst bufferUtil = bufferUtilExports;\nconst Limiter2 = limiter;\nconst {\n  kStatusCode: kStatusCode$2\n} = constants;\nconst FastBuffer$1 = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0, 0, 255, 255]);\nconst kPerMessageDeflate = Symbol(\"permessage-deflate\");\nconst kTotalLength = Symbol(\"total-length\");\nconst kCallback = Symbol(\"callback\");\nconst kBuffers = Symbol(\"buffers\");\nconst kError$1 = Symbol(\"error\");\nlet zlibLimiter;\nlet PerMessageDeflate$4 = class PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n    this.params = null;\n    if (!zlibLimiter) {\n      const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;\n      zlibLimiter = new Limiter2(concurrency);\n    }\n  }\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return \"permessage-deflate\";\n  }\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n    return params;\n  }\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n    return this.params;\n  }\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n      this._deflate.close();\n      this._deflate = null;\n      if (callback) {\n        callback(new Error(\"The deflate stream was closed while data was being processed\"));\n      }\n    }\n  }\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find(params => {\n      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === \"number\" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === \"number\" && !params.client_max_window_bits) {\n        return false;\n      }\n      return true;\n    });\n    if (!accepted) {\n      throw new Error(\"None of the extension offers can be accepted\");\n    }\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === \"number\") {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === \"number\") {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n      delete accepted.client_max_window_bits;\n    }\n    return accepted;\n  }\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === \"number\") {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === \"number\" && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n      throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n    }\n    return params;\n  }\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach(params => {\n      Object.keys(params).forEach(key => {\n        let value = params[key];\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n        value = value[0];\n        if (key === \"client_max_window_bits\") {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n        } else if (key === \"server_max_window_bits\") {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n          value = num;\n        } else if (key === \"client_no_context_takeover\" || key === \"server_no_context_takeover\") {\n          if (value !== true) {\n            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n        params[key] = value;\n      });\n    });\n    return configurations;\n  }\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add(done => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add(done => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? \"client\" : \"server\";\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on(\"error\", inflateOnError);\n      this._inflate.on(\"data\", inflateOnData);\n    }\n    this._inflate[kCallback] = callback;\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n    this._inflate.flush(() => {\n      const err = this._inflate[kError$1];\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n      const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n      callback(null, data2);\n    });\n  }\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? \"server\" : \"client\";\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      this._deflate.on(\"data\", deflateOnData);\n    }\n    this._deflate[kCallback] = callback;\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        return;\n      }\n      let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n      if (fin) {\n        data2 = new FastBuffer$1(data2.buffer, data2.byteOffset, data2.length - 4);\n      }\n      this._deflate[kCallback] = null;\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n      callback(null, data2);\n    });\n  }\n};\nvar permessageDeflate = PerMessageDeflate$4;\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n  this[kError$1] = new RangeError(\"Max payload size exceeded\");\n  this[kError$1].code = \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\";\n  this[kError$1][kStatusCode$2] = 1009;\n  this.removeListener(\"data\", inflateOnData);\n  this.reset();\n}\nfunction inflateOnError(err) {\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode$2] = 1007;\n  this[kCallback](err);\n}\nvar validation = {\n  exports: {}\n};\nconst __viteOptionalPeerDep_utf8Validate_ws = {};\nconst __viteOptionalPeerDep_utf8Validate_ws$1 = /* @__PURE__ */Object.freeze(/* @__PURE__ */Object.defineProperty({\n  __proto__: null,\n  default: __viteOptionalPeerDep_utf8Validate_ws\n}, Symbol.toStringTag, {\n  value: \"Module\"\n}));\nconst require$$1 = /* @__PURE__ */getAugmentedNamespace(__viteOptionalPeerDep_utf8Validate_ws$1);\nvar isValidUTF8_1;\nconst {\n  isUtf8\n} = require$$0$3;\nconst tokenChars$2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n// 0 - 15\n0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n// 16 - 31\n0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0,\n// 32 - 47\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\n// 48 - 63\n0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n// 64 - 79\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1,\n// 80 - 95\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n// 96 - 111\n1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0\n// 112 - 127\n];\nfunction isValidStatusCode$2(code) {\n  return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;\n}\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n  while (i < len) {\n    if ((buf[i] & 128) === 0) {\n      i++;\n    } else if ((buf[i] & 224) === 192) {\n      if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {\n        return false;\n      }\n      i += 2;\n    } else if ((buf[i] & 240) === 224) {\n      if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 ||\n      // Overlong\n      buf[i] === 237 && (buf[i + 1] & 224) === 160) {\n        return false;\n      }\n      i += 3;\n    } else if ((buf[i] & 248) === 240) {\n      if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 ||\n      // Overlong\n      buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {\n        return false;\n      }\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nvalidation.exports = {\n  isValidStatusCode: isValidStatusCode$2,\n  isValidUTF8: _isValidUTF8,\n  tokenChars: tokenChars$2\n};\nif (isUtf8) {\n  isValidUTF8_1 = validation.exports.isValidUTF8 = function (buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF82 = require$$1;\n    isValidUTF8_1 = validation.exports.isValidUTF8 = function (buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF82(buf);\n    };\n  } catch (e) {}\n}\nvar validationExports = validation.exports;\nconst {\n  Writable\n} = require$$0;\nconst PerMessageDeflate$3 = permessageDeflate;\nconst {\n  BINARY_TYPES: BINARY_TYPES$1,\n  EMPTY_BUFFER: EMPTY_BUFFER$2,\n  kStatusCode: kStatusCode$1,\n  kWebSocket: kWebSocket$2\n} = constants;\nconst {\n  concat,\n  toArrayBuffer,\n  unmask\n} = bufferUtilExports;\nconst {\n  isValidStatusCode: isValidStatusCode$1,\n  isValidUTF8\n} = validationExports;\nconst FastBuffer = Buffer[Symbol.species];\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nlet Receiver$1 = class Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n    this._binaryType = options.binaryType || BINARY_TYPES$1[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket$2] = void 0;\n    this._bufferedBytes = 0;\n    this._buffers = [];\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = void 0;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 8 && this._state == GET_INFO) return cb();\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n    if (n === this._buffers[0].length) return this._buffers.shift();\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n    const dst = Buffer.allocUnsafe(n);\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n      }\n      n -= buf.length;\n    } while (n > 0);\n    return dst;\n  }\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n    cb(err);\n  }\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(2);\n    if ((buf[0] & 48) !== 0) {\n      this._loop = false;\n      return error(RangeError, \"RSV2 and RSV3 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_2_3\");\n    }\n    const compressed = (buf[0] & 64) === 64;\n    if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {\n      this._loop = false;\n      return error(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n    }\n    this._fin = (buf[0] & 128) === 128;\n    this._opcode = buf[0] & 15;\n    this._payloadLength = buf[1] & 127;\n    if (this._opcode === 0) {\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n      }\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(RangeError, \"invalid opcode 0\", true, 1002, \"WS_ERR_INVALID_OPCODE\");\n      }\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 1 || this._opcode === 2) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n      }\n      this._compressed = compressed;\n    } else if (this._opcode > 7 && this._opcode < 11) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(RangeError, \"FIN must be set\", true, 1002, \"WS_ERR_EXPECTED_FIN\");\n      }\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n      }\n      if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {\n        this._loop = false;\n        return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\");\n      }\n    } else {\n      this._loop = false;\n      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n    }\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 128) === 128;\n    if (this._isServer) {\n      if (!this._masked) {\n        this._loop = false;\n        return error(RangeError, \"MASK must be set\", true, 1002, \"WS_ERR_EXPECTED_MASK\");\n      }\n    } else if (this._masked) {\n      this._loop = false;\n      return error(RangeError, \"MASK must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_MASK\");\n    }\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else return this.haveLength();\n  }\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(RangeError, \"Unsupported WebSocket frame: payload length > 2^53 - 1\", false, 1009, \"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH\");\n    }\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 8) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\");\n      }\n    }\n    if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;\n  }\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER$2;\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n      data = this.consume(this._payloadLength);\n      if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n        unmask(data, this._mask);\n      }\n    }\n    if (this._opcode > 7) return this.controlMessage(data);\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n    if (data.length) {\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n    return this.dataMessage();\n  }\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(error(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"));\n        }\n        this._fragments.push(buf);\n      }\n      const er = this.dataMessage();\n      if (er) return cb(er);\n      this.startLoop(cb);\n    });\n  }\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n      if (this._opcode === 2) {\n        let data;\n        if (this._binaryType === \"nodebuffer\") {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === \"arraybuffer\") {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n        this.emit(\"message\", data, true);\n      } else {\n        const buf = concat(fragments, messageLength);\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          this._loop = false;\n          return error(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n        }\n        this.emit(\"message\", buf, false);\n      }\n    }\n    this._state = GET_INFO;\n  }\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 8) {\n      this._loop = false;\n      if (data.length === 0) {\n        this.emit(\"conclude\", 1005, EMPTY_BUFFER$2);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n        if (!isValidStatusCode$1(code)) {\n          return error(RangeError, `invalid status code ${code}`, true, 1002, \"WS_ERR_INVALID_CLOSE_CODE\");\n        }\n        const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          return error(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n        }\n        this.emit(\"conclude\", code, buf);\n        this.end();\n      }\n    } else if (this._opcode === 9) {\n      this.emit(\"ping\", data);\n    } else {\n      this.emit(\"pong\", data);\n    }\n    this._state = GET_INFO;\n  }\n};\nvar receiver = Receiver$1;\nfunction error(ErrorCtor, message, prefix, statusCode, errorCode) {\n  const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);\n  Error.captureStackTrace(err, error);\n  err.code = errorCode;\n  err[kStatusCode$1] = statusCode;\n  return err;\n}\nconst receiver$1 = /* @__PURE__ */getDefaultExportFromCjs(receiver);\nconst {\n  randomFillSync\n} = require$$5;\nconst PerMessageDeflate$2 = permessageDeflate;\nconst {\n  EMPTY_BUFFER: EMPTY_BUFFER$1\n} = constants;\nconst {\n  isValidStatusCode\n} = validationExports;\nconst {\n  mask: applyMask,\n  toBuffer: toBuffer$1\n} = bufferUtilExports;\nconst kByteLength = Symbol(\"kByteLength\");\nconst maskBuffer = Buffer.alloc(4);\nlet Sender$1 = class Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n    this._socket = socket;\n    this._firstFragment = true;\n    this._compress = false;\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask2;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n    if (options.mask) {\n      mask2 = options.maskBuffer || maskBuffer;\n      if (options.generateMask) {\n        options.generateMask(mask2);\n      } else {\n        randomFillSync(mask2, 0, 4);\n      }\n      skipMasking = (mask2[0] | mask2[1] | mask2[2] | mask2[3]) === 0;\n      offset = 6;\n    }\n    let dataLength;\n    if (typeof data === \"string\") {\n      if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n    let payloadLength = dataLength;\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n    target[0] = options.fin ? options.opcode | 128 : options.opcode;\n    if (options.rsv1) target[0] |= 64;\n    target[1] = payloadLength;\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n    if (!options.mask) return [target, data];\n    target[1] |= 128;\n    target[offset - 4] = mask2[0];\n    target[offset - 3] = mask2[1];\n    target[offset - 2] = mask2[2];\n    target[offset - 1] = mask2[3];\n    if (skipMasking) return [target, data];\n    if (merge) {\n      applyMask(data, mask2, target, offset, dataLength);\n      return [target];\n    }\n    applyMask(data, mask2, data, 0, dataLength);\n    return [target, data];\n  }\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask2, cb) {\n    let buf;\n    if (code === void 0) {\n      buf = EMPTY_BUFFER$1;\n    } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n      throw new TypeError(\"First argument must be a valid error code number\");\n    } else if (data === void 0 || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n      if (length > 123) {\n        throw new RangeError(\"The message must not be greater than 123 bytes\");\n      }\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n      if (typeof data === \"string\") {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask: mask2,\n      maskBuffer: this._maskBuffer,\n      opcode: 8,\n      readOnly: false,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask2, cb) {\n    let byteLength;\n    let readOnly;\n    if (typeof data === \"string\") {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer$1(data);\n      byteLength = data.length;\n      readOnly = toBuffer$1.readOnly;\n    }\n    if (byteLength > 125) {\n      throw new RangeError(\"The data size must not be greater than 125 bytes\");\n    }\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask: mask2,\n      maskBuffer: this._maskBuffer,\n      opcode: 9,\n      readOnly,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask2, cb) {\n    let byteLength;\n    let readOnly;\n    if (typeof data === \"string\") {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer$1(data);\n      byteLength = data.length;\n      readOnly = toBuffer$1.readOnly;\n    }\n    if (byteLength > 125) {\n      throw new RangeError(\"The data size must not be greater than 125 bytes\");\n    }\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask: mask2,\n      maskBuffer: this._maskBuffer,\n      opcode: 10,\n      readOnly,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n    let byteLength;\n    let readOnly;\n    if (typeof data === \"string\") {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer$1(data);\n      byteLength = data.length;\n      readOnly = toBuffer$1.readOnly;\n    }\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n    if (options.fin) this._firstFragment = true;\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(Sender.frame(data, {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1: false\n      }), cb);\n    }\n  }\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\"The socket was closed while data was being compressed\");\n        if (typeof cb === \"function\") cb(err);\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n          if (typeof callback === \"function\") callback(err);\n        }\n        return;\n      }\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n};\nvar sender = Sender$1;\nconst sender$1 = /* @__PURE__ */getDefaultExportFromCjs(sender);\nconst {\n  kForOnEventAttribute: kForOnEventAttribute$1,\n  kListener: kListener$1\n} = constants;\nconst kCode = Symbol(\"kCode\");\nconst kData = Symbol(\"kData\");\nconst kError = Symbol(\"kError\");\nconst kMessage = Symbol(\"kMessage\");\nconst kReason = Symbol(\"kReason\");\nconst kTarget = Symbol(\"kTarget\");\nconst kType = Symbol(\"kType\");\nconst kWasClean = Symbol(\"kWasClean\");\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\nObject.defineProperty(Event.prototype, \"target\", {\n  enumerable: true\n});\nObject.defineProperty(Event.prototype, \"type\", {\n  enumerable: true\n});\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kCode] = options.code === void 0 ? 0 : options.code;\n    this[kReason] = options.reason === void 0 ? \"\" : options.reason;\n    this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;\n  }\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\nObject.defineProperty(CloseEvent.prototype, \"code\", {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, \"reason\", {\n  enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, \"wasClean\", {\n  enumerable: true\n});\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kError] = options.error === void 0 ? null : options.error;\n    this[kMessage] = options.message === void 0 ? \"\" : options.message;\n  }\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\nObject.defineProperty(ErrorEvent.prototype, \"error\", {\n  enumerable: true\n});\nObject.defineProperty(ErrorEvent.prototype, \"message\", {\n  enumerable: true\n});\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kData] = options.data === void 0 ? null : options.data;\n  }\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\nObject.defineProperty(MessageEvent.prototype, \"data\", {\n  enumerable: true\n});\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (!options[kForOnEventAttribute$1] && listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {\n        return;\n      }\n    }\n    let wrapper;\n    if (type === \"message\") {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent(\"message\", {\n          data: isBinary ? data : data.toString()\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === \"close\") {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent(\"close\", {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === \"error\") {\n      wrapper = function onError(error2) {\n        const event = new ErrorEvent(\"error\", {\n          error: error2,\n          message: error2.message\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === \"open\") {\n      wrapper = function onOpen() {\n        const event = new Event(\"open\");\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n    wrapper[kForOnEventAttribute$1] = !!options[kForOnEventAttribute$1];\n    wrapper[kListener$1] = handler;\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\nvar eventTarget = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === \"object\" && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}\nconst {\n  tokenChars: tokenChars$1\n} = validationExports;\nfunction push(dest, name, elem) {\n  if (dest[name] === void 0) dest[name] = [elem];else dest[name].push(elem);\n}\nfunction parse$2(header) {\n  const offers = /* @__PURE__ */Object.create(null);\n  let params = /* @__PURE__ */Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n    if (extensionName === void 0) {\n      if (end === -1 && tokenChars$1[code] === 1) {\n        if (start === -1) start = i;\n      } else if (i !== 0 && (code === 32 || code === 9)) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 59 || code === 44) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 44) {\n          push(offers, name, params);\n          params = /* @__PURE__ */Object.create(null);\n        } else {\n          extensionName = name;\n        }\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === void 0) {\n      if (end === -1 && tokenChars$1[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 32 || code === 9) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 59 || code === 44) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 44) {\n          push(offers, extensionName, params);\n          params = /* @__PURE__ */Object.create(null);\n          extensionName = void 0;\n        }\n        start = end = -1;\n      } else if (code === 61 && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      if (isEscaping) {\n        if (tokenChars$1[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars$1[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 34 && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 92) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 34 && header.charCodeAt(i - 1) === 61) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars$1[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 32 || code === 9)) {\n        if (end === -1) end = i;\n      } else if (code === 59 || code === 44) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, \"\");\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 44) {\n          push(offers, extensionName, params);\n          params = /* @__PURE__ */Object.create(null);\n          extensionName = void 0;\n        }\n        paramName = void 0;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n  if (start === -1 || inQuotes || code === 32 || code === 9) {\n    throw new SyntaxError(\"Unexpected end of input\");\n  }\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === void 0) {\n    push(offers, token, params);\n  } else {\n    if (paramName === void 0) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, \"\"));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n  return offers;\n}\nfunction format$1(extensions) {\n  return Object.keys(extensions).map(extension2 => {\n    let configurations = extensions[extension2];\n    if (!Array.isArray(configurations)) configurations = [configurations];\n    return configurations.map(params => {\n      return [extension2].concat(Object.keys(params).map(k => {\n        let values = params[k];\n        if (!Array.isArray(values)) values = [values];\n        return values.map(v => v === true ? k : `${k}=${v}`).join(\"; \");\n      })).join(\"; \");\n    }).join(\", \");\n  }).join(\", \");\n}\nvar extension$1 = {\n  format: format$1,\n  parse: parse$2\n};\nconst EventEmitter$1 = require$$0$4;\nconst https = require$$1$2;\nconst http$1 = require$$2$1;\nconst net = require$$3;\nconst tls = require$$4;\nconst {\n  randomBytes,\n  createHash: createHash$1\n} = require$$5;\nconst {\n  URL\n} = require$$7;\nconst PerMessageDeflate$1 = permessageDeflate;\nconst Receiver2 = receiver;\nconst Sender2 = sender;\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID: GUID$1,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket: kWebSocket$1,\n  NOOP\n} = constants;\nconst {\n  EventTarget: {\n    addEventListener,\n    removeEventListener\n  }\n} = eventTarget;\nconst {\n  format,\n  parse: parse$1\n} = extension$1;\nconst {\n  toBuffer\n} = bufferUtilExports;\nconst closeTimeout = 30 * 1e3;\nconst kAborted = Symbol(\"kAborted\");\nconst protocolVersions = [8, 13];\nconst readyStates = [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\nlet WebSocket$1 = class WebSocket extends EventEmitter$1 {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = \"\";\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n      if (protocols === void 0) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === \"object\" && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n    this._binaryType = type;\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver2 = new Receiver2({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n    this._sender = new Sender2(socket, this._extensions, options.generateMask);\n    this._receiver = receiver2;\n    this._socket = socket;\n    receiver2[kWebSocket$1] = this;\n    socket[kWebSocket$1] = this;\n    receiver2.on(\"conclude\", receiverOnConclude);\n    receiver2.on(\"drain\", receiverOnDrain);\n    receiver2.on(\"error\", receiverOnError);\n    receiver2.on(\"message\", receiverOnMessage);\n    receiver2.on(\"ping\", receiverOnPing);\n    receiver2.on(\"pong\", receiverOnPong);\n    socket.setTimeout(0);\n    socket.setNoDelay();\n    if (head.length > 0) socket.unshift(head);\n    socket.on(\"close\", socketOnClose);\n    socket.on(\"data\", socketOnData);\n    socket.on(\"end\", socketOnEnd);\n    socket.on(\"error\", socketOnError$1);\n    this._readyState = WebSocket.OPEN;\n    this.emit(\"open\");\n  }\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit(\"close\", this._closeCode, this._closeMessage);\n      return;\n    }\n    if (this._extensions[PerMessageDeflate$1.extensionName]) {\n      this._extensions[PerMessageDeflate$1.extensionName].cleanup();\n    }\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit(\"close\", this._closeCode, this._closeMessage);\n  }\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = \"WebSocket was closed before the connection was established\";\n      abortHandshake$1(this, this._req, msg);\n      return;\n    }\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n        this._socket.end();\n      }\n      return;\n    }\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, err => {\n      if (err) return;\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n        this._socket.end();\n      }\n    });\n    this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);\n  }\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = true;\n    this._socket.pause();\n  }\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask2, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n    }\n    if (typeof data === \"function\") {\n      cb = data;\n      data = mask2 = void 0;\n    } else if (typeof mask2 === \"function\") {\n      cb = mask2;\n      mask2 = void 0;\n    }\n    if (typeof data === \"number\") data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask2 === void 0) mask2 = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask2, cb);\n  }\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask2, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n    }\n    if (typeof data === \"function\") {\n      cb = data;\n      data = mask2 = void 0;\n    } else if (typeof mask2 === \"function\") {\n      cb = mask2;\n      mask2 = void 0;\n    }\n    if (typeof data === \"number\") data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask2 === void 0) mask2 = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask2, cb);\n  }\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n    }\n    if (typeof options === \"function\") {\n      cb = options;\n      options = {};\n    }\n    if (typeof data === \"number\") data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    const opts = {\n      binary: typeof data !== \"string\",\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n    if (!this._extensions[PerMessageDeflate$1.extensionName]) {\n      opts.compress = false;\n    }\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = \"WebSocket was closed before the connection was established\";\n      abortHandshake$1(this, this._req, msg);\n      return;\n    }\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n};\nObject.defineProperty(WebSocket$1, \"CONNECTING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"CONNECTING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(WebSocket$1, \"OPEN\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"OPEN\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(WebSocket$1, \"CLOSING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"CLOSING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(WebSocket$1, \"CLOSED\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSED\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"CLOSED\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSED\")\n});\n[\"binaryType\", \"bufferedAmount\", \"extensions\", \"isPaused\", \"protocol\", \"readyState\", \"url\"].forEach(property => {\n  Object.defineProperty(WebSocket$1.prototype, property, {\n    enumerable: true\n  });\n});\n[\"open\", \"error\", \"close\", \"message\"].forEach(method => {\n  Object.defineProperty(WebSocket$1.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n      if (typeof handler !== \"function\") return;\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\nWebSocket$1.prototype.addEventListener = addEventListener;\nWebSocket$1.prototype.removeEventListener = removeEventListener;\nvar websocket = WebSocket$1;\nfunction initAsClient(websocket2, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: void 0,\n    socketPath: void 0,\n    hostname: void 0,\n    protocol: void 0,\n    timeout: void 0,\n    method: \"GET\",\n    host: void 0,\n    path: void 0,\n    port: void 0\n  };\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(\", \")})`);\n  }\n  let parsedUrl;\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket2._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n    websocket2._url = address;\n  }\n  const isSecure = parsedUrl.protocol === \"wss:\";\n  const isIpcUrl = parsedUrl.protocol === \"ws+unix:\";\n  let invalidUrlMessage;\n  if (parsedUrl.protocol !== \"ws:\" && !isSecure && !isIpcUrl) {\n    invalidUrlMessage = `The URL's protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"`;\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = \"The URL contains a fragment identifier\";\n  }\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n    if (websocket2._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket2, err);\n      return;\n    }\n  }\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString(\"base64\");\n  const request = isSecure ? https.request : http$1.request;\n  const protocolSet = /* @__PURE__ */new Set();\n  let perMessageDeflate;\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith(\"[\") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    \"Sec-WebSocket-Version\": opts.protocolVersion,\n    \"Sec-WebSocket-Key\": key,\n    Connection: \"Upgrade\",\n    Upgrade: \"websocket\"\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate$1(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n    opts.headers[\"Sec-WebSocket-Extensions\"] = format({\n      [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (typeof protocol !== \"string\" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n        throw new SyntaxError(\"An invalid or duplicated subprotocol was specified\");\n      }\n      protocolSet.add(protocol);\n    }\n    opts.headers[\"Sec-WebSocket-Protocol\"] = protocols.join(\",\");\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers[\"Sec-WebSocket-Origin\"] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n  if (isIpcUrl) {\n    const parts = opts.path.split(\":\");\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n  let req;\n  if (opts.followRedirects) {\n    if (websocket2._redirects === 0) {\n      websocket2._originalIpc = isIpcUrl;\n      websocket2._originalSecure = isSecure;\n      websocket2._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n      const headers = options && options.headers;\n      options = {\n        ...options,\n        headers: {}\n      };\n      if (headers) {\n        for (const [key2, value] of Object.entries(headers)) {\n          options.headers[key2.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket2.listenerCount(\"redirect\") === 0) {\n      const isSameHost = isIpcUrl ? websocket2._originalIpc ? opts.socketPath === websocket2._originalHostOrSocketPath : false : websocket2._originalIpc ? false : parsedUrl.host === websocket2._originalHostOrSocketPath;\n      if (!isSameHost || websocket2._originalSecure && !isSecure) {\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n        if (!isSameHost) delete opts.headers.host;\n        opts.auth = void 0;\n      }\n    }\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization = \"Basic \" + Buffer.from(opts.auth).toString(\"base64\");\n    }\n    req = websocket2._req = request(opts);\n    if (websocket2._redirects) {\n      websocket2.emit(\"redirect\", websocket2.url, req);\n    }\n  } else {\n    req = websocket2._req = request(opts);\n  }\n  if (opts.timeout) {\n    req.on(\"timeout\", () => {\n      abortHandshake$1(websocket2, req, \"Opening handshake has timed out\");\n    });\n  }\n  req.on(\"error\", err => {\n    if (req === null || req[kAborted]) return;\n    req = websocket2._req = null;\n    emitErrorAndClose(websocket2, err);\n  });\n  req.on(\"response\", res => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n      if (++websocket2._redirects > opts.maxRedirects) {\n        abortHandshake$1(websocket2, req, \"Maximum redirects exceeded\");\n        return;\n      }\n      req.abort();\n      let addr;\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket2, err);\n        return;\n      }\n      initAsClient(websocket2, addr, protocols, options);\n    } else if (!websocket2.emit(\"unexpected-response\", req, res)) {\n      abortHandshake$1(websocket2, req, `Unexpected server response: ${res.statusCode}`);\n    }\n  });\n  req.on(\"upgrade\", (res, socket, head) => {\n    websocket2.emit(\"upgrade\", res);\n    if (websocket2.readyState !== WebSocket$1.CONNECTING) return;\n    req = websocket2._req = null;\n    if (res.headers.upgrade.toLowerCase() !== \"websocket\") {\n      abortHandshake$1(websocket2, socket, \"Invalid Upgrade header\");\n      return;\n    }\n    const digest = createHash$1(\"sha1\").update(key + GUID$1).digest(\"base64\");\n    if (res.headers[\"sec-websocket-accept\"] !== digest) {\n      abortHandshake$1(websocket2, socket, \"Invalid Sec-WebSocket-Accept header\");\n      return;\n    }\n    const serverProt = res.headers[\"sec-websocket-protocol\"];\n    let protError;\n    if (serverProt !== void 0) {\n      if (!protocolSet.size) {\n        protError = \"Server sent a subprotocol but none was requested\";\n      } else if (!protocolSet.has(serverProt)) {\n        protError = \"Server sent an invalid subprotocol\";\n      }\n    } else if (protocolSet.size) {\n      protError = \"Server sent no subprotocol\";\n    }\n    if (protError) {\n      abortHandshake$1(websocket2, socket, protError);\n      return;\n    }\n    if (serverProt) websocket2._protocol = serverProt;\n    const secWebSocketExtensions = res.headers[\"sec-websocket-extensions\"];\n    if (secWebSocketExtensions !== void 0) {\n      if (!perMessageDeflate) {\n        const message = \"Server sent a Sec-WebSocket-Extensions header but no extension was requested\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      let extensions;\n      try {\n        extensions = parse$1(secWebSocketExtensions);\n      } catch (err) {\n        const message = \"Invalid Sec-WebSocket-Extensions header\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      const extensionNames = Object.keys(extensions);\n      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {\n        const message = \"Server indicated an extension that was not requested\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate$1.extensionName]);\n      } catch (err) {\n        const message = \"Invalid Sec-WebSocket-Extensions header\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      websocket2._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;\n    }\n    websocket2.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket2);\n  } else {\n    req.end();\n  }\n}\nfunction emitErrorAndClose(websocket2, err) {\n  websocket2._readyState = WebSocket$1.CLOSING;\n  websocket2.emit(\"error\", err);\n  websocket2.emitClose();\n}\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\nfunction tlsConnect(options) {\n  options.path = void 0;\n  if (!options.servername && options.servername !== \"\") {\n    options.servername = net.isIP(options.host) ? \"\" : options.host;\n  }\n  return tls.connect(options);\n}\nfunction abortHandshake$1(websocket2, stream2, message) {\n  websocket2._readyState = WebSocket$1.CLOSING;\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake$1);\n  if (stream2.setHeader) {\n    stream2[kAborted] = true;\n    stream2.abort();\n    if (stream2.socket && !stream2.socket.destroyed) {\n      stream2.socket.destroy();\n    }\n    process.nextTick(emitErrorAndClose, websocket2, err);\n  } else {\n    stream2.destroy(err);\n    stream2.once(\"error\", websocket2.emit.bind(websocket2, \"error\"));\n    stream2.once(\"close\", websocket2.emitClose.bind(websocket2));\n  }\n}\nfunction sendAfterClose(websocket2, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n    if (websocket2._socket) websocket2._sender._bufferedBytes += length;else websocket2._bufferedAmount += length;\n  }\n  if (cb) {\n    const err = new Error(`WebSocket is not open: readyState ${websocket2.readyState} (${readyStates[websocket2.readyState]})`);\n    process.nextTick(cb, err);\n  }\n}\nfunction receiverOnConclude(code, reason) {\n  const websocket2 = this[kWebSocket$1];\n  websocket2._closeFrameReceived = true;\n  websocket2._closeMessage = reason;\n  websocket2._closeCode = code;\n  if (websocket2._socket[kWebSocket$1] === void 0) return;\n  websocket2._socket.removeListener(\"data\", socketOnData);\n  process.nextTick(resume, websocket2._socket);\n  if (code === 1005) websocket2.close();else websocket2.close(code, reason);\n}\nfunction receiverOnDrain() {\n  const websocket2 = this[kWebSocket$1];\n  if (!websocket2.isPaused) websocket2._socket.resume();\n}\nfunction receiverOnError(err) {\n  const websocket2 = this[kWebSocket$1];\n  if (websocket2._socket[kWebSocket$1] !== void 0) {\n    websocket2._socket.removeListener(\"data\", socketOnData);\n    process.nextTick(resume, websocket2._socket);\n    websocket2.close(err[kStatusCode]);\n  }\n  websocket2.emit(\"error\", err);\n}\nfunction receiverOnFinish() {\n  this[kWebSocket$1].emitClose();\n}\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket$1].emit(\"message\", data, isBinary);\n}\nfunction receiverOnPing(data) {\n  const websocket2 = this[kWebSocket$1];\n  websocket2.pong(data, !websocket2._isServer, NOOP);\n  websocket2.emit(\"ping\", data);\n}\nfunction receiverOnPong(data) {\n  this[kWebSocket$1].emit(\"pong\", data);\n}\nfunction resume(stream2) {\n  stream2.resume();\n}\nfunction socketOnClose() {\n  const websocket2 = this[kWebSocket$1];\n  this.removeListener(\"close\", socketOnClose);\n  this.removeListener(\"data\", socketOnData);\n  this.removeListener(\"end\", socketOnEnd);\n  websocket2._readyState = WebSocket$1.CLOSING;\n  let chunk;\n  if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {\n    websocket2._receiver.write(chunk);\n  }\n  websocket2._receiver.end();\n  this[kWebSocket$1] = void 0;\n  clearTimeout(websocket2._closeTimer);\n  if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {\n    websocket2.emitClose();\n  } else {\n    websocket2._receiver.on(\"error\", receiverOnFinish);\n    websocket2._receiver.on(\"finish\", receiverOnFinish);\n  }\n}\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket$1]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\nfunction socketOnEnd() {\n  const websocket2 = this[kWebSocket$1];\n  websocket2._readyState = WebSocket$1.CLOSING;\n  websocket2._receiver.end();\n  this.end();\n}\nfunction socketOnError$1() {\n  const websocket2 = this[kWebSocket$1];\n  this.removeListener(\"error\", socketOnError$1);\n  this.on(\"error\", NOOP);\n  if (websocket2) {\n    websocket2._readyState = WebSocket$1.CLOSING;\n    this.destroy();\n  }\n}\nconst WebSocket$2 = /* @__PURE__ */getDefaultExportFromCjs(websocket);\nconst {\n  tokenChars\n} = validationExports;\nfunction parse(header) {\n  const protocols = /* @__PURE__ */new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (i !== 0 && (code === 32 || code === 9)) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 44) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n      if (end === -1) end = i;\n      const protocol2 = header.slice(start, end);\n      if (protocols.has(protocol2)) {\n        throw new SyntaxError(`The \"${protocol2}\" subprotocol is duplicated`);\n      }\n      protocols.add(protocol2);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError(\"Unexpected end of input\");\n  }\n  const protocol = header.slice(start, i);\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n  protocols.add(protocol);\n  return protocols;\n}\nvar subprotocol$1 = {\n  parse\n};\nconst EventEmitter = require$$0$4;\nconst http = require$$2$1;\nconst {\n  createHash\n} = require$$5;\nconst extension = extension$1;\nconst PerMessageDeflate2 = permessageDeflate;\nconst subprotocol = subprotocol$1;\nconst WebSocket2 = websocket;\nconst {\n  GUID,\n  kWebSocket\n} = constants;\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket: WebSocket2,\n      ...options\n    };\n    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n      throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options must be specified');\n    }\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          \"Content-Length\": body.length,\n          \"Content-Type\": \"text/plain\"\n        });\n        res.end(body);\n      });\n      this._server.listen(options.port, options.host, options.backlog, callback);\n    } else if (options.server) {\n      this._server = options.server;\n    }\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, \"connection\");\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, \"listening\"),\n        error: this.emit.bind(this, \"error\"),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = /* @__PURE__ */new Set();\n      this._shouldEmitClose = false;\n    }\n    this.options = options;\n    this._state = RUNNING;\n  }\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n    if (!this._server) return null;\n    return this._server.address();\n  }\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once(\"close\", () => {\n          cb(new Error(\"The server is not running\"));\n        });\n      }\n      process.nextTick(emitClose, this);\n      return;\n    }\n    if (cb) this.once(\"close\", cb);\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf(\"?\");\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n      if (pathname !== this.options.path) return false;\n    }\n    return true;\n  }\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on(\"error\", socketOnError);\n    const key = req.headers[\"sec-websocket-key\"];\n    const version = +req.headers[\"sec-websocket-version\"];\n    if (req.method !== \"GET\") {\n      const message = \"Invalid HTTP method\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n    if (req.headers.upgrade.toLowerCase() !== \"websocket\") {\n      const message = \"Invalid Upgrade header\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (!key || !keyRegex.test(key)) {\n      const message = \"Missing or invalid Sec-WebSocket-Key header\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (version !== 8 && version !== 13) {\n      const message = \"Missing or invalid Sec-WebSocket-Version header\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n    const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\n    let protocols = /* @__PURE__ */new Set();\n    if (secWebSocketProtocol !== void 0) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = \"Invalid Sec-WebSocket-Protocol header\";\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n    const secWebSocketExtensions = req.headers[\"sec-websocket-extensions\"];\n    const extensions = {};\n    if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {\n      const perMessageDeflate = new PerMessageDeflate2(this.options.perMessageDeflate, true, this.options.maxPayload);\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n        if (offers[PerMessageDeflate2.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate2.extensionName]);\n          extensions[PerMessageDeflate2.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message = \"Invalid or unacceptable Sec-WebSocket-Extensions header\";\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? \"sec-websocket-origin\" : \"origin\"}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n          this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n        });\n        return;\n      }\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    if (!socket.readable || !socket.writable) return socket.destroy();\n    if (socket[kWebSocket]) {\n      throw new Error(\"server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration\");\n    }\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n    const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n    const headers = [\"HTTP/1.1 101 Switching Protocols\", \"Upgrade: websocket\", \"Connection: Upgrade\", `Sec-WebSocket-Accept: ${digest}`];\n    const ws = new this.options.WebSocket(null);\n    if (protocols.size) {\n      const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n    if (extensions[PerMessageDeflate2.extensionName]) {\n      const params = extensions[PerMessageDeflate2.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate2.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n    this.emit(\"headers\", headers, req);\n    socket.write(headers.concat(\"\\r\\n\").join(\"\\r\\n\"));\n    socket.removeListener(\"error\", socketOnError);\n    ws.setSocket(socket, head, {\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on(\"close\", () => {\n        this.clients.delete(ws);\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n    cb(ws, req);\n  }\n}\nvar websocketServer = WebSocketServer;\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit(\"close\");\n}\nfunction socketOnError() {\n  this.destroy();\n}\nfunction abortHandshake(socket, code, message, headers) {\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: \"close\",\n    \"Content-Type\": \"text/html\",\n    \"Content-Length\": Buffer.byteLength(message),\n    ...headers\n  };\n  socket.once(\"finish\", socket.destroy);\n  socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\n` + Object.keys(headers).map(h => `${h}: ${headers[h]}`).join(\"\\r\\n\") + \"\\r\\n\\r\\n\" + message);\n}\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount(\"wsClientError\")) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n    server.emit(\"wsClientError\", err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}\nconst websocketServer$1 = /* @__PURE__ */getDefaultExportFromCjs(websocketServer);\nexport { receiver$1 as Receiver, sender$1 as Sender, WebSocket$2 as WebSocket, websocketServer$1 as WebSocketServer, stream$1 as createWebSocketStream, WebSocket$2 as default };","map":{"version":3,"names":["require$$0","require$$0$2","require$$0$1","require$$1$1","require$$2","require$$0$3","require$$3","require$$4","require$$5","require$$0$4","require$$1$2","require$$2$1","require$$7","getDefaultExportFromCjs","x","__esModule","Object","prototype","hasOwnProperty","call","getAugmentedNamespace","n","f","default","a","a2","Reflect","construct","arguments","constructor","apply","defineProperty","value","keys","forEach","k","d","getOwnPropertyDescriptor","get","enumerable","Duplex","emitClose$1","stream2","emit","duplexOnEnd","destroyed","_writableState","finished","destroy","duplexOnError","err","removeListener","listenerCount","createWebSocketStream","ws","options","terminateOnDestroy","duplex","autoDestroy","emitClose","objectMode","writableObjectMode","on","message","msg","isBinary","data","_readableState","toString","push","pause","once","error2","close","_destroy","callback","readyState","CLOSED","process","nextTick","called","err2","terminate","_final","CONNECTING","open","_socket","endEmitted","finish","_read","isPaused","resume","_write","chunk","encoding","send","stream","stream$1","bufferUtil$1","exports","constants","BINARY_TYPES","EMPTY_BUFFER","Buffer","alloc","GUID","kForOnEventAttribute","Symbol","kListener","kStatusCode","kWebSocket","NOOP","bufferutil","nodeGypBuild$1","commonjsRequire","path","Error","nodeGypBuild","hasRequiredNodeGypBuild$1","requireNodeGypBuild$1","fs","os","runtimeRequire","__webpack_require__","__non_webpack_require__","vars","config","variables","prebuildsOnly","env","PREBUILDS_ONLY","abi","versions","modules","runtime","isElectron","isNwjs","arch","npm_config_arch","platform","npm_config_platform","libc","LIBC","isAlpine","armv","ARM_VERSION","arm_version","uv","split","load","dir","resolve","name","join","toUpperCase","replace","release","getFirst","matchBuild","debug","prebuild","nearby","dirname","execPath","target","node","electron","filter","Boolean","dir2","tuples","readdirSync","map","parseTuple","tuple","matchTuple","sort","compareTuples","prebuilds","parsed","parseTags","candidates","matchTags","winner","compareTags","file","files","test","arr","length","platform2","architectures","every","arch2","includes","b","extension2","pop","tags","specificity","i","tag","napi","slice","runtime2","abi2","runtimeAgnostic","nw","ELECTRON_RUN_AS_NODE","window","type","existsSync","hasRequiredNodeGypBuild","requireNodeGypBuild","addon","bind","fallback","hasRequiredFallback","requireFallback","mask2","source","mask3","output","offset","unmask2","buffer","mask","unmask","hasRequiredBufferutil","requireBufferutil","__dirname","e","unmask$1","EMPTY_BUFFER$3","FastBuffer$2","species","concat$1","list","totalLength","allocUnsafe","buf","set","byteOffset","_mask","_unmask","toArrayBuffer$1","byteLength","toBuffer$2","readOnly","isBuffer","ArrayBuffer","isView","from","concat","toArrayBuffer","toBuffer","WS_NO_BUFFER_UTIL","bufferUtil2","bufferUtilExports","kDone","kRun","Limiter$1","Limiter","concurrency","pending","Infinity","jobs","add","job","shift","limiter","zlib","bufferUtil","Limiter2","kStatusCode$2","FastBuffer$1","TRAILER","kPerMessageDeflate","kTotalLength","kCallback","kBuffers","kError$1","zlibLimiter","PerMessageDeflate$4","PerMessageDeflate","isServer","maxPayload","_maxPayload","_options","_threshold","threshold","_isServer","_deflate","_inflate","params","concurrencyLimit","extensionName","offer","serverNoContextTakeover","server_no_context_takeover","clientNoContextTakeover","client_no_context_takeover","serverMaxWindowBits","server_max_window_bits","clientMaxWindowBits","client_max_window_bits","accept","configurations","normalizeParams","acceptAsServer","acceptAsClient","cleanup","offers","opts","accepted","find","response","key","num","Number","isInteger","TypeError","decompress","fin","done","_decompress","result","compress","_compress","endpoint","windowBits","Z_DEFAULT_WINDOWBITS","createInflateRaw","zlibInflateOptions","inflateOnError","inflateOnData","write","flush","data2","reset","createDeflateRaw","zlibDeflateOptions","deflateOnData","Z_SYNC_FLUSH","permessageDeflate","RangeError","code","validation","__viteOptionalPeerDep_utf8Validate_ws","__viteOptionalPeerDep_utf8Validate_ws$1","freeze","__proto__","toStringTag","require$$1","isValidUTF8_1","isUtf8","tokenChars$2","isValidStatusCode$2","_isValidUTF8","len","isValidStatusCode","isValidUTF8","tokenChars","WS_NO_UTF_8_VALIDATE","isValidUTF82","validationExports","Writable","PerMessageDeflate$3","BINARY_TYPES$1","EMPTY_BUFFER$2","kStatusCode$1","kWebSocket$2","isValidStatusCode$1","FastBuffer","GET_INFO","GET_PAYLOAD_LENGTH_16","GET_PAYLOAD_LENGTH_64","GET_MASK","GET_DATA","INFLATING","Receiver$1","Receiver","_binaryType","binaryType","_extensions","extensions","_skipUTF8Validation","skipUTF8Validation","_bufferedBytes","_buffers","_compressed","_payloadLength","_fragmented","_masked","_fin","_opcode","_totalPayloadLength","_messageLength","_fragments","_state","_loop","cb","startLoop","consume","dst","Uint8Array","getInfo","getPayloadLength16","getPayloadLength64","getMask","getData","error","compressed","haveLength","readUInt16BE","readUInt32BE","Math","pow","controlMessage","dataMessage","perMessageDeflate","er","messageLength","fragments","end","receiver","ErrorCtor","prefix","statusCode","errorCode","captureStackTrace","receiver$1","randomFillSync","PerMessageDeflate$2","EMPTY_BUFFER$1","applyMask","toBuffer$1","kByteLength","maskBuffer","Sender$1","Sender","socket","generateMask","_generateMask","_maskBuffer","_firstFragment","_deflating","_queue","frame","merge","skipMasking","dataLength","payloadLength","opcode","rsv1","writeUInt16BE","writeUIntBE","enqueue","dispatch","sendFrame","ping","pong","binary","_","dequeue","cork","uncork","sender","sender$1","kForOnEventAttribute$1","kListener$1","kCode","kData","kError","kMessage","kReason","kTarget","kType","kWasClean","Event","CloseEvent","reason","wasClean","ErrorEvent","MessageEvent","EventTarget","addEventListener","handler","listener","listeners","wrapper","onMessage","event","callListener","onClose","_closeFrameReceived","_closeFrameSent","onError","onOpen","removeEventListener","eventTarget","thisArg","handleEvent","tokenChars$1","dest","elem","parse$2","header","create","mustUnescape","isEscaping","inQuotes","paramName","start","charCodeAt","SyntaxError","token","format$1","Array","isArray","values","v","extension$1","format","parse","EventEmitter$1","https","http$1","net","tls","randomBytes","createHash","createHash$1","URL","PerMessageDeflate$1","Receiver2","Sender2","GUID$1","kWebSocket$1","parse$1","closeTimeout","kAborted","protocolVersions","readyStates","subprotocolRegex","WebSocket$1","WebSocket","address","protocols","_closeCode","_closeMessage","_closeTimer","_paused","_protocol","_readyState","_receiver","_sender","_bufferedAmount","_redirects","initAsClient","bufferedAmount","onclose","onerror","onopen","onmessage","protocol","url","_url","setSocket","head","receiver2","receiverOnConclude","receiverOnDrain","receiverOnError","receiverOnMessage","receiverOnPing","receiverOnPong","setTimeout","setNoDelay","unshift","socketOnClose","socketOnData","socketOnEnd","socketOnError$1","OPEN","removeAllListeners","abortHandshake$1","_req","CLOSING","errorEmitted","sendAfterClose","needDrain","indexOf","property","method","websocket","websocket2","protocolVersion","followRedirects","maxRedirects","createConnection","socketPath","hostname","timeout","host","port","parsedUrl","href","isSecure","isIpcUrl","invalidUrlMessage","pathname","hash","emitErrorAndClose","defaultPort","request","protocolSet","Set","tlsConnect","netConnect","startsWith","headers","Connection","Upgrade","search","handshakeTimeout","has","origin","Origin","username","password","auth","parts","req","_originalIpc","_originalSecure","_originalHostOrSocketPath","key2","entries","toLowerCase","isSameHost","authorization","cookie","res","location","abort","addr","upgrade","digest","update","serverProt","protError","size","secWebSocketExtensions","extensionNames","finishRequest","connect","servername","isIP","setHeader","receiverOnFinish","read","clearTimeout","WebSocket$2","protocol2","subprotocol$1","EventEmitter","http","extension","PerMessageDeflate2","subprotocol","WebSocket2","keyRegex","RUNNING","WebSocketServer","handleProtocols","clientTracking","verifyClient","noServer","backlog","server","_server","createServer","body","STATUS_CODES","writeHead","listen","emitConnection","_removeListeners","addListeners","listening","handleUpgrade","clients","_shouldEmitClose","shouldHandle","index","socketOnError","version","abortHandshakeOrEmitwsClientError","abortHandshake","secWebSocketProtocol","info","secure","authorized","encrypted","verified","completeUpgrade","readable","writable","next","delete","websocketServer","removeListeners","h","websocketServer$1"],"sources":["C:/Users/elect/Documents/CIS/4914/Mellowdies/mellowdies/node_modules/@gradio/client/dist/wrapper-CviSselG.js"],"sourcesContent":["import require$$0 from \"stream\";\nimport require$$0$2 from \"zlib\";\nimport require$$0$1 from \"fs\";\nimport require$$1$1 from \"path\";\nimport require$$2 from \"os\";\nimport require$$0$3 from \"buffer\";\nimport require$$3 from \"net\";\nimport require$$4 from \"tls\";\nimport require$$5 from \"crypto\";\nimport require$$0$4 from \"events\";\nimport require$$1$2 from \"https\";\nimport require$$2$1 from \"http\";\nimport require$$7 from \"url\";\nfunction getDefaultExportFromCjs(x) {\n  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nfunction getAugmentedNamespace(n) {\n  if (n.__esModule)\n    return n;\n  var f = n.default;\n  if (typeof f == \"function\") {\n    var a = function a2() {\n      if (this instanceof a2) {\n        return Reflect.construct(f, arguments, this.constructor);\n      }\n      return f.apply(this, arguments);\n    };\n    a.prototype = f.prototype;\n  } else\n    a = {};\n  Object.defineProperty(a, \"__esModule\", { value: true });\n  Object.keys(n).forEach(function(k) {\n    var d = Object.getOwnPropertyDescriptor(n, k);\n    Object.defineProperty(a, k, d.get ? d : {\n      enumerable: true,\n      get: function() {\n        return n[k];\n      }\n    });\n  });\n  return a;\n}\nconst { Duplex } = require$$0;\nfunction emitClose$1(stream2) {\n  stream2.emit(\"close\");\n}\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\nfunction duplexOnError(err) {\n  this.removeListener(\"error\", duplexOnError);\n  this.destroy();\n  if (this.listenerCount(\"error\") === 0) {\n    this.emit(\"error\", err);\n  }\n}\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n  ws.on(\"message\", function message(msg, isBinary) {\n    const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n    if (!duplex.push(data))\n      ws.pause();\n  });\n  ws.once(\"error\", function error2(err) {\n    if (duplex.destroyed)\n      return;\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n  ws.once(\"close\", function close() {\n    if (duplex.destroyed)\n      return;\n    duplex.push(null);\n  });\n  duplex._destroy = function(err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose$1, duplex);\n      return;\n    }\n    let called = false;\n    ws.once(\"error\", function error2(err2) {\n      called = true;\n      callback(err2);\n    });\n    ws.once(\"close\", function close() {\n      if (!called)\n        callback(err);\n      process.nextTick(emitClose$1, duplex);\n    });\n    if (terminateOnDestroy)\n      ws.terminate();\n  };\n  duplex._final = function(callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once(\"open\", function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n    if (ws._socket === null)\n      return;\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted)\n        duplex.destroy();\n    } else {\n      ws._socket.once(\"finish\", function finish() {\n        callback();\n      });\n      ws.close();\n    }\n  };\n  duplex._read = function() {\n    if (ws.isPaused)\n      ws.resume();\n  };\n  duplex._write = function(chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once(\"open\", function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n    ws.send(chunk, callback);\n  };\n  duplex.on(\"end\", duplexOnEnd);\n  duplex.on(\"error\", duplexOnError);\n  return duplex;\n}\nvar stream = createWebSocketStream;\nconst stream$1 = /* @__PURE__ */ getDefaultExportFromCjs(stream);\nvar bufferUtil$1 = { exports: {} };\nvar constants = {\n  BINARY_TYPES: [\"nodebuffer\", \"arraybuffer\", \"fragments\"],\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\",\n  kForOnEventAttribute: Symbol(\"kIsForOnEventAttribute\"),\n  kListener: Symbol(\"kListener\"),\n  kStatusCode: Symbol(\"status-code\"),\n  kWebSocket: Symbol(\"websocket\"),\n  NOOP: () => {\n  }\n};\nvar bufferutil = { exports: {} };\nvar nodeGypBuild$1 = { exports: {} };\nfunction commonjsRequire(path) {\n  throw new Error('Could not dynamically require \"' + path + '\". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');\n}\nvar nodeGypBuild;\nvar hasRequiredNodeGypBuild$1;\nfunction requireNodeGypBuild$1() {\n  if (hasRequiredNodeGypBuild$1)\n    return nodeGypBuild;\n  hasRequiredNodeGypBuild$1 = 1;\n  var fs = require$$0$1;\n  var path = require$$1$1;\n  var os = require$$2;\n  var runtimeRequire = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : commonjsRequire;\n  var vars = process.config && process.config.variables || {};\n  var prebuildsOnly = !!process.env.PREBUILDS_ONLY;\n  var abi = process.versions.modules;\n  var runtime = isElectron() ? \"electron\" : isNwjs() ? \"node-webkit\" : \"node\";\n  var arch = process.env.npm_config_arch || os.arch();\n  var platform = process.env.npm_config_platform || os.platform();\n  var libc = process.env.LIBC || (isAlpine(platform) ? \"musl\" : \"glibc\");\n  var armv = process.env.ARM_VERSION || (arch === \"arm64\" ? \"8\" : vars.arm_version) || \"\";\n  var uv = (process.versions.uv || \"\").split(\".\")[0];\n  nodeGypBuild = load;\n  function load(dir) {\n    return runtimeRequire(load.resolve(dir));\n  }\n  load.resolve = load.path = function(dir) {\n    dir = path.resolve(dir || \".\");\n    try {\n      var name = runtimeRequire(path.join(dir, \"package.json\")).name.toUpperCase().replace(/-/g, \"_\");\n      if (process.env[name + \"_PREBUILD\"])\n        dir = process.env[name + \"_PREBUILD\"];\n    } catch (err) {\n    }\n    if (!prebuildsOnly) {\n      var release = getFirst(path.join(dir, \"build/Release\"), matchBuild);\n      if (release)\n        return release;\n      var debug = getFirst(path.join(dir, \"build/Debug\"), matchBuild);\n      if (debug)\n        return debug;\n    }\n    var prebuild = resolve(dir);\n    if (prebuild)\n      return prebuild;\n    var nearby = resolve(path.dirname(process.execPath));\n    if (nearby)\n      return nearby;\n    var target = [\n      \"platform=\" + platform,\n      \"arch=\" + arch,\n      \"runtime=\" + runtime,\n      \"abi=\" + abi,\n      \"uv=\" + uv,\n      armv ? \"armv=\" + armv : \"\",\n      \"libc=\" + libc,\n      \"node=\" + process.versions.node,\n      process.versions.electron ? \"electron=\" + process.versions.electron : \"\",\n      typeof __webpack_require__ === \"function\" ? \"webpack=true\" : \"\"\n      // eslint-disable-line\n    ].filter(Boolean).join(\" \");\n    throw new Error(\"No native build was found for \" + target + \"\\n    loaded from: \" + dir + \"\\n\");\n    function resolve(dir2) {\n      var tuples = readdirSync(path.join(dir2, \"prebuilds\")).map(parseTuple);\n      var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];\n      if (!tuple)\n        return;\n      var prebuilds = path.join(dir2, \"prebuilds\", tuple.name);\n      var parsed = readdirSync(prebuilds).map(parseTags);\n      var candidates = parsed.filter(matchTags(runtime, abi));\n      var winner = candidates.sort(compareTags(runtime))[0];\n      if (winner)\n        return path.join(prebuilds, winner.file);\n    }\n  };\n  function readdirSync(dir) {\n    try {\n      return fs.readdirSync(dir);\n    } catch (err) {\n      return [];\n    }\n  }\n  function getFirst(dir, filter) {\n    var files = readdirSync(dir).filter(filter);\n    return files[0] && path.join(dir, files[0]);\n  }\n  function matchBuild(name) {\n    return /\\.node$/.test(name);\n  }\n  function parseTuple(name) {\n    var arr = name.split(\"-\");\n    if (arr.length !== 2)\n      return;\n    var platform2 = arr[0];\n    var architectures = arr[1].split(\"+\");\n    if (!platform2)\n      return;\n    if (!architectures.length)\n      return;\n    if (!architectures.every(Boolean))\n      return;\n    return { name, platform: platform2, architectures };\n  }\n  function matchTuple(platform2, arch2) {\n    return function(tuple) {\n      if (tuple == null)\n        return false;\n      if (tuple.platform !== platform2)\n        return false;\n      return tuple.architectures.includes(arch2);\n    };\n  }\n  function compareTuples(a, b) {\n    return a.architectures.length - b.architectures.length;\n  }\n  function parseTags(file) {\n    var arr = file.split(\".\");\n    var extension2 = arr.pop();\n    var tags = { file, specificity: 0 };\n    if (extension2 !== \"node\")\n      return;\n    for (var i = 0; i < arr.length; i++) {\n      var tag = arr[i];\n      if (tag === \"node\" || tag === \"electron\" || tag === \"node-webkit\") {\n        tags.runtime = tag;\n      } else if (tag === \"napi\") {\n        tags.napi = true;\n      } else if (tag.slice(0, 3) === \"abi\") {\n        tags.abi = tag.slice(3);\n      } else if (tag.slice(0, 2) === \"uv\") {\n        tags.uv = tag.slice(2);\n      } else if (tag.slice(0, 4) === \"armv\") {\n        tags.armv = tag.slice(4);\n      } else if (tag === \"glibc\" || tag === \"musl\") {\n        tags.libc = tag;\n      } else {\n        continue;\n      }\n      tags.specificity++;\n    }\n    return tags;\n  }\n  function matchTags(runtime2, abi2) {\n    return function(tags) {\n      if (tags == null)\n        return false;\n      if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))\n        return false;\n      if (tags.abi !== abi2 && !tags.napi)\n        return false;\n      if (tags.uv && tags.uv !== uv)\n        return false;\n      if (tags.armv && tags.armv !== armv)\n        return false;\n      if (tags.libc && tags.libc !== libc)\n        return false;\n      return true;\n    };\n  }\n  function runtimeAgnostic(tags) {\n    return tags.runtime === \"node\" && tags.napi;\n  }\n  function compareTags(runtime2) {\n    return function(a, b) {\n      if (a.runtime !== b.runtime) {\n        return a.runtime === runtime2 ? -1 : 1;\n      } else if (a.abi !== b.abi) {\n        return a.abi ? -1 : 1;\n      } else if (a.specificity !== b.specificity) {\n        return a.specificity > b.specificity ? -1 : 1;\n      } else {\n        return 0;\n      }\n    };\n  }\n  function isNwjs() {\n    return !!(process.versions && process.versions.nw);\n  }\n  function isElectron() {\n    if (process.versions && process.versions.electron)\n      return true;\n    if (process.env.ELECTRON_RUN_AS_NODE)\n      return true;\n    return typeof window !== \"undefined\" && window.process && window.process.type === \"renderer\";\n  }\n  function isAlpine(platform2) {\n    return platform2 === \"linux\" && fs.existsSync(\"/etc/alpine-release\");\n  }\n  load.parseTags = parseTags;\n  load.matchTags = matchTags;\n  load.compareTags = compareTags;\n  load.parseTuple = parseTuple;\n  load.matchTuple = matchTuple;\n  load.compareTuples = compareTuples;\n  return nodeGypBuild;\n}\nvar hasRequiredNodeGypBuild;\nfunction requireNodeGypBuild() {\n  if (hasRequiredNodeGypBuild)\n    return nodeGypBuild$1.exports;\n  hasRequiredNodeGypBuild = 1;\n  if (typeof process.addon === \"function\") {\n    nodeGypBuild$1.exports = process.addon.bind(process);\n  } else {\n    nodeGypBuild$1.exports = requireNodeGypBuild$1();\n  }\n  return nodeGypBuild$1.exports;\n}\nvar fallback;\nvar hasRequiredFallback;\nfunction requireFallback() {\n  if (hasRequiredFallback)\n    return fallback;\n  hasRequiredFallback = 1;\n  const mask2 = (source, mask3, output, offset, length) => {\n    for (var i = 0; i < length; i++) {\n      output[offset + i] = source[i] ^ mask3[i & 3];\n    }\n  };\n  const unmask2 = (buffer, mask3) => {\n    const length = buffer.length;\n    for (var i = 0; i < length; i++) {\n      buffer[i] ^= mask3[i & 3];\n    }\n  };\n  fallback = { mask: mask2, unmask: unmask2 };\n  return fallback;\n}\nvar hasRequiredBufferutil;\nfunction requireBufferutil() {\n  if (hasRequiredBufferutil)\n    return bufferutil.exports;\n  hasRequiredBufferutil = 1;\n  try {\n    bufferutil.exports = requireNodeGypBuild()(__dirname);\n  } catch (e) {\n    bufferutil.exports = requireFallback();\n  }\n  return bufferutil.exports;\n}\nvar unmask$1;\nvar mask;\nconst { EMPTY_BUFFER: EMPTY_BUFFER$3 } = constants;\nconst FastBuffer$2 = Buffer[Symbol.species];\nfunction concat$1(list, totalLength) {\n  if (list.length === 0)\n    return EMPTY_BUFFER$3;\n  if (list.length === 1)\n    return list[0];\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n  if (offset < totalLength) {\n    return new FastBuffer$2(target.buffer, target.byteOffset, offset);\n  }\n  return target;\n}\nfunction _mask(source, mask2, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask2[i & 3];\n  }\n}\nfunction _unmask(buffer, mask2) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask2[i & 3];\n  }\n}\nfunction toArrayBuffer$1(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\nfunction toBuffer$2(data) {\n  toBuffer$2.readOnly = true;\n  if (Buffer.isBuffer(data))\n    return data;\n  let buf;\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer$2(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer$2(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer$2.readOnly = false;\n  }\n  return buf;\n}\nbufferUtil$1.exports = {\n  concat: concat$1,\n  mask: _mask,\n  toArrayBuffer: toArrayBuffer$1,\n  toBuffer: toBuffer$2,\n  unmask: _unmask\n};\nif (!process.env.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil2 = requireBufferutil();\n    mask = bufferUtil$1.exports.mask = function(source, mask2, output, offset, length) {\n      if (length < 48)\n        _mask(source, mask2, output, offset, length);\n      else\n        bufferUtil2.mask(source, mask2, output, offset, length);\n    };\n    unmask$1 = bufferUtil$1.exports.unmask = function(buffer, mask2) {\n      if (buffer.length < 32)\n        _unmask(buffer, mask2);\n      else\n        bufferUtil2.unmask(buffer, mask2);\n    };\n  } catch (e) {\n  }\n}\nvar bufferUtilExports = bufferUtil$1.exports;\nconst kDone = Symbol(\"kDone\");\nconst kRun = Symbol(\"kRun\");\nlet Limiter$1 = class Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency)\n      return;\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n};\nvar limiter = Limiter$1;\nconst zlib = require$$0$2;\nconst bufferUtil = bufferUtilExports;\nconst Limiter2 = limiter;\nconst { kStatusCode: kStatusCode$2 } = constants;\nconst FastBuffer$1 = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0, 0, 255, 255]);\nconst kPerMessageDeflate = Symbol(\"permessage-deflate\");\nconst kTotalLength = Symbol(\"total-length\");\nconst kCallback = Symbol(\"callback\");\nconst kBuffers = Symbol(\"buffers\");\nconst kError$1 = Symbol(\"error\");\nlet zlibLimiter;\nlet PerMessageDeflate$4 = class PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n    this.params = null;\n    if (!zlibLimiter) {\n      const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;\n      zlibLimiter = new Limiter2(concurrency);\n    }\n  }\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return \"permessage-deflate\";\n  }\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n    return params;\n  }\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n    this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n    return this.params;\n  }\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n      this._deflate.close();\n      this._deflate = null;\n      if (callback) {\n        callback(\n          new Error(\n            \"The deflate stream was closed while data was being processed\"\n          )\n        );\n      }\n    }\n  }\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === \"number\" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === \"number\" && !params.client_max_window_bits) {\n        return false;\n      }\n      return true;\n    });\n    if (!accepted) {\n      throw new Error(\"None of the extension offers can be accepted\");\n    }\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === \"number\") {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === \"number\") {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n      delete accepted.client_max_window_bits;\n    }\n    return accepted;\n  }\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n    if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === \"number\") {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === \"number\" && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n    return params;\n  }\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n        value = value[0];\n        if (key === \"client_max_window_bits\") {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === \"server_max_window_bits\") {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (key === \"client_no_context_takeover\" || key === \"server_no_context_takeover\") {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n        params[key] = value;\n      });\n    });\n    return configurations;\n  }\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? \"client\" : \"server\";\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on(\"error\", inflateOnError);\n      this._inflate.on(\"data\", inflateOnData);\n    }\n    this._inflate[kCallback] = callback;\n    this._inflate.write(data);\n    if (fin)\n      this._inflate.write(TRAILER);\n    this._inflate.flush(() => {\n      const err = this._inflate[kError$1];\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n      const data2 = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n      callback(null, data2);\n    });\n  }\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? \"server\" : \"client\";\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      this._deflate.on(\"data\", deflateOnData);\n    }\n    this._deflate[kCallback] = callback;\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        return;\n      }\n      let data2 = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n      if (fin) {\n        data2 = new FastBuffer$1(data2.buffer, data2.byteOffset, data2.length - 4);\n      }\n      this._deflate[kCallback] = null;\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n      callback(null, data2);\n    });\n  }\n};\nvar permessageDeflate = PerMessageDeflate$4;\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n  this[kError$1] = new RangeError(\"Max payload size exceeded\");\n  this[kError$1].code = \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\";\n  this[kError$1][kStatusCode$2] = 1009;\n  this.removeListener(\"data\", inflateOnData);\n  this.reset();\n}\nfunction inflateOnError(err) {\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode$2] = 1007;\n  this[kCallback](err);\n}\nvar validation = { exports: {} };\nconst __viteOptionalPeerDep_utf8Validate_ws = {};\nconst __viteOptionalPeerDep_utf8Validate_ws$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: __viteOptionalPeerDep_utf8Validate_ws\n}, Symbol.toStringTag, { value: \"Module\" }));\nconst require$$1 = /* @__PURE__ */ getAugmentedNamespace(__viteOptionalPeerDep_utf8Validate_ws$1);\nvar isValidUTF8_1;\nconst { isUtf8 } = require$$0$3;\nconst tokenChars$2 = [\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  // 0 - 15\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  // 16 - 31\n  0,\n  1,\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0,\n  1,\n  1,\n  0,\n  // 32 - 47\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  // 48 - 63\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  // 64 - 79\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  1,\n  1,\n  // 80 - 95\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  // 96 - 111\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  1,\n  0,\n  1,\n  0\n  // 112 - 127\n];\nfunction isValidStatusCode$2(code) {\n  return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;\n}\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n  while (i < len) {\n    if ((buf[i] & 128) === 0) {\n      i++;\n    } else if ((buf[i] & 224) === 192) {\n      if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {\n        return false;\n      }\n      i += 2;\n    } else if ((buf[i] & 240) === 224) {\n      if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong\n      buf[i] === 237 && (buf[i + 1] & 224) === 160) {\n        return false;\n      }\n      i += 3;\n    } else if ((buf[i] & 248) === 240) {\n      if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong\n      buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {\n        return false;\n      }\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n  return true;\n}\nvalidation.exports = {\n  isValidStatusCode: isValidStatusCode$2,\n  isValidUTF8: _isValidUTF8,\n  tokenChars: tokenChars$2\n};\nif (isUtf8) {\n  isValidUTF8_1 = validation.exports.isValidUTF8 = function(buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF82 = require$$1;\n    isValidUTF8_1 = validation.exports.isValidUTF8 = function(buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF82(buf);\n    };\n  } catch (e) {\n  }\n}\nvar validationExports = validation.exports;\nconst { Writable } = require$$0;\nconst PerMessageDeflate$3 = permessageDeflate;\nconst {\n  BINARY_TYPES: BINARY_TYPES$1,\n  EMPTY_BUFFER: EMPTY_BUFFER$2,\n  kStatusCode: kStatusCode$1,\n  kWebSocket: kWebSocket$2\n} = constants;\nconst { concat, toArrayBuffer, unmask } = bufferUtilExports;\nconst { isValidStatusCode: isValidStatusCode$1, isValidUTF8 } = validationExports;\nconst FastBuffer = Buffer[Symbol.species];\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nlet Receiver$1 = class Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n    this._binaryType = options.binaryType || BINARY_TYPES$1[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket$2] = void 0;\n    this._bufferedBytes = 0;\n    this._buffers = [];\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = void 0;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 8 && this._state == GET_INFO)\n      return cb();\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n    if (n === this._buffers[0].length)\n      return this._buffers.shift();\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(\n        buf.buffer,\n        buf.byteOffset + n,\n        buf.length - n\n      );\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n    const dst = Buffer.allocUnsafe(n);\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(\n          buf.buffer,\n          buf.byteOffset + n,\n          buf.length - n\n        );\n      }\n      n -= buf.length;\n    } while (n > 0);\n    return dst;\n  }\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n    cb(err);\n  }\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(2);\n    if ((buf[0] & 48) !== 0) {\n      this._loop = false;\n      return error(\n        RangeError,\n        \"RSV2 and RSV3 must be clear\",\n        true,\n        1002,\n        \"WS_ERR_UNEXPECTED_RSV_2_3\"\n      );\n    }\n    const compressed = (buf[0] & 64) === 64;\n    if (compressed && !this._extensions[PerMessageDeflate$3.extensionName]) {\n      this._loop = false;\n      return error(\n        RangeError,\n        \"RSV1 must be clear\",\n        true,\n        1002,\n        \"WS_ERR_UNEXPECTED_RSV_1\"\n      );\n    }\n    this._fin = (buf[0] & 128) === 128;\n    this._opcode = buf[0] & 15;\n    this._payloadLength = buf[1] & 127;\n    if (this._opcode === 0) {\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"RSV1 must be clear\",\n          true,\n          1002,\n          \"WS_ERR_UNEXPECTED_RSV_1\"\n        );\n      }\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"invalid opcode 0\",\n          true,\n          1002,\n          \"WS_ERR_INVALID_OPCODE\"\n        );\n      }\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 1 || this._opcode === 2) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          \"WS_ERR_INVALID_OPCODE\"\n        );\n      }\n      this._compressed = compressed;\n    } else if (this._opcode > 7 && this._opcode < 11) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"FIN must be set\",\n          true,\n          1002,\n          \"WS_ERR_EXPECTED_FIN\"\n        );\n      }\n      if (compressed) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"RSV1 must be clear\",\n          true,\n          1002,\n          \"WS_ERR_UNEXPECTED_RSV_1\"\n        );\n      }\n      if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\"\n        );\n      }\n    } else {\n      this._loop = false;\n      return error(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        \"WS_ERR_INVALID_OPCODE\"\n      );\n    }\n    if (!this._fin && !this._fragmented)\n      this._fragmented = this._opcode;\n    this._masked = (buf[1] & 128) === 128;\n    if (this._isServer) {\n      if (!this._masked) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"MASK must be set\",\n          true,\n          1002,\n          \"WS_ERR_EXPECTED_MASK\"\n        );\n      }\n    } else if (this._masked) {\n      this._loop = false;\n      return error(\n        RangeError,\n        \"MASK must be clear\",\n        true,\n        1002,\n        \"WS_ERR_UNEXPECTED_MASK\"\n      );\n    }\n    if (this._payloadLength === 126)\n      this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127)\n      this._state = GET_PAYLOAD_LENGTH_64;\n    else\n      return this.haveLength();\n  }\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(\n        RangeError,\n        \"Unsupported WebSocket frame: payload length > 2^53 - 1\",\n        false,\n        1009,\n        \"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH\"\n      );\n    }\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 8) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(\n          RangeError,\n          \"Max payload size exceeded\",\n          false,\n          1009,\n          \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"\n        );\n      }\n    }\n    if (this._masked)\n      this._state = GET_MASK;\n    else\n      this._state = GET_DATA;\n  }\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER$2;\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n      data = this.consume(this._payloadLength);\n      if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n        unmask(data, this._mask);\n      }\n    }\n    if (this._opcode > 7)\n      return this.controlMessage(data);\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n    if (data.length) {\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n    return this.dataMessage();\n  }\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate$3.extensionName];\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err)\n        return cb(err);\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(\n            error(\n              RangeError,\n              \"Max payload size exceeded\",\n              false,\n              1009,\n              \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\"\n            )\n          );\n        }\n        this._fragments.push(buf);\n      }\n      const er = this.dataMessage();\n      if (er)\n        return cb(er);\n      this.startLoop(cb);\n    });\n  }\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n      if (this._opcode === 2) {\n        let data;\n        if (this._binaryType === \"nodebuffer\") {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === \"arraybuffer\") {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n        this.emit(\"message\", data, true);\n      } else {\n        const buf = concat(fragments, messageLength);\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          this._loop = false;\n          return error(\n            Error,\n            \"invalid UTF-8 sequence\",\n            true,\n            1007,\n            \"WS_ERR_INVALID_UTF8\"\n          );\n        }\n        this.emit(\"message\", buf, false);\n      }\n    }\n    this._state = GET_INFO;\n  }\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 8) {\n      this._loop = false;\n      if (data.length === 0) {\n        this.emit(\"conclude\", 1005, EMPTY_BUFFER$2);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n        if (!isValidStatusCode$1(code)) {\n          return error(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            \"WS_ERR_INVALID_CLOSE_CODE\"\n          );\n        }\n        const buf = new FastBuffer(\n          data.buffer,\n          data.byteOffset + 2,\n          data.length - 2\n        );\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          return error(\n            Error,\n            \"invalid UTF-8 sequence\",\n            true,\n            1007,\n            \"WS_ERR_INVALID_UTF8\"\n          );\n        }\n        this.emit(\"conclude\", code, buf);\n        this.end();\n      }\n    } else if (this._opcode === 9) {\n      this.emit(\"ping\", data);\n    } else {\n      this.emit(\"pong\", data);\n    }\n    this._state = GET_INFO;\n  }\n};\nvar receiver = Receiver$1;\nfunction error(ErrorCtor, message, prefix, statusCode, errorCode) {\n  const err = new ErrorCtor(\n    prefix ? `Invalid WebSocket frame: ${message}` : message\n  );\n  Error.captureStackTrace(err, error);\n  err.code = errorCode;\n  err[kStatusCode$1] = statusCode;\n  return err;\n}\nconst receiver$1 = /* @__PURE__ */ getDefaultExportFromCjs(receiver);\nconst { randomFillSync } = require$$5;\nconst PerMessageDeflate$2 = permessageDeflate;\nconst { EMPTY_BUFFER: EMPTY_BUFFER$1 } = constants;\nconst { isValidStatusCode } = validationExports;\nconst { mask: applyMask, toBuffer: toBuffer$1 } = bufferUtilExports;\nconst kByteLength = Symbol(\"kByteLength\");\nconst maskBuffer = Buffer.alloc(4);\nlet Sender$1 = class Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n    this._socket = socket;\n    this._firstFragment = true;\n    this._compress = false;\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask2;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n    if (options.mask) {\n      mask2 = options.maskBuffer || maskBuffer;\n      if (options.generateMask) {\n        options.generateMask(mask2);\n      } else {\n        randomFillSync(mask2, 0, 4);\n      }\n      skipMasking = (mask2[0] | mask2[1] | mask2[2] | mask2[3]) === 0;\n      offset = 6;\n    }\n    let dataLength;\n    if (typeof data === \"string\") {\n      if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n    let payloadLength = dataLength;\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n    target[0] = options.fin ? options.opcode | 128 : options.opcode;\n    if (options.rsv1)\n      target[0] |= 64;\n    target[1] = payloadLength;\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n    if (!options.mask)\n      return [target, data];\n    target[1] |= 128;\n    target[offset - 4] = mask2[0];\n    target[offset - 3] = mask2[1];\n    target[offset - 2] = mask2[2];\n    target[offset - 1] = mask2[3];\n    if (skipMasking)\n      return [target, data];\n    if (merge) {\n      applyMask(data, mask2, target, offset, dataLength);\n      return [target];\n    }\n    applyMask(data, mask2, data, 0, dataLength);\n    return [target, data];\n  }\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask2, cb) {\n    let buf;\n    if (code === void 0) {\n      buf = EMPTY_BUFFER$1;\n    } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n      throw new TypeError(\"First argument must be a valid error code number\");\n    } else if (data === void 0 || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n      if (length > 123) {\n        throw new RangeError(\"The message must not be greater than 123 bytes\");\n      }\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n      if (typeof data === \"string\") {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask: mask2,\n      maskBuffer: this._maskBuffer,\n      opcode: 8,\n      readOnly: false,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask2, cb) {\n    let byteLength;\n    let readOnly;\n    if (typeof data === \"string\") {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer$1(data);\n      byteLength = data.length;\n      readOnly = toBuffer$1.readOnly;\n    }\n    if (byteLength > 125) {\n      throw new RangeError(\"The data size must not be greater than 125 bytes\");\n    }\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask: mask2,\n      maskBuffer: this._maskBuffer,\n      opcode: 9,\n      readOnly,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask2, cb) {\n    let byteLength;\n    let readOnly;\n    if (typeof data === \"string\") {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer$1(data);\n      byteLength = data.length;\n      readOnly = toBuffer$1.readOnly;\n    }\n    if (byteLength > 125) {\n      throw new RangeError(\"The data size must not be greater than 125 bytes\");\n    }\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask: mask2,\n      maskBuffer: this._maskBuffer,\n      opcode: 10,\n      readOnly,\n      rsv1: false\n    };\n    if (this._deflating) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n    let byteLength;\n    let readOnly;\n    if (typeof data === \"string\") {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else {\n      data = toBuffer$1(data);\n      byteLength = data.length;\n      readOnly = toBuffer$1.readOnly;\n    }\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n    if (options.fin)\n      this._firstFragment = true;\n    if (perMessageDeflate) {\n      const opts = {\n        [kByteLength]: byteLength,\n        fin: options.fin,\n        generateMask: this._generateMask,\n        mask: options.mask,\n        maskBuffer: this._maskBuffer,\n        opcode,\n        readOnly,\n        rsv1\n      };\n      if (this._deflating) {\n        this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n      } else {\n        this.dispatch(data, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(data, {\n          [kByteLength]: byteLength,\n          fin: options.fin,\n          generateMask: this._generateMask,\n          mask: options.mask,\n          maskBuffer: this._maskBuffer,\n          opcode,\n          readOnly,\n          rsv1: false\n        }),\n        cb\n      );\n    }\n  }\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n    const perMessageDeflate = this._extensions[PerMessageDeflate$2.extensionName];\n    this._bufferedBytes += options[kByteLength];\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          \"The socket was closed while data was being compressed\"\n        );\n        if (typeof cb === \"function\")\n          cb(err);\n        for (let i = 0; i < this._queue.length; i++) {\n          const params = this._queue[i];\n          const callback = params[params.length - 1];\n          if (typeof callback === \"function\")\n            callback(err);\n        }\n        return;\n      }\n      this._bufferedBytes -= options[kByteLength];\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n};\nvar sender = Sender$1;\nconst sender$1 = /* @__PURE__ */ getDefaultExportFromCjs(sender);\nconst { kForOnEventAttribute: kForOnEventAttribute$1, kListener: kListener$1 } = constants;\nconst kCode = Symbol(\"kCode\");\nconst kData = Symbol(\"kData\");\nconst kError = Symbol(\"kError\");\nconst kMessage = Symbol(\"kMessage\");\nconst kReason = Symbol(\"kReason\");\nconst kTarget = Symbol(\"kTarget\");\nconst kType = Symbol(\"kType\");\nconst kWasClean = Symbol(\"kWasClean\");\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\nObject.defineProperty(Event.prototype, \"target\", { enumerable: true });\nObject.defineProperty(Event.prototype, \"type\", { enumerable: true });\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kCode] = options.code === void 0 ? 0 : options.code;\n    this[kReason] = options.reason === void 0 ? \"\" : options.reason;\n    this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;\n  }\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\nObject.defineProperty(CloseEvent.prototype, \"code\", { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, \"reason\", { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, \"wasClean\", { enumerable: true });\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kError] = options.error === void 0 ? null : options.error;\n    this[kMessage] = options.message === void 0 ? \"\" : options.message;\n  }\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\nObject.defineProperty(ErrorEvent.prototype, \"error\", { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, \"message\", { enumerable: true });\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n    this[kData] = options.data === void 0 ? null : options.data;\n  }\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\nObject.defineProperty(MessageEvent.prototype, \"data\", { enumerable: true });\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (!options[kForOnEventAttribute$1] && listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {\n        return;\n      }\n    }\n    let wrapper;\n    if (type === \"message\") {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent(\"message\", {\n          data: isBinary ? data : data.toString()\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === \"close\") {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent(\"close\", {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === \"error\") {\n      wrapper = function onError(error2) {\n        const event = new ErrorEvent(\"error\", {\n          error: error2,\n          message: error2.message\n        });\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === \"open\") {\n      wrapper = function onOpen() {\n        const event = new Event(\"open\");\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n    wrapper[kForOnEventAttribute$1] = !!options[kForOnEventAttribute$1];\n    wrapper[kListener$1] = handler;\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener$1] === handler && !listener[kForOnEventAttribute$1]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\nvar eventTarget = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === \"object\" && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}\nconst { tokenChars: tokenChars$1 } = validationExports;\nfunction push(dest, name, elem) {\n  if (dest[name] === void 0)\n    dest[name] = [elem];\n  else\n    dest[name].push(elem);\n}\nfunction parse$2(header) {\n  const offers = /* @__PURE__ */ Object.create(null);\n  let params = /* @__PURE__ */ Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n    if (extensionName === void 0) {\n      if (end === -1 && tokenChars$1[code] === 1) {\n        if (start === -1)\n          start = i;\n      } else if (i !== 0 && (code === 32 || code === 9)) {\n        if (end === -1 && start !== -1)\n          end = i;\n      } else if (code === 59 || code === 44) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1)\n          end = i;\n        const name = header.slice(start, end);\n        if (code === 44) {\n          push(offers, name, params);\n          params = /* @__PURE__ */ Object.create(null);\n        } else {\n          extensionName = name;\n        }\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === void 0) {\n      if (end === -1 && tokenChars$1[code] === 1) {\n        if (start === -1)\n          start = i;\n      } else if (code === 32 || code === 9) {\n        if (end === -1 && start !== -1)\n          end = i;\n      } else if (code === 59 || code === 44) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1)\n          end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 44) {\n          push(offers, extensionName, params);\n          params = /* @__PURE__ */ Object.create(null);\n          extensionName = void 0;\n        }\n        start = end = -1;\n      } else if (code === 61 && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      if (isEscaping) {\n        if (tokenChars$1[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1)\n          start = i;\n        else if (!mustUnescape)\n          mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars$1[code] === 1) {\n          if (start === -1)\n            start = i;\n        } else if (code === 34 && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 92) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 34 && header.charCodeAt(i - 1) === 61) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars$1[code] === 1) {\n        if (start === -1)\n          start = i;\n      } else if (start !== -1 && (code === 32 || code === 9)) {\n        if (end === -1)\n          end = i;\n      } else if (code === 59 || code === 44) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (end === -1)\n          end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, \"\");\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 44) {\n          push(offers, extensionName, params);\n          params = /* @__PURE__ */ Object.create(null);\n          extensionName = void 0;\n        }\n        paramName = void 0;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n  if (start === -1 || inQuotes || code === 32 || code === 9) {\n    throw new SyntaxError(\"Unexpected end of input\");\n  }\n  if (end === -1)\n    end = i;\n  const token = header.slice(start, end);\n  if (extensionName === void 0) {\n    push(offers, token, params);\n  } else {\n    if (paramName === void 0) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, \"\"));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n  return offers;\n}\nfunction format$1(extensions) {\n  return Object.keys(extensions).map((extension2) => {\n    let configurations = extensions[extension2];\n    if (!Array.isArray(configurations))\n      configurations = [configurations];\n    return configurations.map((params) => {\n      return [extension2].concat(\n        Object.keys(params).map((k) => {\n          let values = params[k];\n          if (!Array.isArray(values))\n            values = [values];\n          return values.map((v) => v === true ? k : `${k}=${v}`).join(\"; \");\n        })\n      ).join(\"; \");\n    }).join(\", \");\n  }).join(\", \");\n}\nvar extension$1 = { format: format$1, parse: parse$2 };\nconst EventEmitter$1 = require$$0$4;\nconst https = require$$1$2;\nconst http$1 = require$$2$1;\nconst net = require$$3;\nconst tls = require$$4;\nconst { randomBytes, createHash: createHash$1 } = require$$5;\nconst { URL } = require$$7;\nconst PerMessageDeflate$1 = permessageDeflate;\nconst Receiver2 = receiver;\nconst Sender2 = sender;\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID: GUID$1,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket: kWebSocket$1,\n  NOOP\n} = constants;\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = eventTarget;\nconst { format, parse: parse$1 } = extension$1;\nconst { toBuffer } = bufferUtilExports;\nconst closeTimeout = 30 * 1e3;\nconst kAborted = Symbol(\"kAborted\");\nconst protocolVersions = [8, 13];\nconst readyStates = [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\nlet WebSocket$1 = class WebSocket extends EventEmitter$1 {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = \"\";\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n      if (protocols === void 0) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === \"object\" && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type))\n      return;\n    this._binaryType = type;\n    if (this._receiver)\n      this._receiver._binaryType = type;\n  }\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket)\n      return this._bufferedAmount;\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver2 = new Receiver2({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n    this._sender = new Sender2(socket, this._extensions, options.generateMask);\n    this._receiver = receiver2;\n    this._socket = socket;\n    receiver2[kWebSocket$1] = this;\n    socket[kWebSocket$1] = this;\n    receiver2.on(\"conclude\", receiverOnConclude);\n    receiver2.on(\"drain\", receiverOnDrain);\n    receiver2.on(\"error\", receiverOnError);\n    receiver2.on(\"message\", receiverOnMessage);\n    receiver2.on(\"ping\", receiverOnPing);\n    receiver2.on(\"pong\", receiverOnPong);\n    socket.setTimeout(0);\n    socket.setNoDelay();\n    if (head.length > 0)\n      socket.unshift(head);\n    socket.on(\"close\", socketOnClose);\n    socket.on(\"data\", socketOnData);\n    socket.on(\"end\", socketOnEnd);\n    socket.on(\"error\", socketOnError$1);\n    this._readyState = WebSocket.OPEN;\n    this.emit(\"open\");\n  }\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit(\"close\", this._closeCode, this._closeMessage);\n      return;\n    }\n    if (this._extensions[PerMessageDeflate$1.extensionName]) {\n      this._extensions[PerMessageDeflate$1.extensionName].cleanup();\n    }\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit(\"close\", this._closeCode, this._closeMessage);\n  }\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED)\n      return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = \"WebSocket was closed before the connection was established\";\n      abortHandshake$1(this, this._req, msg);\n      return;\n    }\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n        this._socket.end();\n      }\n      return;\n    }\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      if (err)\n        return;\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n        this._socket.end();\n      }\n    });\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = true;\n    this._socket.pause();\n  }\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask2, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n    }\n    if (typeof data === \"function\") {\n      cb = data;\n      data = mask2 = void 0;\n    } else if (typeof mask2 === \"function\") {\n      cb = mask2;\n      mask2 = void 0;\n    }\n    if (typeof data === \"number\")\n      data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask2 === void 0)\n      mask2 = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask2, cb);\n  }\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask2, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n    }\n    if (typeof data === \"function\") {\n      cb = data;\n      data = mask2 = void 0;\n    } else if (typeof mask2 === \"function\") {\n      cb = mask2;\n      mask2 = void 0;\n    }\n    if (typeof data === \"number\")\n      data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask2 === void 0)\n      mask2 = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask2, cb);\n  }\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain)\n      this._socket.resume();\n  }\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n    }\n    if (typeof options === \"function\") {\n      cb = options;\n      options = {};\n    }\n    if (typeof data === \"number\")\n      data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    const opts = {\n      binary: typeof data !== \"string\",\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n    if (!this._extensions[PerMessageDeflate$1.extensionName]) {\n      opts.compress = false;\n    }\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED)\n      return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = \"WebSocket was closed before the connection was established\";\n      abortHandshake$1(this, this._req, msg);\n      return;\n    }\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n};\nObject.defineProperty(WebSocket$1, \"CONNECTING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"CONNECTING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CONNECTING\")\n});\nObject.defineProperty(WebSocket$1, \"OPEN\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"OPEN\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"OPEN\")\n});\nObject.defineProperty(WebSocket$1, \"CLOSING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"CLOSING\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSING\")\n});\nObject.defineProperty(WebSocket$1, \"CLOSED\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSED\")\n});\nObject.defineProperty(WebSocket$1.prototype, \"CLOSED\", {\n  enumerable: true,\n  value: readyStates.indexOf(\"CLOSED\")\n});\n[\n  \"binaryType\",\n  \"bufferedAmount\",\n  \"extensions\",\n  \"isPaused\",\n  \"protocol\",\n  \"readyState\",\n  \"url\"\n].forEach((property) => {\n  Object.defineProperty(WebSocket$1.prototype, property, { enumerable: true });\n});\n[\"open\", \"error\", \"close\", \"message\"].forEach((method) => {\n  Object.defineProperty(WebSocket$1.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute])\n          return listener[kListener];\n      }\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n      if (typeof handler !== \"function\")\n        return;\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\nWebSocket$1.prototype.addEventListener = addEventListener;\nWebSocket$1.prototype.removeEventListener = removeEventListener;\nvar websocket = WebSocket$1;\nfunction initAsClient(websocket2, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: void 0,\n    socketPath: void 0,\n    hostname: void 0,\n    protocol: void 0,\n    timeout: void 0,\n    method: \"GET\",\n    host: void 0,\n    path: void 0,\n    port: void 0\n  };\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(\", \")})`\n    );\n  }\n  let parsedUrl;\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket2._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n    websocket2._url = address;\n  }\n  const isSecure = parsedUrl.protocol === \"wss:\";\n  const isIpcUrl = parsedUrl.protocol === \"ws+unix:\";\n  let invalidUrlMessage;\n  if (parsedUrl.protocol !== \"ws:\" && !isSecure && !isIpcUrl) {\n    invalidUrlMessage = `The URL's protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"`;\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = \"The URL contains a fragment identifier\";\n  }\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n    if (websocket2._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket2, err);\n      return;\n    }\n  }\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString(\"base64\");\n  const request = isSecure ? https.request : http$1.request;\n  const protocolSet = /* @__PURE__ */ new Set();\n  let perMessageDeflate;\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith(\"[\") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    \"Sec-WebSocket-Version\": opts.protocolVersion,\n    \"Sec-WebSocket-Key\": key,\n    Connection: \"Upgrade\",\n    Upgrade: \"websocket\"\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate$1(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers[\"Sec-WebSocket-Extensions\"] = format({\n      [PerMessageDeflate$1.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (typeof protocol !== \"string\" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n        throw new SyntaxError(\n          \"An invalid or duplicated subprotocol was specified\"\n        );\n      }\n      protocolSet.add(protocol);\n    }\n    opts.headers[\"Sec-WebSocket-Protocol\"] = protocols.join(\",\");\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers[\"Sec-WebSocket-Origin\"] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n  if (isIpcUrl) {\n    const parts = opts.path.split(\":\");\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n  let req;\n  if (opts.followRedirects) {\n    if (websocket2._redirects === 0) {\n      websocket2._originalIpc = isIpcUrl;\n      websocket2._originalSecure = isSecure;\n      websocket2._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n      const headers = options && options.headers;\n      options = { ...options, headers: {} };\n      if (headers) {\n        for (const [key2, value] of Object.entries(headers)) {\n          options.headers[key2.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket2.listenerCount(\"redirect\") === 0) {\n      const isSameHost = isIpcUrl ? websocket2._originalIpc ? opts.socketPath === websocket2._originalHostOrSocketPath : false : websocket2._originalIpc ? false : parsedUrl.host === websocket2._originalHostOrSocketPath;\n      if (!isSameHost || websocket2._originalSecure && !isSecure) {\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n        if (!isSameHost)\n          delete opts.headers.host;\n        opts.auth = void 0;\n      }\n    }\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization = \"Basic \" + Buffer.from(opts.auth).toString(\"base64\");\n    }\n    req = websocket2._req = request(opts);\n    if (websocket2._redirects) {\n      websocket2.emit(\"redirect\", websocket2.url, req);\n    }\n  } else {\n    req = websocket2._req = request(opts);\n  }\n  if (opts.timeout) {\n    req.on(\"timeout\", () => {\n      abortHandshake$1(websocket2, req, \"Opening handshake has timed out\");\n    });\n  }\n  req.on(\"error\", (err) => {\n    if (req === null || req[kAborted])\n      return;\n    req = websocket2._req = null;\n    emitErrorAndClose(websocket2, err);\n  });\n  req.on(\"response\", (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n      if (++websocket2._redirects > opts.maxRedirects) {\n        abortHandshake$1(websocket2, req, \"Maximum redirects exceeded\");\n        return;\n      }\n      req.abort();\n      let addr;\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket2, err);\n        return;\n      }\n      initAsClient(websocket2, addr, protocols, options);\n    } else if (!websocket2.emit(\"unexpected-response\", req, res)) {\n      abortHandshake$1(\n        websocket2,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n  req.on(\"upgrade\", (res, socket, head) => {\n    websocket2.emit(\"upgrade\", res);\n    if (websocket2.readyState !== WebSocket$1.CONNECTING)\n      return;\n    req = websocket2._req = null;\n    if (res.headers.upgrade.toLowerCase() !== \"websocket\") {\n      abortHandshake$1(websocket2, socket, \"Invalid Upgrade header\");\n      return;\n    }\n    const digest = createHash$1(\"sha1\").update(key + GUID$1).digest(\"base64\");\n    if (res.headers[\"sec-websocket-accept\"] !== digest) {\n      abortHandshake$1(websocket2, socket, \"Invalid Sec-WebSocket-Accept header\");\n      return;\n    }\n    const serverProt = res.headers[\"sec-websocket-protocol\"];\n    let protError;\n    if (serverProt !== void 0) {\n      if (!protocolSet.size) {\n        protError = \"Server sent a subprotocol but none was requested\";\n      } else if (!protocolSet.has(serverProt)) {\n        protError = \"Server sent an invalid subprotocol\";\n      }\n    } else if (protocolSet.size) {\n      protError = \"Server sent no subprotocol\";\n    }\n    if (protError) {\n      abortHandshake$1(websocket2, socket, protError);\n      return;\n    }\n    if (serverProt)\n      websocket2._protocol = serverProt;\n    const secWebSocketExtensions = res.headers[\"sec-websocket-extensions\"];\n    if (secWebSocketExtensions !== void 0) {\n      if (!perMessageDeflate) {\n        const message = \"Server sent a Sec-WebSocket-Extensions header but no extension was requested\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      let extensions;\n      try {\n        extensions = parse$1(secWebSocketExtensions);\n      } catch (err) {\n        const message = \"Invalid Sec-WebSocket-Extensions header\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      const extensionNames = Object.keys(extensions);\n      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate$1.extensionName) {\n        const message = \"Server indicated an extension that was not requested\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate$1.extensionName]);\n      } catch (err) {\n        const message = \"Invalid Sec-WebSocket-Extensions header\";\n        abortHandshake$1(websocket2, socket, message);\n        return;\n      }\n      websocket2._extensions[PerMessageDeflate$1.extensionName] = perMessageDeflate;\n    }\n    websocket2.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket2);\n  } else {\n    req.end();\n  }\n}\nfunction emitErrorAndClose(websocket2, err) {\n  websocket2._readyState = WebSocket$1.CLOSING;\n  websocket2.emit(\"error\", err);\n  websocket2.emitClose();\n}\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\nfunction tlsConnect(options) {\n  options.path = void 0;\n  if (!options.servername && options.servername !== \"\") {\n    options.servername = net.isIP(options.host) ? \"\" : options.host;\n  }\n  return tls.connect(options);\n}\nfunction abortHandshake$1(websocket2, stream2, message) {\n  websocket2._readyState = WebSocket$1.CLOSING;\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake$1);\n  if (stream2.setHeader) {\n    stream2[kAborted] = true;\n    stream2.abort();\n    if (stream2.socket && !stream2.socket.destroyed) {\n      stream2.socket.destroy();\n    }\n    process.nextTick(emitErrorAndClose, websocket2, err);\n  } else {\n    stream2.destroy(err);\n    stream2.once(\"error\", websocket2.emit.bind(websocket2, \"error\"));\n    stream2.once(\"close\", websocket2.emitClose.bind(websocket2));\n  }\n}\nfunction sendAfterClose(websocket2, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n    if (websocket2._socket)\n      websocket2._sender._bufferedBytes += length;\n    else\n      websocket2._bufferedAmount += length;\n  }\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket2.readyState} (${readyStates[websocket2.readyState]})`\n    );\n    process.nextTick(cb, err);\n  }\n}\nfunction receiverOnConclude(code, reason) {\n  const websocket2 = this[kWebSocket$1];\n  websocket2._closeFrameReceived = true;\n  websocket2._closeMessage = reason;\n  websocket2._closeCode = code;\n  if (websocket2._socket[kWebSocket$1] === void 0)\n    return;\n  websocket2._socket.removeListener(\"data\", socketOnData);\n  process.nextTick(resume, websocket2._socket);\n  if (code === 1005)\n    websocket2.close();\n  else\n    websocket2.close(code, reason);\n}\nfunction receiverOnDrain() {\n  const websocket2 = this[kWebSocket$1];\n  if (!websocket2.isPaused)\n    websocket2._socket.resume();\n}\nfunction receiverOnError(err) {\n  const websocket2 = this[kWebSocket$1];\n  if (websocket2._socket[kWebSocket$1] !== void 0) {\n    websocket2._socket.removeListener(\"data\", socketOnData);\n    process.nextTick(resume, websocket2._socket);\n    websocket2.close(err[kStatusCode]);\n  }\n  websocket2.emit(\"error\", err);\n}\nfunction receiverOnFinish() {\n  this[kWebSocket$1].emitClose();\n}\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket$1].emit(\"message\", data, isBinary);\n}\nfunction receiverOnPing(data) {\n  const websocket2 = this[kWebSocket$1];\n  websocket2.pong(data, !websocket2._isServer, NOOP);\n  websocket2.emit(\"ping\", data);\n}\nfunction receiverOnPong(data) {\n  this[kWebSocket$1].emit(\"pong\", data);\n}\nfunction resume(stream2) {\n  stream2.resume();\n}\nfunction socketOnClose() {\n  const websocket2 = this[kWebSocket$1];\n  this.removeListener(\"close\", socketOnClose);\n  this.removeListener(\"data\", socketOnData);\n  this.removeListener(\"end\", socketOnEnd);\n  websocket2._readyState = WebSocket$1.CLOSING;\n  let chunk;\n  if (!this._readableState.endEmitted && !websocket2._closeFrameReceived && !websocket2._receiver._writableState.errorEmitted && (chunk = websocket2._socket.read()) !== null) {\n    websocket2._receiver.write(chunk);\n  }\n  websocket2._receiver.end();\n  this[kWebSocket$1] = void 0;\n  clearTimeout(websocket2._closeTimer);\n  if (websocket2._receiver._writableState.finished || websocket2._receiver._writableState.errorEmitted) {\n    websocket2.emitClose();\n  } else {\n    websocket2._receiver.on(\"error\", receiverOnFinish);\n    websocket2._receiver.on(\"finish\", receiverOnFinish);\n  }\n}\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket$1]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\nfunction socketOnEnd() {\n  const websocket2 = this[kWebSocket$1];\n  websocket2._readyState = WebSocket$1.CLOSING;\n  websocket2._receiver.end();\n  this.end();\n}\nfunction socketOnError$1() {\n  const websocket2 = this[kWebSocket$1];\n  this.removeListener(\"error\", socketOnError$1);\n  this.on(\"error\", NOOP);\n  if (websocket2) {\n    websocket2._readyState = WebSocket$1.CLOSING;\n    this.destroy();\n  }\n}\nconst WebSocket$2 = /* @__PURE__ */ getDefaultExportFromCjs(websocket);\nconst { tokenChars } = validationExports;\nfunction parse(header) {\n  const protocols = /* @__PURE__ */ new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1)\n        start = i;\n    } else if (i !== 0 && (code === 32 || code === 9)) {\n      if (end === -1 && start !== -1)\n        end = i;\n    } else if (code === 44) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n      if (end === -1)\n        end = i;\n      const protocol2 = header.slice(start, end);\n      if (protocols.has(protocol2)) {\n        throw new SyntaxError(`The \"${protocol2}\" subprotocol is duplicated`);\n      }\n      protocols.add(protocol2);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError(\"Unexpected end of input\");\n  }\n  const protocol = header.slice(start, i);\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n  protocols.add(protocol);\n  return protocols;\n}\nvar subprotocol$1 = { parse };\nconst EventEmitter = require$$0$4;\nconst http = require$$2$1;\nconst { createHash } = require$$5;\nconst extension = extension$1;\nconst PerMessageDeflate2 = permessageDeflate;\nconst subprotocol = subprotocol$1;\nconst WebSocket2 = websocket;\nconst { GUID, kWebSocket } = constants;\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null,\n      // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket: WebSocket2,\n      ...options\n    };\n    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options must be specified'\n      );\n    }\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n        res.writeHead(426, {\n          \"Content-Length\": body.length,\n          \"Content-Type\": \"text/plain\"\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, \"connection\");\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, \"listening\"),\n        error: this.emit.bind(this, \"error\"),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n    if (options.perMessageDeflate === true)\n      options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = /* @__PURE__ */ new Set();\n      this._shouldEmitClose = false;\n    }\n    this.options = options;\n    this._state = RUNNING;\n  }\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n    if (!this._server)\n      return null;\n    return this._server.address();\n  }\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once(\"close\", () => {\n          cb(new Error(\"The server is not running\"));\n        });\n      }\n      process.nextTick(emitClose, this);\n      return;\n    }\n    if (cb)\n      this.once(\"close\", cb);\n    if (this._state === CLOSING)\n      return;\n    this._state = CLOSING;\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf(\"?\");\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n      if (pathname !== this.options.path)\n        return false;\n    }\n    return true;\n  }\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on(\"error\", socketOnError);\n    const key = req.headers[\"sec-websocket-key\"];\n    const version = +req.headers[\"sec-websocket-version\"];\n    if (req.method !== \"GET\") {\n      const message = \"Invalid HTTP method\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n    if (req.headers.upgrade.toLowerCase() !== \"websocket\") {\n      const message = \"Invalid Upgrade header\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (!key || !keyRegex.test(key)) {\n      const message = \"Missing or invalid Sec-WebSocket-Key header\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (version !== 8 && version !== 13) {\n      const message = \"Missing or invalid Sec-WebSocket-Version header\";\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n    const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\n    let protocols = /* @__PURE__ */ new Set();\n    if (secWebSocketProtocol !== void 0) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = \"Invalid Sec-WebSocket-Protocol header\";\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n    const secWebSocketExtensions = req.headers[\"sec-websocket-extensions\"];\n    const extensions = {};\n    if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {\n      const perMessageDeflate = new PerMessageDeflate2(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n        if (offers[PerMessageDeflate2.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate2.extensionName]);\n          extensions[PerMessageDeflate2.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message = \"Invalid or unacceptable Sec-WebSocket-Extensions header\";\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n    if (this.options.verifyClient) {\n      const info = {\n        origin: req.headers[`${version === 8 ? \"sec-websocket-origin\" : \"origin\"}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n      if (!this.options.verifyClient(info))\n        return abortHandshake(socket, 401);\n    }\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    if (!socket.readable || !socket.writable)\n      return socket.destroy();\n    if (socket[kWebSocket]) {\n      throw new Error(\n        \"server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration\"\n      );\n    }\n    if (this._state > RUNNING)\n      return abortHandshake(socket, 503);\n    const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n    const headers = [\n      \"HTTP/1.1 101 Switching Protocols\",\n      \"Upgrade: websocket\",\n      \"Connection: Upgrade\",\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n    const ws = new this.options.WebSocket(null);\n    if (protocols.size) {\n      const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n    if (extensions[PerMessageDeflate2.extensionName]) {\n      const params = extensions[PerMessageDeflate2.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate2.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n    this.emit(\"headers\", headers, req);\n    socket.write(headers.concat(\"\\r\\n\").join(\"\\r\\n\"));\n    socket.removeListener(\"error\", socketOnError);\n    ws.setSocket(socket, head, {\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on(\"close\", () => {\n        this.clients.delete(ws);\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n    cb(ws, req);\n  }\n}\nvar websocketServer = WebSocketServer;\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map))\n    server.on(event, map[event]);\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit(\"close\");\n}\nfunction socketOnError() {\n  this.destroy();\n}\nfunction abortHandshake(socket, code, message, headers) {\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: \"close\",\n    \"Content-Type\": \"text/html\",\n    \"Content-Length\": Buffer.byteLength(message),\n    ...headers\n  };\n  socket.once(\"finish\", socket.destroy);\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\n` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join(\"\\r\\n\") + \"\\r\\n\\r\\n\" + message\n  );\n}\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount(\"wsClientError\")) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n    server.emit(\"wsClientError\", err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}\nconst websocketServer$1 = /* @__PURE__ */ getDefaultExportFromCjs(websocketServer);\nexport {\n  receiver$1 as Receiver,\n  sender$1 as Sender,\n  WebSocket$2 as WebSocket,\n  websocketServer$1 as WebSocketServer,\n  stream$1 as createWebSocketStream,\n  WebSocket$2 as default\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}