{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\nconst {\n  makePathsRelative\n} = require(\"../util/identifier\");\nconst numberHash = require(\"../util/numberHash\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n\n/**\n * @param {string} str string to hash\n * @param {number} len max length of the hash\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nconst getHash = (str, len, hashFunction) => {\n  const hash = createHash(hashFunction);\n  hash.update(str);\n  const digest = /** @type {string} */hash.digest(\"hex\");\n  return digest.slice(0, len);\n};\n\n/**\n * @param {string} str the string\n * @returns {string} string prefixed by an underscore if it is a number\n */\nconst avoidNumber = str => {\n  // max length of a number is 21 chars, bigger numbers a written as \"...e+xx\"\n  if (str.length > 21) return str;\n  const firstChar = str.charCodeAt(0);\n  // skip everything that doesn't look like a number\n  // charCodes: \"-\": 45, \"1\": 49, \"9\": 57\n  if (firstChar < 49) {\n    if (firstChar !== 45) return str;\n  } else if (firstChar > 57) {\n    return str;\n  }\n  if (str === String(Number(str))) {\n    return `_${str}`;\n  }\n  return str;\n};\n\n/**\n * @param {string} request the request\n * @returns {string} id representation\n */\nconst requestToId = request => request.replace(/^(\\.\\.?\\/)+/, \"\").replace(/(^[.-]|[^a-zA-Z0-9_-])+/g, \"_\");\nmodule.exports.requestToId = requestToId;\n\n/**\n * @param {string} string the string\n * @param {string} delimiter separator for string and hash\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} string with limited max length to 100 chars\n */\nconst shortenLongString = (string, delimiter, hashFunction) => {\n  if (string.length < 100) return string;\n  return string.slice(0, 100 - 6 - delimiter.length) + delimiter + getHash(string, 6, hashFunction);\n};\n\n/**\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short module name\n */\nconst getShortModuleName = (module, context, associatedObjectForCache) => {\n  const libIdent = module.libIdent({\n    context,\n    associatedObjectForCache\n  });\n  if (libIdent) return avoidNumber(libIdent);\n  const nameForCondition = module.nameForCondition();\n  if (nameForCondition) return avoidNumber(makePathsRelative(context, nameForCondition, associatedObjectForCache));\n  return \"\";\n};\nmodule.exports.getShortModuleName = getShortModuleName;\n\n/**\n * @param {string} shortName the short name\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {string | Hash} hashFunction hash function to use\n * @param {object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} long module name\n */\nconst getLongModuleName = (shortName, module, context, hashFunction, associatedObjectForCache) => {\n  const fullName = getFullModuleName(module, context, associatedObjectForCache);\n  return `${shortName}?${getHash(fullName, 4, hashFunction)}`;\n};\nmodule.exports.getLongModuleName = getLongModuleName;\n\n/**\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} full module name\n */\nconst getFullModuleName = (module, context, associatedObjectForCache) => makePathsRelative(context, module.identifier(), associatedObjectForCache);\nmodule.exports.getFullModuleName = getFullModuleName;\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {string} delimiter delimiter for names\n * @param {string | Hash} hashFunction hash function to use\n * @param {object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short chunk name\n */\nconst getShortChunkName = (chunk, chunkGraph, context, delimiter, hashFunction, associatedObjectForCache) => {\n  const modules = chunkGraph.getChunkRootModules(chunk);\n  const shortModuleNames = modules.map(m => requestToId(getShortModuleName(m, context, associatedObjectForCache)));\n  chunk.idNameHints.sort();\n  const chunkName = Array.from(chunk.idNameHints).concat(shortModuleNames).filter(Boolean).join(delimiter);\n  return shortenLongString(chunkName, delimiter, hashFunction);\n};\nmodule.exports.getShortChunkName = getShortChunkName;\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {string} delimiter delimiter for names\n * @param {string | Hash} hashFunction hash function to use\n * @param {object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short chunk name\n */\nconst getLongChunkName = (chunk, chunkGraph, context, delimiter, hashFunction, associatedObjectForCache) => {\n  const modules = chunkGraph.getChunkRootModules(chunk);\n  const shortModuleNames = modules.map(m => requestToId(getShortModuleName(m, context, associatedObjectForCache)));\n  const longModuleNames = modules.map(m => requestToId(getLongModuleName(\"\", m, context, hashFunction, associatedObjectForCache)));\n  chunk.idNameHints.sort();\n  const chunkName = Array.from(chunk.idNameHints).concat(shortModuleNames, longModuleNames).filter(Boolean).join(delimiter);\n  return shortenLongString(chunkName, delimiter, hashFunction);\n};\nmodule.exports.getLongChunkName = getLongChunkName;\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} full chunk name\n */\nconst getFullChunkName = (chunk, chunkGraph, context, associatedObjectForCache) => {\n  if (chunk.name) return chunk.name;\n  const modules = chunkGraph.getChunkRootModules(chunk);\n  const fullModuleNames = modules.map(m => makePathsRelative(context, m.identifier(), associatedObjectForCache));\n  return fullModuleNames.join();\n};\nmodule.exports.getFullChunkName = getFullChunkName;\n\n/**\n * @template K\n * @template V\n * @param {Map<K, V[]>} map a map from key to values\n * @param {K} key key\n * @param {V} value value\n * @returns {void}\n */\nconst addToMapOfItems = (map, key, value) => {\n  let array = map.get(key);\n  if (array === undefined) {\n    array = [];\n    map.set(key, array);\n  }\n  array.push(value);\n};\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {function(Module): boolean=} filter filter modules\n * @returns {[Set<string>, Module[]]} used module ids as strings and modules without id matching the filter\n */\nconst getUsedModuleIdsAndModules = (compilation, filter) => {\n  const chunkGraph = compilation.chunkGraph;\n  const modules = [];\n\n  /** @type {Set<string>} */\n  const usedIds = new Set();\n  if (compilation.usedModuleIds) {\n    for (const id of compilation.usedModuleIds) {\n      usedIds.add(String(id));\n    }\n  }\n  for (const module of compilation.modules) {\n    if (!module.needId) continue;\n    const moduleId = chunkGraph.getModuleId(module);\n    if (moduleId !== null) {\n      usedIds.add(String(moduleId));\n    } else if ((!filter || filter(module)) && chunkGraph.getNumberOfModuleChunks(module) !== 0) {\n      modules.push(module);\n    }\n  }\n  return [usedIds, modules];\n};\nmodule.exports.getUsedModuleIdsAndModules = getUsedModuleIdsAndModules;\n\n/**\n * @param {Compilation} compilation the compilation\n * @returns {Set<string>} used chunk ids as strings\n */\nconst getUsedChunkIds = compilation => {\n  /** @type {Set<string>} */\n  const usedIds = new Set();\n  if (compilation.usedChunkIds) {\n    for (const id of compilation.usedChunkIds) {\n      usedIds.add(String(id));\n    }\n  }\n  for (const chunk of compilation.chunks) {\n    const chunkId = chunk.id;\n    if (chunkId !== null) {\n      usedIds.add(String(chunkId));\n    }\n  }\n  return usedIds;\n};\nmodule.exports.getUsedChunkIds = getUsedChunkIds;\n\n/**\n * @template T\n * @param {Iterable<T>} items list of items to be named\n * @param {function(T): string} getShortName get a short name for an item\n * @param {function(T, string): string} getLongName get a long name for an item\n * @param {function(T, T): -1|0|1} comparator order of items\n * @param {Set<string>} usedIds already used ids, will not be assigned\n * @param {function(T, string): void} assignName assign a name to an item\n * @returns {T[]} list of items without a name\n */\nconst assignNames = (items, getShortName, getLongName, comparator, usedIds, assignName) => {\n  /** @type {Map<string, T[]>} */\n  const nameToItems = new Map();\n  for (const item of items) {\n    const name = getShortName(item);\n    addToMapOfItems(nameToItems, name, item);\n  }\n\n  /** @type {Map<string, T[]>} */\n  const nameToItems2 = new Map();\n  for (const [name, items] of nameToItems) {\n    if (items.length > 1 || !name) {\n      for (const item of items) {\n        const longName = getLongName(item, name);\n        addToMapOfItems(nameToItems2, longName, item);\n      }\n    } else {\n      addToMapOfItems(nameToItems2, name, items[0]);\n    }\n  }\n\n  /** @type {T[]} */\n  const unnamedItems = [];\n  for (const [name, items] of nameToItems2) {\n    if (!name) {\n      for (const item of items) {\n        unnamedItems.push(item);\n      }\n    } else if (items.length === 1 && !usedIds.has(name)) {\n      assignName(items[0], name);\n      usedIds.add(name);\n    } else {\n      items.sort(comparator);\n      let i = 0;\n      for (const item of items) {\n        while (nameToItems2.has(name + i) && usedIds.has(name + i)) i++;\n        assignName(item, name + i);\n        usedIds.add(name + i);\n        i++;\n      }\n    }\n  }\n  unnamedItems.sort(comparator);\n  return unnamedItems;\n};\nmodule.exports.assignNames = assignNames;\n\n/**\n * @template T\n * @param {T[]} items list of items to be named\n * @param {function(T): string} getName get a name for an item\n * @param {function(T, T): -1|0|1} comparator order of items\n * @param {function(T, number): boolean} assignId assign an id to an item\n * @param {number[]} ranges usable ranges for ids\n * @param {number} expandFactor factor to create more ranges\n * @param {number} extraSpace extra space to allocate, i. e. when some ids are already used\n * @param {number} salt salting number to initialize hashing\n * @returns {void}\n */\nconst assignDeterministicIds = (items, getName, comparator, assignId, ranges = [10], expandFactor = 10, extraSpace = 0, salt = 0) => {\n  items.sort(comparator);\n\n  // max 5% fill rate\n  const optimalRange = Math.min(items.length * 20 + extraSpace, Number.MAX_SAFE_INTEGER);\n  let i = 0;\n  let range = ranges[i];\n  while (range < optimalRange) {\n    i++;\n    if (i < ranges.length) {\n      range = Math.min(ranges[i], Number.MAX_SAFE_INTEGER);\n    } else if (expandFactor) {\n      range = Math.min(range * expandFactor, Number.MAX_SAFE_INTEGER);\n    } else {\n      break;\n    }\n  }\n  for (const item of items) {\n    const ident = getName(item);\n    let id;\n    let i = salt;\n    do {\n      id = numberHash(ident + i++, range);\n    } while (!assignId(item, id));\n  }\n};\nmodule.exports.assignDeterministicIds = assignDeterministicIds;\n\n/**\n * @param {Set<string>} usedIds used ids\n * @param {Iterable<Module>} modules the modules\n * @param {Compilation} compilation the compilation\n * @returns {void}\n */\nconst assignAscendingModuleIds = (usedIds, modules, compilation) => {\n  const chunkGraph = compilation.chunkGraph;\n  let nextId = 0;\n  let assignId;\n  if (usedIds.size > 0) {\n    /**\n     * @param {Module} module the module\n     */\n    assignId = module => {\n      if (chunkGraph.getModuleId(module) === null) {\n        while (usedIds.has(String(nextId))) nextId++;\n        chunkGraph.setModuleId(module, nextId++);\n      }\n    };\n  } else {\n    /**\n     * @param {Module} module the module\n     */\n    assignId = module => {\n      if (chunkGraph.getModuleId(module) === null) {\n        chunkGraph.setModuleId(module, nextId++);\n      }\n    };\n  }\n  for (const module of modules) {\n    assignId(module);\n  }\n};\nmodule.exports.assignAscendingModuleIds = assignAscendingModuleIds;\n\n/**\n * @param {Iterable<Chunk>} chunks the chunks\n * @param {Compilation} compilation the compilation\n * @returns {void}\n */\nconst assignAscendingChunkIds = (chunks, compilation) => {\n  const usedIds = getUsedChunkIds(compilation);\n  let nextId = 0;\n  if (usedIds.size > 0) {\n    for (const chunk of chunks) {\n      if (chunk.id === null) {\n        while (usedIds.has(String(nextId))) nextId++;\n        chunk.id = nextId;\n        chunk.ids = [nextId];\n        nextId++;\n      }\n    }\n  } else {\n    for (const chunk of chunks) {\n      if (chunk.id === null) {\n        chunk.id = nextId;\n        chunk.ids = [nextId];\n        nextId++;\n      }\n    }\n  }\n};\nmodule.exports.assignAscendingChunkIds = assignAscendingChunkIds;","map":{"version":3,"names":["createHash","require","makePathsRelative","numberHash","getHash","str","len","hashFunction","hash","update","digest","slice","avoidNumber","length","firstChar","charCodeAt","String","Number","requestToId","request","replace","module","exports","shortenLongString","string","delimiter","getShortModuleName","context","associatedObjectForCache","libIdent","nameForCondition","getLongModuleName","shortName","fullName","getFullModuleName","identifier","getShortChunkName","chunk","chunkGraph","modules","getChunkRootModules","shortModuleNames","map","m","idNameHints","sort","chunkName","Array","from","concat","filter","Boolean","join","getLongChunkName","longModuleNames","getFullChunkName","name","fullModuleNames","addToMapOfItems","key","value","array","get","undefined","set","push","getUsedModuleIdsAndModules","compilation","usedIds","Set","usedModuleIds","id","add","needId","moduleId","getModuleId","getNumberOfModuleChunks","getUsedChunkIds","usedChunkIds","chunks","chunkId","assignNames","items","getShortName","getLongName","comparator","assignName","nameToItems","Map","item","nameToItems2","longName","unnamedItems","has","i","assignDeterministicIds","getName","assignId","ranges","expandFactor","extraSpace","salt","optimalRange","Math","min","MAX_SAFE_INTEGER","range","ident","assignAscendingModuleIds","nextId","size","setModuleId","assignAscendingChunkIds","ids"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/webpack/lib/ids/IdHelpers.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst createHash = require(\"../util/createHash\");\nconst { makePathsRelative } = require(\"../util/identifier\");\nconst numberHash = require(\"../util/numberHash\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {typeof import(\"../util/Hash\")} Hash */\n\n/**\n * @param {string} str string to hash\n * @param {number} len max length of the hash\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} hash\n */\nconst getHash = (str, len, hashFunction) => {\n\tconst hash = createHash(hashFunction);\n\thash.update(str);\n\tconst digest = /** @type {string} */ (hash.digest(\"hex\"));\n\treturn digest.slice(0, len);\n};\n\n/**\n * @param {string} str the string\n * @returns {string} string prefixed by an underscore if it is a number\n */\nconst avoidNumber = str => {\n\t// max length of a number is 21 chars, bigger numbers a written as \"...e+xx\"\n\tif (str.length > 21) return str;\n\tconst firstChar = str.charCodeAt(0);\n\t// skip everything that doesn't look like a number\n\t// charCodes: \"-\": 45, \"1\": 49, \"9\": 57\n\tif (firstChar < 49) {\n\t\tif (firstChar !== 45) return str;\n\t} else if (firstChar > 57) {\n\t\treturn str;\n\t}\n\tif (str === String(Number(str))) {\n\t\treturn `_${str}`;\n\t}\n\treturn str;\n};\n\n/**\n * @param {string} request the request\n * @returns {string} id representation\n */\nconst requestToId = request =>\n\trequest.replace(/^(\\.\\.?\\/)+/, \"\").replace(/(^[.-]|[^a-zA-Z0-9_-])+/g, \"_\");\nmodule.exports.requestToId = requestToId;\n\n/**\n * @param {string} string the string\n * @param {string} delimiter separator for string and hash\n * @param {string | Hash} hashFunction hash function to use\n * @returns {string} string with limited max length to 100 chars\n */\nconst shortenLongString = (string, delimiter, hashFunction) => {\n\tif (string.length < 100) return string;\n\treturn (\n\t\tstring.slice(0, 100 - 6 - delimiter.length) +\n\t\tdelimiter +\n\t\tgetHash(string, 6, hashFunction)\n\t);\n};\n\n/**\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short module name\n */\nconst getShortModuleName = (module, context, associatedObjectForCache) => {\n\tconst libIdent = module.libIdent({ context, associatedObjectForCache });\n\tif (libIdent) return avoidNumber(libIdent);\n\tconst nameForCondition = module.nameForCondition();\n\tif (nameForCondition)\n\t\treturn avoidNumber(\n\t\t\tmakePathsRelative(context, nameForCondition, associatedObjectForCache)\n\t\t);\n\treturn \"\";\n};\nmodule.exports.getShortModuleName = getShortModuleName;\n\n/**\n * @param {string} shortName the short name\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {string | Hash} hashFunction hash function to use\n * @param {object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} long module name\n */\nconst getLongModuleName = (\n\tshortName,\n\tmodule,\n\tcontext,\n\thashFunction,\n\tassociatedObjectForCache\n) => {\n\tconst fullName = getFullModuleName(module, context, associatedObjectForCache);\n\treturn `${shortName}?${getHash(fullName, 4, hashFunction)}`;\n};\nmodule.exports.getLongModuleName = getLongModuleName;\n\n/**\n * @param {Module} module the module\n * @param {string} context context directory\n * @param {object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} full module name\n */\nconst getFullModuleName = (module, context, associatedObjectForCache) =>\n\tmakePathsRelative(context, module.identifier(), associatedObjectForCache);\nmodule.exports.getFullModuleName = getFullModuleName;\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {string} delimiter delimiter for names\n * @param {string | Hash} hashFunction hash function to use\n * @param {object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short chunk name\n */\nconst getShortChunkName = (\n\tchunk,\n\tchunkGraph,\n\tcontext,\n\tdelimiter,\n\thashFunction,\n\tassociatedObjectForCache\n) => {\n\tconst modules = chunkGraph.getChunkRootModules(chunk);\n\tconst shortModuleNames = modules.map(m =>\n\t\trequestToId(getShortModuleName(m, context, associatedObjectForCache))\n\t);\n\tchunk.idNameHints.sort();\n\tconst chunkName = Array.from(chunk.idNameHints)\n\t\t.concat(shortModuleNames)\n\t\t.filter(Boolean)\n\t\t.join(delimiter);\n\treturn shortenLongString(chunkName, delimiter, hashFunction);\n};\nmodule.exports.getShortChunkName = getShortChunkName;\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {string} delimiter delimiter for names\n * @param {string | Hash} hashFunction hash function to use\n * @param {object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} short chunk name\n */\nconst getLongChunkName = (\n\tchunk,\n\tchunkGraph,\n\tcontext,\n\tdelimiter,\n\thashFunction,\n\tassociatedObjectForCache\n) => {\n\tconst modules = chunkGraph.getChunkRootModules(chunk);\n\tconst shortModuleNames = modules.map(m =>\n\t\trequestToId(getShortModuleName(m, context, associatedObjectForCache))\n\t);\n\tconst longModuleNames = modules.map(m =>\n\t\trequestToId(\n\t\t\tgetLongModuleName(\"\", m, context, hashFunction, associatedObjectForCache)\n\t\t)\n\t);\n\tchunk.idNameHints.sort();\n\tconst chunkName = Array.from(chunk.idNameHints)\n\t\t.concat(shortModuleNames, longModuleNames)\n\t\t.filter(Boolean)\n\t\t.join(delimiter);\n\treturn shortenLongString(chunkName, delimiter, hashFunction);\n};\nmodule.exports.getLongChunkName = getLongChunkName;\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {string} context context directory\n * @param {object=} associatedObjectForCache an object to which the cache will be attached\n * @returns {string} full chunk name\n */\nconst getFullChunkName = (\n\tchunk,\n\tchunkGraph,\n\tcontext,\n\tassociatedObjectForCache\n) => {\n\tif (chunk.name) return chunk.name;\n\tconst modules = chunkGraph.getChunkRootModules(chunk);\n\tconst fullModuleNames = modules.map(m =>\n\t\tmakePathsRelative(context, m.identifier(), associatedObjectForCache)\n\t);\n\treturn fullModuleNames.join();\n};\nmodule.exports.getFullChunkName = getFullChunkName;\n\n/**\n * @template K\n * @template V\n * @param {Map<K, V[]>} map a map from key to values\n * @param {K} key key\n * @param {V} value value\n * @returns {void}\n */\nconst addToMapOfItems = (map, key, value) => {\n\tlet array = map.get(key);\n\tif (array === undefined) {\n\t\tarray = [];\n\t\tmap.set(key, array);\n\t}\n\tarray.push(value);\n};\n\n/**\n * @param {Compilation} compilation the compilation\n * @param {function(Module): boolean=} filter filter modules\n * @returns {[Set<string>, Module[]]} used module ids as strings and modules without id matching the filter\n */\nconst getUsedModuleIdsAndModules = (compilation, filter) => {\n\tconst chunkGraph = compilation.chunkGraph;\n\n\tconst modules = [];\n\n\t/** @type {Set<string>} */\n\tconst usedIds = new Set();\n\tif (compilation.usedModuleIds) {\n\t\tfor (const id of compilation.usedModuleIds) {\n\t\t\tusedIds.add(String(id));\n\t\t}\n\t}\n\n\tfor (const module of compilation.modules) {\n\t\tif (!module.needId) continue;\n\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\tif (moduleId !== null) {\n\t\t\tusedIds.add(String(moduleId));\n\t\t} else if (\n\t\t\t(!filter || filter(module)) &&\n\t\t\tchunkGraph.getNumberOfModuleChunks(module) !== 0\n\t\t) {\n\t\t\tmodules.push(module);\n\t\t}\n\t}\n\n\treturn [usedIds, modules];\n};\nmodule.exports.getUsedModuleIdsAndModules = getUsedModuleIdsAndModules;\n\n/**\n * @param {Compilation} compilation the compilation\n * @returns {Set<string>} used chunk ids as strings\n */\nconst getUsedChunkIds = compilation => {\n\t/** @type {Set<string>} */\n\tconst usedIds = new Set();\n\tif (compilation.usedChunkIds) {\n\t\tfor (const id of compilation.usedChunkIds) {\n\t\t\tusedIds.add(String(id));\n\t\t}\n\t}\n\n\tfor (const chunk of compilation.chunks) {\n\t\tconst chunkId = chunk.id;\n\t\tif (chunkId !== null) {\n\t\t\tusedIds.add(String(chunkId));\n\t\t}\n\t}\n\n\treturn usedIds;\n};\nmodule.exports.getUsedChunkIds = getUsedChunkIds;\n\n/**\n * @template T\n * @param {Iterable<T>} items list of items to be named\n * @param {function(T): string} getShortName get a short name for an item\n * @param {function(T, string): string} getLongName get a long name for an item\n * @param {function(T, T): -1|0|1} comparator order of items\n * @param {Set<string>} usedIds already used ids, will not be assigned\n * @param {function(T, string): void} assignName assign a name to an item\n * @returns {T[]} list of items without a name\n */\nconst assignNames = (\n\titems,\n\tgetShortName,\n\tgetLongName,\n\tcomparator,\n\tusedIds,\n\tassignName\n) => {\n\t/** @type {Map<string, T[]>} */\n\tconst nameToItems = new Map();\n\n\tfor (const item of items) {\n\t\tconst name = getShortName(item);\n\t\taddToMapOfItems(nameToItems, name, item);\n\t}\n\n\t/** @type {Map<string, T[]>} */\n\tconst nameToItems2 = new Map();\n\n\tfor (const [name, items] of nameToItems) {\n\t\tif (items.length > 1 || !name) {\n\t\t\tfor (const item of items) {\n\t\t\t\tconst longName = getLongName(item, name);\n\t\t\t\taddToMapOfItems(nameToItems2, longName, item);\n\t\t\t}\n\t\t} else {\n\t\t\taddToMapOfItems(nameToItems2, name, items[0]);\n\t\t}\n\t}\n\n\t/** @type {T[]} */\n\tconst unnamedItems = [];\n\n\tfor (const [name, items] of nameToItems2) {\n\t\tif (!name) {\n\t\t\tfor (const item of items) {\n\t\t\t\tunnamedItems.push(item);\n\t\t\t}\n\t\t} else if (items.length === 1 && !usedIds.has(name)) {\n\t\t\tassignName(items[0], name);\n\t\t\tusedIds.add(name);\n\t\t} else {\n\t\t\titems.sort(comparator);\n\t\t\tlet i = 0;\n\t\t\tfor (const item of items) {\n\t\t\t\twhile (nameToItems2.has(name + i) && usedIds.has(name + i)) i++;\n\t\t\t\tassignName(item, name + i);\n\t\t\t\tusedIds.add(name + i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tunnamedItems.sort(comparator);\n\treturn unnamedItems;\n};\nmodule.exports.assignNames = assignNames;\n\n/**\n * @template T\n * @param {T[]} items list of items to be named\n * @param {function(T): string} getName get a name for an item\n * @param {function(T, T): -1|0|1} comparator order of items\n * @param {function(T, number): boolean} assignId assign an id to an item\n * @param {number[]} ranges usable ranges for ids\n * @param {number} expandFactor factor to create more ranges\n * @param {number} extraSpace extra space to allocate, i. e. when some ids are already used\n * @param {number} salt salting number to initialize hashing\n * @returns {void}\n */\nconst assignDeterministicIds = (\n\titems,\n\tgetName,\n\tcomparator,\n\tassignId,\n\tranges = [10],\n\texpandFactor = 10,\n\textraSpace = 0,\n\tsalt = 0\n) => {\n\titems.sort(comparator);\n\n\t// max 5% fill rate\n\tconst optimalRange = Math.min(\n\t\titems.length * 20 + extraSpace,\n\t\tNumber.MAX_SAFE_INTEGER\n\t);\n\n\tlet i = 0;\n\tlet range = ranges[i];\n\twhile (range < optimalRange) {\n\t\ti++;\n\t\tif (i < ranges.length) {\n\t\t\trange = Math.min(ranges[i], Number.MAX_SAFE_INTEGER);\n\t\t} else if (expandFactor) {\n\t\t\trange = Math.min(range * expandFactor, Number.MAX_SAFE_INTEGER);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfor (const item of items) {\n\t\tconst ident = getName(item);\n\t\tlet id;\n\t\tlet i = salt;\n\t\tdo {\n\t\t\tid = numberHash(ident + i++, range);\n\t\t} while (!assignId(item, id));\n\t}\n};\nmodule.exports.assignDeterministicIds = assignDeterministicIds;\n\n/**\n * @param {Set<string>} usedIds used ids\n * @param {Iterable<Module>} modules the modules\n * @param {Compilation} compilation the compilation\n * @returns {void}\n */\nconst assignAscendingModuleIds = (usedIds, modules, compilation) => {\n\tconst chunkGraph = compilation.chunkGraph;\n\n\tlet nextId = 0;\n\tlet assignId;\n\tif (usedIds.size > 0) {\n\t\t/**\n\t\t * @param {Module} module the module\n\t\t */\n\t\tassignId = module => {\n\t\t\tif (chunkGraph.getModuleId(module) === null) {\n\t\t\t\twhile (usedIds.has(String(nextId))) nextId++;\n\t\t\t\tchunkGraph.setModuleId(module, nextId++);\n\t\t\t}\n\t\t};\n\t} else {\n\t\t/**\n\t\t * @param {Module} module the module\n\t\t */\n\t\tassignId = module => {\n\t\t\tif (chunkGraph.getModuleId(module) === null) {\n\t\t\t\tchunkGraph.setModuleId(module, nextId++);\n\t\t\t}\n\t\t};\n\t}\n\tfor (const module of modules) {\n\t\tassignId(module);\n\t}\n};\nmodule.exports.assignAscendingModuleIds = assignAscendingModuleIds;\n\n/**\n * @param {Iterable<Chunk>} chunks the chunks\n * @param {Compilation} compilation the compilation\n * @returns {void}\n */\nconst assignAscendingChunkIds = (chunks, compilation) => {\n\tconst usedIds = getUsedChunkIds(compilation);\n\n\tlet nextId = 0;\n\tif (usedIds.size > 0) {\n\t\tfor (const chunk of chunks) {\n\t\t\tif (chunk.id === null) {\n\t\t\t\twhile (usedIds.has(String(nextId))) nextId++;\n\t\t\t\tchunk.id = nextId;\n\t\t\t\tchunk.ids = [nextId];\n\t\t\t\tnextId++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (const chunk of chunks) {\n\t\t\tif (chunk.id === null) {\n\t\t\t\tchunk.id = nextId;\n\t\t\t\tchunk.ids = [nextId];\n\t\t\t\tnextId++;\n\t\t\t}\n\t\t}\n\t}\n};\nmodule.exports.assignAscendingChunkIds = assignAscendingChunkIds;\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,UAAU,GAAGC,OAAO,CAAC,oBAAoB,CAAC;AAChD,MAAM;EAAEC;AAAkB,CAAC,GAAGD,OAAO,CAAC,oBAAoB,CAAC;AAC3D,MAAME,UAAU,GAAGF,OAAO,CAAC,oBAAoB,CAAC;;AAEhD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,OAAO,GAAGA,CAACC,GAAG,EAAEC,GAAG,EAAEC,YAAY,KAAK;EAC3C,MAAMC,IAAI,GAAGR,UAAU,CAACO,YAAY,CAAC;EACrCC,IAAI,CAACC,MAAM,CAACJ,GAAG,CAAC;EAChB,MAAMK,MAAM,GAAG,qBAAuBF,IAAI,CAACE,MAAM,CAAC,KAAK,CAAE;EACzD,OAAOA,MAAM,CAACC,KAAK,CAAC,CAAC,EAAEL,GAAG,CAAC;AAC5B,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMM,WAAW,GAAGP,GAAG,IAAI;EAC1B;EACA,IAAIA,GAAG,CAACQ,MAAM,GAAG,EAAE,EAAE,OAAOR,GAAG;EAC/B,MAAMS,SAAS,GAAGT,GAAG,CAACU,UAAU,CAAC,CAAC,CAAC;EACnC;EACA;EACA,IAAID,SAAS,GAAG,EAAE,EAAE;IACnB,IAAIA,SAAS,KAAK,EAAE,EAAE,OAAOT,GAAG;EACjC,CAAC,MAAM,IAAIS,SAAS,GAAG,EAAE,EAAE;IAC1B,OAAOT,GAAG;EACX;EACA,IAAIA,GAAG,KAAKW,MAAM,CAACC,MAAM,CAACZ,GAAG,CAAC,CAAC,EAAE;IAChC,OAAO,IAAIA,GAAG,EAAE;EACjB;EACA,OAAOA,GAAG;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA,MAAMa,WAAW,GAAGC,OAAO,IAC1BA,OAAO,CAACC,OAAO,CAAC,aAAa,EAAE,EAAE,CAAC,CAACA,OAAO,CAAC,0BAA0B,EAAE,GAAG,CAAC;AAC5EC,MAAM,CAACC,OAAO,CAACJ,WAAW,GAAGA,WAAW;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA,MAAMK,iBAAiB,GAAGA,CAACC,MAAM,EAAEC,SAAS,EAAElB,YAAY,KAAK;EAC9D,IAAIiB,MAAM,CAACX,MAAM,GAAG,GAAG,EAAE,OAAOW,MAAM;EACtC,OACCA,MAAM,CAACb,KAAK,CAAC,CAAC,EAAE,GAAG,GAAG,CAAC,GAAGc,SAAS,CAACZ,MAAM,CAAC,GAC3CY,SAAS,GACTrB,OAAO,CAACoB,MAAM,EAAE,CAAC,EAAEjB,YAAY,CAAC;AAElC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMmB,kBAAkB,GAAGA,CAACL,MAAM,EAAEM,OAAO,EAAEC,wBAAwB,KAAK;EACzE,MAAMC,QAAQ,GAAGR,MAAM,CAACQ,QAAQ,CAAC;IAAEF,OAAO;IAAEC;EAAyB,CAAC,CAAC;EACvE,IAAIC,QAAQ,EAAE,OAAOjB,WAAW,CAACiB,QAAQ,CAAC;EAC1C,MAAMC,gBAAgB,GAAGT,MAAM,CAACS,gBAAgB,CAAC,CAAC;EAClD,IAAIA,gBAAgB,EACnB,OAAOlB,WAAW,CACjBV,iBAAiB,CAACyB,OAAO,EAAEG,gBAAgB,EAAEF,wBAAwB,CACtE,CAAC;EACF,OAAO,EAAE;AACV,CAAC;AACDP,MAAM,CAACC,OAAO,CAACI,kBAAkB,GAAGA,kBAAkB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMK,iBAAiB,GAAGA,CACzBC,SAAS,EACTX,MAAM,EACNM,OAAO,EACPpB,YAAY,EACZqB,wBAAwB,KACpB;EACJ,MAAMK,QAAQ,GAAGC,iBAAiB,CAACb,MAAM,EAAEM,OAAO,EAAEC,wBAAwB,CAAC;EAC7E,OAAO,GAAGI,SAAS,IAAI5B,OAAO,CAAC6B,QAAQ,EAAE,CAAC,EAAE1B,YAAY,CAAC,EAAE;AAC5D,CAAC;AACDc,MAAM,CAACC,OAAO,CAACS,iBAAiB,GAAGA,iBAAiB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,iBAAiB,GAAGA,CAACb,MAAM,EAAEM,OAAO,EAAEC,wBAAwB,KACnE1B,iBAAiB,CAACyB,OAAO,EAAEN,MAAM,CAACc,UAAU,CAAC,CAAC,EAAEP,wBAAwB,CAAC;AAC1EP,MAAM,CAACC,OAAO,CAACY,iBAAiB,GAAGA,iBAAiB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,iBAAiB,GAAGA,CACzBC,KAAK,EACLC,UAAU,EACVX,OAAO,EACPF,SAAS,EACTlB,YAAY,EACZqB,wBAAwB,KACpB;EACJ,MAAMW,OAAO,GAAGD,UAAU,CAACE,mBAAmB,CAACH,KAAK,CAAC;EACrD,MAAMI,gBAAgB,GAAGF,OAAO,CAACG,GAAG,CAACC,CAAC,IACrCzB,WAAW,CAACQ,kBAAkB,CAACiB,CAAC,EAAEhB,OAAO,EAAEC,wBAAwB,CAAC,CACrE,CAAC;EACDS,KAAK,CAACO,WAAW,CAACC,IAAI,CAAC,CAAC;EACxB,MAAMC,SAAS,GAAGC,KAAK,CAACC,IAAI,CAACX,KAAK,CAACO,WAAW,CAAC,CAC7CK,MAAM,CAACR,gBAAgB,CAAC,CACxBS,MAAM,CAACC,OAAO,CAAC,CACfC,IAAI,CAAC3B,SAAS,CAAC;EACjB,OAAOF,iBAAiB,CAACuB,SAAS,EAAErB,SAAS,EAAElB,YAAY,CAAC;AAC7D,CAAC;AACDc,MAAM,CAACC,OAAO,CAACc,iBAAiB,GAAGA,iBAAiB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMiB,gBAAgB,GAAGA,CACxBhB,KAAK,EACLC,UAAU,EACVX,OAAO,EACPF,SAAS,EACTlB,YAAY,EACZqB,wBAAwB,KACpB;EACJ,MAAMW,OAAO,GAAGD,UAAU,CAACE,mBAAmB,CAACH,KAAK,CAAC;EACrD,MAAMI,gBAAgB,GAAGF,OAAO,CAACG,GAAG,CAACC,CAAC,IACrCzB,WAAW,CAACQ,kBAAkB,CAACiB,CAAC,EAAEhB,OAAO,EAAEC,wBAAwB,CAAC,CACrE,CAAC;EACD,MAAM0B,eAAe,GAAGf,OAAO,CAACG,GAAG,CAACC,CAAC,IACpCzB,WAAW,CACVa,iBAAiB,CAAC,EAAE,EAAEY,CAAC,EAAEhB,OAAO,EAAEpB,YAAY,EAAEqB,wBAAwB,CACzE,CACD,CAAC;EACDS,KAAK,CAACO,WAAW,CAACC,IAAI,CAAC,CAAC;EACxB,MAAMC,SAAS,GAAGC,KAAK,CAACC,IAAI,CAACX,KAAK,CAACO,WAAW,CAAC,CAC7CK,MAAM,CAACR,gBAAgB,EAAEa,eAAe,CAAC,CACzCJ,MAAM,CAACC,OAAO,CAAC,CACfC,IAAI,CAAC3B,SAAS,CAAC;EACjB,OAAOF,iBAAiB,CAACuB,SAAS,EAAErB,SAAS,EAAElB,YAAY,CAAC;AAC7D,CAAC;AACDc,MAAM,CAACC,OAAO,CAAC+B,gBAAgB,GAAGA,gBAAgB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,gBAAgB,GAAGA,CACxBlB,KAAK,EACLC,UAAU,EACVX,OAAO,EACPC,wBAAwB,KACpB;EACJ,IAAIS,KAAK,CAACmB,IAAI,EAAE,OAAOnB,KAAK,CAACmB,IAAI;EACjC,MAAMjB,OAAO,GAAGD,UAAU,CAACE,mBAAmB,CAACH,KAAK,CAAC;EACrD,MAAMoB,eAAe,GAAGlB,OAAO,CAACG,GAAG,CAACC,CAAC,IACpCzC,iBAAiB,CAACyB,OAAO,EAAEgB,CAAC,CAACR,UAAU,CAAC,CAAC,EAAEP,wBAAwB,CACpE,CAAC;EACD,OAAO6B,eAAe,CAACL,IAAI,CAAC,CAAC;AAC9B,CAAC;AACD/B,MAAM,CAACC,OAAO,CAACiC,gBAAgB,GAAGA,gBAAgB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMG,eAAe,GAAGA,CAAChB,GAAG,EAAEiB,GAAG,EAAEC,KAAK,KAAK;EAC5C,IAAIC,KAAK,GAAGnB,GAAG,CAACoB,GAAG,CAACH,GAAG,CAAC;EACxB,IAAIE,KAAK,KAAKE,SAAS,EAAE;IACxBF,KAAK,GAAG,EAAE;IACVnB,GAAG,CAACsB,GAAG,CAACL,GAAG,EAAEE,KAAK,CAAC;EACpB;EACAA,KAAK,CAACI,IAAI,CAACL,KAAK,CAAC;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMM,0BAA0B,GAAGA,CAACC,WAAW,EAAEjB,MAAM,KAAK;EAC3D,MAAMZ,UAAU,GAAG6B,WAAW,CAAC7B,UAAU;EAEzC,MAAMC,OAAO,GAAG,EAAE;;EAElB;EACA,MAAM6B,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;EACzB,IAAIF,WAAW,CAACG,aAAa,EAAE;IAC9B,KAAK,MAAMC,EAAE,IAAIJ,WAAW,CAACG,aAAa,EAAE;MAC3CF,OAAO,CAACI,GAAG,CAACxD,MAAM,CAACuD,EAAE,CAAC,CAAC;IACxB;EACD;EAEA,KAAK,MAAMlD,MAAM,IAAI8C,WAAW,CAAC5B,OAAO,EAAE;IACzC,IAAI,CAAClB,MAAM,CAACoD,MAAM,EAAE;IACpB,MAAMC,QAAQ,GAAGpC,UAAU,CAACqC,WAAW,CAACtD,MAAM,CAAC;IAC/C,IAAIqD,QAAQ,KAAK,IAAI,EAAE;MACtBN,OAAO,CAACI,GAAG,CAACxD,MAAM,CAAC0D,QAAQ,CAAC,CAAC;IAC9B,CAAC,MAAM,IACN,CAAC,CAACxB,MAAM,IAAIA,MAAM,CAAC7B,MAAM,CAAC,KAC1BiB,UAAU,CAACsC,uBAAuB,CAACvD,MAAM,CAAC,KAAK,CAAC,EAC/C;MACDkB,OAAO,CAAC0B,IAAI,CAAC5C,MAAM,CAAC;IACrB;EACD;EAEA,OAAO,CAAC+C,OAAO,EAAE7B,OAAO,CAAC;AAC1B,CAAC;AACDlB,MAAM,CAACC,OAAO,CAAC4C,0BAA0B,GAAGA,0BAA0B;;AAEtE;AACA;AACA;AACA;AACA,MAAMW,eAAe,GAAGV,WAAW,IAAI;EACtC;EACA,MAAMC,OAAO,GAAG,IAAIC,GAAG,CAAC,CAAC;EACzB,IAAIF,WAAW,CAACW,YAAY,EAAE;IAC7B,KAAK,MAAMP,EAAE,IAAIJ,WAAW,CAACW,YAAY,EAAE;MAC1CV,OAAO,CAACI,GAAG,CAACxD,MAAM,CAACuD,EAAE,CAAC,CAAC;IACxB;EACD;EAEA,KAAK,MAAMlC,KAAK,IAAI8B,WAAW,CAACY,MAAM,EAAE;IACvC,MAAMC,OAAO,GAAG3C,KAAK,CAACkC,EAAE;IACxB,IAAIS,OAAO,KAAK,IAAI,EAAE;MACrBZ,OAAO,CAACI,GAAG,CAACxD,MAAM,CAACgE,OAAO,CAAC,CAAC;IAC7B;EACD;EAEA,OAAOZ,OAAO;AACf,CAAC;AACD/C,MAAM,CAACC,OAAO,CAACuD,eAAe,GAAGA,eAAe;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMI,WAAW,GAAGA,CACnBC,KAAK,EACLC,YAAY,EACZC,WAAW,EACXC,UAAU,EACVjB,OAAO,EACPkB,UAAU,KACN;EACJ;EACA,MAAMC,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC;EAE7B,KAAK,MAAMC,IAAI,IAAIP,KAAK,EAAE;IACzB,MAAM1B,IAAI,GAAG2B,YAAY,CAACM,IAAI,CAAC;IAC/B/B,eAAe,CAAC6B,WAAW,EAAE/B,IAAI,EAAEiC,IAAI,CAAC;EACzC;;EAEA;EACA,MAAMC,YAAY,GAAG,IAAIF,GAAG,CAAC,CAAC;EAE9B,KAAK,MAAM,CAAChC,IAAI,EAAE0B,KAAK,CAAC,IAAIK,WAAW,EAAE;IACxC,IAAIL,KAAK,CAACrE,MAAM,GAAG,CAAC,IAAI,CAAC2C,IAAI,EAAE;MAC9B,KAAK,MAAMiC,IAAI,IAAIP,KAAK,EAAE;QACzB,MAAMS,QAAQ,GAAGP,WAAW,CAACK,IAAI,EAAEjC,IAAI,CAAC;QACxCE,eAAe,CAACgC,YAAY,EAAEC,QAAQ,EAAEF,IAAI,CAAC;MAC9C;IACD,CAAC,MAAM;MACN/B,eAAe,CAACgC,YAAY,EAAElC,IAAI,EAAE0B,KAAK,CAAC,CAAC,CAAC,CAAC;IAC9C;EACD;;EAEA;EACA,MAAMU,YAAY,GAAG,EAAE;EAEvB,KAAK,MAAM,CAACpC,IAAI,EAAE0B,KAAK,CAAC,IAAIQ,YAAY,EAAE;IACzC,IAAI,CAAClC,IAAI,EAAE;MACV,KAAK,MAAMiC,IAAI,IAAIP,KAAK,EAAE;QACzBU,YAAY,CAAC3B,IAAI,CAACwB,IAAI,CAAC;MACxB;IACD,CAAC,MAAM,IAAIP,KAAK,CAACrE,MAAM,KAAK,CAAC,IAAI,CAACuD,OAAO,CAACyB,GAAG,CAACrC,IAAI,CAAC,EAAE;MACpD8B,UAAU,CAACJ,KAAK,CAAC,CAAC,CAAC,EAAE1B,IAAI,CAAC;MAC1BY,OAAO,CAACI,GAAG,CAAChB,IAAI,CAAC;IAClB,CAAC,MAAM;MACN0B,KAAK,CAACrC,IAAI,CAACwC,UAAU,CAAC;MACtB,IAAIS,CAAC,GAAG,CAAC;MACT,KAAK,MAAML,IAAI,IAAIP,KAAK,EAAE;QACzB,OAAOQ,YAAY,CAACG,GAAG,CAACrC,IAAI,GAAGsC,CAAC,CAAC,IAAI1B,OAAO,CAACyB,GAAG,CAACrC,IAAI,GAAGsC,CAAC,CAAC,EAAEA,CAAC,EAAE;QAC/DR,UAAU,CAACG,IAAI,EAAEjC,IAAI,GAAGsC,CAAC,CAAC;QAC1B1B,OAAO,CAACI,GAAG,CAAChB,IAAI,GAAGsC,CAAC,CAAC;QACrBA,CAAC,EAAE;MACJ;IACD;EACD;EAEAF,YAAY,CAAC/C,IAAI,CAACwC,UAAU,CAAC;EAC7B,OAAOO,YAAY;AACpB,CAAC;AACDvE,MAAM,CAACC,OAAO,CAAC2D,WAAW,GAAGA,WAAW;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMc,sBAAsB,GAAGA,CAC9Bb,KAAK,EACLc,OAAO,EACPX,UAAU,EACVY,QAAQ,EACRC,MAAM,GAAG,CAAC,EAAE,CAAC,EACbC,YAAY,GAAG,EAAE,EACjBC,UAAU,GAAG,CAAC,EACdC,IAAI,GAAG,CAAC,KACJ;EACJnB,KAAK,CAACrC,IAAI,CAACwC,UAAU,CAAC;;EAEtB;EACA,MAAMiB,YAAY,GAAGC,IAAI,CAACC,GAAG,CAC5BtB,KAAK,CAACrE,MAAM,GAAG,EAAE,GAAGuF,UAAU,EAC9BnF,MAAM,CAACwF,gBACR,CAAC;EAED,IAAIX,CAAC,GAAG,CAAC;EACT,IAAIY,KAAK,GAAGR,MAAM,CAACJ,CAAC,CAAC;EACrB,OAAOY,KAAK,GAAGJ,YAAY,EAAE;IAC5BR,CAAC,EAAE;IACH,IAAIA,CAAC,GAAGI,MAAM,CAACrF,MAAM,EAAE;MACtB6F,KAAK,GAAGH,IAAI,CAACC,GAAG,CAACN,MAAM,CAACJ,CAAC,CAAC,EAAE7E,MAAM,CAACwF,gBAAgB,CAAC;IACrD,CAAC,MAAM,IAAIN,YAAY,EAAE;MACxBO,KAAK,GAAGH,IAAI,CAACC,GAAG,CAACE,KAAK,GAAGP,YAAY,EAAElF,MAAM,CAACwF,gBAAgB,CAAC;IAChE,CAAC,MAAM;MACN;IACD;EACD;EAEA,KAAK,MAAMhB,IAAI,IAAIP,KAAK,EAAE;IACzB,MAAMyB,KAAK,GAAGX,OAAO,CAACP,IAAI,CAAC;IAC3B,IAAIlB,EAAE;IACN,IAAIuB,CAAC,GAAGO,IAAI;IACZ,GAAG;MACF9B,EAAE,GAAGpE,UAAU,CAACwG,KAAK,GAAGb,CAAC,EAAE,EAAEY,KAAK,CAAC;IACpC,CAAC,QAAQ,CAACT,QAAQ,CAACR,IAAI,EAAElB,EAAE,CAAC;EAC7B;AACD,CAAC;AACDlD,MAAM,CAACC,OAAO,CAACyE,sBAAsB,GAAGA,sBAAsB;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA,MAAMa,wBAAwB,GAAGA,CAACxC,OAAO,EAAE7B,OAAO,EAAE4B,WAAW,KAAK;EACnE,MAAM7B,UAAU,GAAG6B,WAAW,CAAC7B,UAAU;EAEzC,IAAIuE,MAAM,GAAG,CAAC;EACd,IAAIZ,QAAQ;EACZ,IAAI7B,OAAO,CAAC0C,IAAI,GAAG,CAAC,EAAE;IACrB;AACF;AACA;IACEb,QAAQ,GAAG5E,MAAM,IAAI;MACpB,IAAIiB,UAAU,CAACqC,WAAW,CAACtD,MAAM,CAAC,KAAK,IAAI,EAAE;QAC5C,OAAO+C,OAAO,CAACyB,GAAG,CAAC7E,MAAM,CAAC6F,MAAM,CAAC,CAAC,EAAEA,MAAM,EAAE;QAC5CvE,UAAU,CAACyE,WAAW,CAAC1F,MAAM,EAAEwF,MAAM,EAAE,CAAC;MACzC;IACD,CAAC;EACF,CAAC,MAAM;IACN;AACF;AACA;IACEZ,QAAQ,GAAG5E,MAAM,IAAI;MACpB,IAAIiB,UAAU,CAACqC,WAAW,CAACtD,MAAM,CAAC,KAAK,IAAI,EAAE;QAC5CiB,UAAU,CAACyE,WAAW,CAAC1F,MAAM,EAAEwF,MAAM,EAAE,CAAC;MACzC;IACD,CAAC;EACF;EACA,KAAK,MAAMxF,MAAM,IAAIkB,OAAO,EAAE;IAC7B0D,QAAQ,CAAC5E,MAAM,CAAC;EACjB;AACD,CAAC;AACDA,MAAM,CAACC,OAAO,CAACsF,wBAAwB,GAAGA,wBAAwB;;AAElE;AACA;AACA;AACA;AACA;AACA,MAAMI,uBAAuB,GAAGA,CAACjC,MAAM,EAAEZ,WAAW,KAAK;EACxD,MAAMC,OAAO,GAAGS,eAAe,CAACV,WAAW,CAAC;EAE5C,IAAI0C,MAAM,GAAG,CAAC;EACd,IAAIzC,OAAO,CAAC0C,IAAI,GAAG,CAAC,EAAE;IACrB,KAAK,MAAMzE,KAAK,IAAI0C,MAAM,EAAE;MAC3B,IAAI1C,KAAK,CAACkC,EAAE,KAAK,IAAI,EAAE;QACtB,OAAOH,OAAO,CAACyB,GAAG,CAAC7E,MAAM,CAAC6F,MAAM,CAAC,CAAC,EAAEA,MAAM,EAAE;QAC5CxE,KAAK,CAACkC,EAAE,GAAGsC,MAAM;QACjBxE,KAAK,CAAC4E,GAAG,GAAG,CAACJ,MAAM,CAAC;QACpBA,MAAM,EAAE;MACT;IACD;EACD,CAAC,MAAM;IACN,KAAK,MAAMxE,KAAK,IAAI0C,MAAM,EAAE;MAC3B,IAAI1C,KAAK,CAACkC,EAAE,KAAK,IAAI,EAAE;QACtBlC,KAAK,CAACkC,EAAE,GAAGsC,MAAM;QACjBxE,KAAK,CAAC4E,GAAG,GAAG,CAACJ,MAAM,CAAC;QACpBA,MAAM,EAAE;MACT;IACD;EACD;AACD,CAAC;AACDxF,MAAM,CAACC,OAAO,CAAC0F,uBAAuB,GAAGA,uBAAuB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}