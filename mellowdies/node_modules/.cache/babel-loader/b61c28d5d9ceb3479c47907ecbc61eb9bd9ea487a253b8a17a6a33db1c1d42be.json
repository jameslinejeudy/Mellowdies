{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  HookMap,\n  SyncBailHook,\n  SyncWaterfallHook\n} = require(\"tapable\");\nconst {\n  concatComparators,\n  keepOriginalOrder\n} = require(\"../util/comparators\");\nconst smartGrouping = require(\"../util/smartGrouping\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compilation\").NormalizedStatsOptions} NormalizedStatsOptions */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n/** @typedef {import(\"../util/comparators\").Comparator<any>} Comparator */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n/** @typedef {import(\"../util/smartGrouping\").GroupConfig<any, object>} GroupConfig */\n\n/**\n * @typedef {object} KnownStatsFactoryContext\n * @property {string} type\n * @property {function(string): string} makePathsRelative\n * @property {Compilation} compilation\n * @property {Set<Module>} rootModules\n * @property {Map<string,Chunk[]>} compilationFileToChunks\n * @property {Map<string,Chunk[]>} compilationAuxiliaryFileToChunks\n * @property {RuntimeSpec} runtime\n * @property {function(Compilation): WebpackError[]} cachedGetErrors\n * @property {function(Compilation): WebpackError[]} cachedGetWarnings\n */\n\n/** @typedef {Record<string, any> & KnownStatsFactoryContext} StatsFactoryContext */\n\n/** @typedef {any} CreatedObject */\n/** @typedef {any} FactoryData */\n/** @typedef {any} FactoryDataItem */\n/** @typedef {any} Result */\n/** @typedef {Record<string, any>} ObjectForExtract */\n\n/**\n * @typedef {object} StatsFactoryHooks\n * @property {HookMap<SyncBailHook<[ObjectForExtract, FactoryData, StatsFactoryContext], undefined>>} extract\n * @property {HookMap<SyncBailHook<[FactoryDataItem, StatsFactoryContext, number, number], boolean | undefined>>} filter\n * @property {HookMap<SyncBailHook<[Comparator[], StatsFactoryContext], undefined>>} sort\n * @property {HookMap<SyncBailHook<[FactoryDataItem, StatsFactoryContext, number, number], boolean | undefined>>} filterSorted\n * @property {HookMap<SyncBailHook<[GroupConfig[], StatsFactoryContext], undefined>>} groupResults\n * @property {HookMap<SyncBailHook<[Comparator[], StatsFactoryContext], undefined>>} sortResults\n * @property {HookMap<SyncBailHook<[FactoryDataItem, StatsFactoryContext, number, number], boolean | undefined>>} filterResults\n * @property {HookMap<SyncBailHook<[FactoryDataItem[], StatsFactoryContext], Result>>} merge\n * @property {HookMap<SyncBailHook<[Result, StatsFactoryContext], Result>>} result\n * @property {HookMap<SyncBailHook<[FactoryDataItem, StatsFactoryContext], string>>} getItemName\n * @property {HookMap<SyncBailHook<[FactoryDataItem, StatsFactoryContext], StatsFactory | undefined>>} getItemFactory\n */\n\n/**\n * @template T\n * @typedef {Map<string, T[]>} Caches\n */\n\nclass StatsFactory {\n  constructor() {\n    /** @type {StatsFactoryHooks} */\n    this.hooks = Object.freeze({\n      extract: new HookMap(() => new SyncBailHook([\"object\", \"data\", \"context\"])),\n      filter: new HookMap(() => new SyncBailHook([\"item\", \"context\", \"index\", \"unfilteredIndex\"])),\n      sort: new HookMap(() => new SyncBailHook([\"comparators\", \"context\"])),\n      filterSorted: new HookMap(() => new SyncBailHook([\"item\", \"context\", \"index\", \"unfilteredIndex\"])),\n      groupResults: new HookMap(() => new SyncBailHook([\"groupConfigs\", \"context\"])),\n      sortResults: new HookMap(() => new SyncBailHook([\"comparators\", \"context\"])),\n      filterResults: new HookMap(() => new SyncBailHook([\"item\", \"context\", \"index\", \"unfilteredIndex\"])),\n      merge: new HookMap(() => new SyncBailHook([\"items\", \"context\"])),\n      result: new HookMap(() => new SyncWaterfallHook([\"result\", \"context\"])),\n      getItemName: new HookMap(() => new SyncBailHook([\"item\", \"context\"])),\n      getItemFactory: new HookMap(() => new SyncBailHook([\"item\", \"context\"]))\n    });\n    const hooks = this.hooks;\n    this._caches = /** @type {TODO} */{};\n    for (const key of Object.keys(hooks)) {\n      this._caches[(/** @type {keyof StatsFactoryHooks} */key)] = new Map();\n    }\n    this._inCreate = false;\n  }\n\n  /**\n   * @template {StatsFactoryHooks[keyof StatsFactoryHooks]} HM\n   * @template {HM extends HookMap<infer H> ? H : never} H\n   * @param {HM} hookMap hook map\n   * @param {Caches<H>} cache cache\n   * @param {string} type type\n   * @returns {H[]} hooks\n   * @private\n   */\n  _getAllLevelHooks(hookMap, cache, type) {\n    const cacheEntry = cache.get(type);\n    if (cacheEntry !== undefined) {\n      return cacheEntry;\n    }\n    const hooks = /** @type {H[]} */[];\n    const typeParts = type.split(\".\");\n    for (let i = 0; i < typeParts.length; i++) {\n      const hook = /** @type {H} */hookMap.get(typeParts.slice(i).join(\".\"));\n      if (hook) {\n        hooks.push(hook);\n      }\n    }\n    cache.set(type, hooks);\n    return hooks;\n  }\n\n  /**\n   * @template {StatsFactoryHooks[keyof StatsFactoryHooks]} HM\n   * @template {HM extends HookMap<infer H> ? H : never} H\n   * @template {H extends import(\"tapable\").Hook<any, infer R> ? R : never} R\n   * @param {HM} hookMap hook map\n   * @param {Caches<H>} cache cache\n   * @param {string} type type\n   * @param {function(H): R | undefined} fn fn\n   * @returns {R | undefined} hook\n   * @private\n   */\n  _forEachLevel(hookMap, cache, type, fn) {\n    for (const hook of this._getAllLevelHooks(hookMap, cache, type)) {\n      const result = fn(/** @type {H} */hook);\n      if (result !== undefined) return result;\n    }\n  }\n\n  /**\n   * @template {StatsFactoryHooks[keyof StatsFactoryHooks]} HM\n   * @template {HM extends HookMap<infer H> ? H : never} H\n   * @param {HM} hookMap hook map\n   * @param {Caches<H>} cache cache\n   * @param {string} type type\n   * @param {FactoryData} data data\n   * @param {function(H, FactoryData): FactoryData} fn fn\n   * @returns {FactoryData} data\n   * @private\n   */\n  _forEachLevelWaterfall(hookMap, cache, type, data, fn) {\n    for (const hook of this._getAllLevelHooks(hookMap, cache, type)) {\n      data = fn(/** @type {H} */hook, data);\n    }\n    return data;\n  }\n\n  /**\n   * @template {StatsFactoryHooks[keyof StatsFactoryHooks]} T\n   * @template {T extends HookMap<infer H> ? H : never} H\n   * @template {H extends import(\"tapable\").Hook<any, infer R> ? R : never} R\n   * @param {T} hookMap hook map\n   * @param {Caches<H>} cache cache\n   * @param {string} type type\n   * @param {Array<FactoryData>} items items\n   * @param {function(H, R, number, number): R | undefined} fn fn\n   * @param {boolean} forceClone force clone\n   * @returns {R[]} result for each level\n   * @private\n   */\n  _forEachLevelFilter(hookMap, cache, type, items, fn, forceClone) {\n    const hooks = this._getAllLevelHooks(hookMap, cache, type);\n    if (hooks.length === 0) return forceClone ? items.slice() : items;\n    let i = 0;\n    return items.filter((item, idx) => {\n      for (const hook of hooks) {\n        const r = fn(/** @type {H} */hook, item, idx, i);\n        if (r !== undefined) {\n          if (r) i++;\n          return r;\n        }\n      }\n      i++;\n      return true;\n    });\n  }\n\n  /**\n   * @param {string} type type\n   * @param {FactoryData} data factory data\n   * @param {Omit<StatsFactoryContext, \"type\">} baseContext context used as base\n   * @returns {CreatedObject} created object\n   */\n  create(type, data, baseContext) {\n    if (this._inCreate) {\n      return this._create(type, data, baseContext);\n    }\n    try {\n      this._inCreate = true;\n      return this._create(type, data, baseContext);\n    } finally {\n      for (const key of Object.keys(this._caches)) this._caches[(/** @type {keyof StatsFactoryHooks} */key)].clear();\n      this._inCreate = false;\n    }\n  }\n\n  /**\n   * @param {string} type type\n   * @param {FactoryData} data factory data\n   * @param {Omit<StatsFactoryContext, \"type\">} baseContext context used as base\n   * @returns {CreatedObject} created object\n   * @private\n   */\n  _create(type, data, baseContext) {\n    const context = /** @type {StatsFactoryContext} */{\n      ...baseContext,\n      type,\n      [type]: data\n    };\n    if (Array.isArray(data)) {\n      // run filter on unsorted items\n      const items = this._forEachLevelFilter(this.hooks.filter, this._caches.filter, type, data, (h, r, idx, i) => h.call(r, context, idx, i), true);\n\n      // sort items\n      /** @type {Comparator[]} */\n      const comparators = [];\n      this._forEachLevel(this.hooks.sort, this._caches.sort, type, h => h.call(comparators, context));\n      if (comparators.length > 0) {\n        items.sort(\n        // @ts-expect-error number of arguments is correct\n        concatComparators(...comparators, keepOriginalOrder(items)));\n      }\n\n      // run filter on sorted items\n      const items2 = this._forEachLevelFilter(this.hooks.filterSorted, this._caches.filterSorted, type, items, (h, r, idx, i) => h.call(r, context, idx, i), false);\n\n      // for each item\n      let resultItems = items2.map((item, i) => {\n        /** @type {StatsFactoryContext} */\n        const itemContext = {\n          ...context,\n          _index: i\n        };\n\n        // run getItemName\n        const itemName = this._forEachLevel(this.hooks.getItemName, this._caches.getItemName, `${type}[]`, h => h.call(item, itemContext));\n        if (itemName) itemContext[itemName] = item;\n        const innerType = itemName ? `${type}[].${itemName}` : `${type}[]`;\n\n        // run getItemFactory\n        const itemFactory = this._forEachLevel(this.hooks.getItemFactory, this._caches.getItemFactory, innerType, h => h.call(item, itemContext)) || this;\n\n        // run item factory\n        return itemFactory.create(innerType, item, itemContext);\n      });\n\n      // sort result items\n      /** @type {Comparator[]} */\n      const comparators2 = [];\n      this._forEachLevel(this.hooks.sortResults, this._caches.sortResults, type, h => h.call(comparators2, context));\n      if (comparators2.length > 0) {\n        resultItems.sort(\n        // @ts-expect-error number of arguments is correct\n        concatComparators(...comparators2, keepOriginalOrder(resultItems)));\n      }\n\n      // group result items\n      /** @type {GroupConfig[]} */\n      const groupConfigs = [];\n      this._forEachLevel(this.hooks.groupResults, this._caches.groupResults, type, h => h.call(groupConfigs, context));\n      if (groupConfigs.length > 0) {\n        resultItems = smartGrouping(resultItems, groupConfigs);\n      }\n\n      // run filter on sorted result items\n      const finalResultItems = this._forEachLevelFilter(this.hooks.filterResults, this._caches.filterResults, type, resultItems, (h, r, idx, i) => h.call(r, context, idx, i), false);\n\n      // run merge on mapped items\n      let result = this._forEachLevel(this.hooks.merge, this._caches.merge, type, h => h.call(finalResultItems, context));\n      if (result === undefined) result = finalResultItems;\n\n      // run result on merged items\n      return this._forEachLevelWaterfall(this.hooks.result, this._caches.result, type, result, (h, r) => h.call(r, context));\n    }\n    /** @type {ObjectForExtract} */\n    const object = {};\n\n    // run extract on value\n    this._forEachLevel(this.hooks.extract, this._caches.extract, type, h => h.call(object, data, context));\n\n    // run result on extracted object\n    return this._forEachLevelWaterfall(this.hooks.result, this._caches.result, type, object, (h, r) => h.call(r, context));\n  }\n}\nmodule.exports = StatsFactory;","map":{"version":3,"names":["HookMap","SyncBailHook","SyncWaterfallHook","require","concatComparators","keepOriginalOrder","smartGrouping","StatsFactory","constructor","hooks","Object","freeze","extract","filter","sort","filterSorted","groupResults","sortResults","filterResults","merge","result","getItemName","getItemFactory","_caches","key","keys","Map","_inCreate","_getAllLevelHooks","hookMap","cache","type","cacheEntry","get","undefined","typeParts","split","i","length","hook","slice","join","push","set","_forEachLevel","fn","_forEachLevelWaterfall","data","_forEachLevelFilter","items","forceClone","item","idx","r","create","baseContext","_create","clear","context","Array","isArray","h","call","comparators","items2","resultItems","map","itemContext","_index","itemName","innerType","itemFactory","comparators2","groupConfigs","finalResultItems","object","module","exports"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/webpack/lib/stats/StatsFactory.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { HookMap, SyncBailHook, SyncWaterfallHook } = require(\"tapable\");\nconst { concatComparators, keepOriginalOrder } = require(\"../util/comparators\");\nconst smartGrouping = require(\"../util/smartGrouping\");\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compilation\").NormalizedStatsOptions} NormalizedStatsOptions */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../WebpackError\")} WebpackError */\n/** @typedef {import(\"../util/comparators\").Comparator<any>} Comparator */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n/** @typedef {import(\"../util/smartGrouping\").GroupConfig<any, object>} GroupConfig */\n\n/**\n * @typedef {object} KnownStatsFactoryContext\n * @property {string} type\n * @property {function(string): string} makePathsRelative\n * @property {Compilation} compilation\n * @property {Set<Module>} rootModules\n * @property {Map<string,Chunk[]>} compilationFileToChunks\n * @property {Map<string,Chunk[]>} compilationAuxiliaryFileToChunks\n * @property {RuntimeSpec} runtime\n * @property {function(Compilation): WebpackError[]} cachedGetErrors\n * @property {function(Compilation): WebpackError[]} cachedGetWarnings\n */\n\n/** @typedef {Record<string, any> & KnownStatsFactoryContext} StatsFactoryContext */\n\n/** @typedef {any} CreatedObject */\n/** @typedef {any} FactoryData */\n/** @typedef {any} FactoryDataItem */\n/** @typedef {any} Result */\n/** @typedef {Record<string, any>} ObjectForExtract */\n\n/**\n * @typedef {object} StatsFactoryHooks\n * @property {HookMap<SyncBailHook<[ObjectForExtract, FactoryData, StatsFactoryContext], undefined>>} extract\n * @property {HookMap<SyncBailHook<[FactoryDataItem, StatsFactoryContext, number, number], boolean | undefined>>} filter\n * @property {HookMap<SyncBailHook<[Comparator[], StatsFactoryContext], undefined>>} sort\n * @property {HookMap<SyncBailHook<[FactoryDataItem, StatsFactoryContext, number, number], boolean | undefined>>} filterSorted\n * @property {HookMap<SyncBailHook<[GroupConfig[], StatsFactoryContext], undefined>>} groupResults\n * @property {HookMap<SyncBailHook<[Comparator[], StatsFactoryContext], undefined>>} sortResults\n * @property {HookMap<SyncBailHook<[FactoryDataItem, StatsFactoryContext, number, number], boolean | undefined>>} filterResults\n * @property {HookMap<SyncBailHook<[FactoryDataItem[], StatsFactoryContext], Result>>} merge\n * @property {HookMap<SyncBailHook<[Result, StatsFactoryContext], Result>>} result\n * @property {HookMap<SyncBailHook<[FactoryDataItem, StatsFactoryContext], string>>} getItemName\n * @property {HookMap<SyncBailHook<[FactoryDataItem, StatsFactoryContext], StatsFactory | undefined>>} getItemFactory\n */\n\n/**\n * @template T\n * @typedef {Map<string, T[]>} Caches\n */\n\nclass StatsFactory {\n\tconstructor() {\n\t\t/** @type {StatsFactoryHooks} */\n\t\tthis.hooks = Object.freeze({\n\t\t\textract: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"object\", \"data\", \"context\"])\n\t\t\t),\n\t\t\tfilter: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"item\", \"context\", \"index\", \"unfilteredIndex\"])\n\t\t\t),\n\t\t\tsort: new HookMap(() => new SyncBailHook([\"comparators\", \"context\"])),\n\t\t\tfilterSorted: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"item\", \"context\", \"index\", \"unfilteredIndex\"])\n\t\t\t),\n\t\t\tgroupResults: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"groupConfigs\", \"context\"])\n\t\t\t),\n\t\t\tsortResults: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"comparators\", \"context\"])\n\t\t\t),\n\t\t\tfilterResults: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"item\", \"context\", \"index\", \"unfilteredIndex\"])\n\t\t\t),\n\t\t\tmerge: new HookMap(() => new SyncBailHook([\"items\", \"context\"])),\n\t\t\tresult: new HookMap(() => new SyncWaterfallHook([\"result\", \"context\"])),\n\t\t\tgetItemName: new HookMap(() => new SyncBailHook([\"item\", \"context\"])),\n\t\t\tgetItemFactory: new HookMap(() => new SyncBailHook([\"item\", \"context\"]))\n\t\t});\n\t\tconst hooks = this.hooks;\n\t\tthis._caches = /** @type {TODO} */ ({});\n\t\tfor (const key of Object.keys(hooks)) {\n\t\t\tthis._caches[/** @type {keyof StatsFactoryHooks} */ (key)] = new Map();\n\t\t}\n\t\tthis._inCreate = false;\n\t}\n\n\t/**\n\t * @template {StatsFactoryHooks[keyof StatsFactoryHooks]} HM\n\t * @template {HM extends HookMap<infer H> ? H : never} H\n\t * @param {HM} hookMap hook map\n\t * @param {Caches<H>} cache cache\n\t * @param {string} type type\n\t * @returns {H[]} hooks\n\t * @private\n\t */\n\t_getAllLevelHooks(hookMap, cache, type) {\n\t\tconst cacheEntry = cache.get(type);\n\t\tif (cacheEntry !== undefined) {\n\t\t\treturn cacheEntry;\n\t\t}\n\t\tconst hooks = /** @type {H[]} */ ([]);\n\t\tconst typeParts = type.split(\".\");\n\t\tfor (let i = 0; i < typeParts.length; i++) {\n\t\t\tconst hook = /** @type {H} */ (hookMap.get(typeParts.slice(i).join(\".\")));\n\t\t\tif (hook) {\n\t\t\t\thooks.push(hook);\n\t\t\t}\n\t\t}\n\t\tcache.set(type, hooks);\n\t\treturn hooks;\n\t}\n\n\t/**\n\t * @template {StatsFactoryHooks[keyof StatsFactoryHooks]} HM\n\t * @template {HM extends HookMap<infer H> ? H : never} H\n\t * @template {H extends import(\"tapable\").Hook<any, infer R> ? R : never} R\n\t * @param {HM} hookMap hook map\n\t * @param {Caches<H>} cache cache\n\t * @param {string} type type\n\t * @param {function(H): R | undefined} fn fn\n\t * @returns {R | undefined} hook\n\t * @private\n\t */\n\t_forEachLevel(hookMap, cache, type, fn) {\n\t\tfor (const hook of this._getAllLevelHooks(hookMap, cache, type)) {\n\t\t\tconst result = fn(/** @type {H} */ (hook));\n\t\t\tif (result !== undefined) return result;\n\t\t}\n\t}\n\n\t/**\n\t * @template {StatsFactoryHooks[keyof StatsFactoryHooks]} HM\n\t * @template {HM extends HookMap<infer H> ? H : never} H\n\t * @param {HM} hookMap hook map\n\t * @param {Caches<H>} cache cache\n\t * @param {string} type type\n\t * @param {FactoryData} data data\n\t * @param {function(H, FactoryData): FactoryData} fn fn\n\t * @returns {FactoryData} data\n\t * @private\n\t */\n\t_forEachLevelWaterfall(hookMap, cache, type, data, fn) {\n\t\tfor (const hook of this._getAllLevelHooks(hookMap, cache, type)) {\n\t\t\tdata = fn(/** @type {H} */ (hook), data);\n\t\t}\n\t\treturn data;\n\t}\n\n\t/**\n\t * @template {StatsFactoryHooks[keyof StatsFactoryHooks]} T\n\t * @template {T extends HookMap<infer H> ? H : never} H\n\t * @template {H extends import(\"tapable\").Hook<any, infer R> ? R : never} R\n\t * @param {T} hookMap hook map\n\t * @param {Caches<H>} cache cache\n\t * @param {string} type type\n\t * @param {Array<FactoryData>} items items\n\t * @param {function(H, R, number, number): R | undefined} fn fn\n\t * @param {boolean} forceClone force clone\n\t * @returns {R[]} result for each level\n\t * @private\n\t */\n\t_forEachLevelFilter(hookMap, cache, type, items, fn, forceClone) {\n\t\tconst hooks = this._getAllLevelHooks(hookMap, cache, type);\n\t\tif (hooks.length === 0) return forceClone ? items.slice() : items;\n\t\tlet i = 0;\n\t\treturn items.filter((item, idx) => {\n\t\t\tfor (const hook of hooks) {\n\t\t\t\tconst r = fn(/** @type {H} */ (hook), item, idx, i);\n\t\t\t\tif (r !== undefined) {\n\t\t\t\t\tif (r) i++;\n\t\t\t\t\treturn r;\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\treturn true;\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} type type\n\t * @param {FactoryData} data factory data\n\t * @param {Omit<StatsFactoryContext, \"type\">} baseContext context used as base\n\t * @returns {CreatedObject} created object\n\t */\n\tcreate(type, data, baseContext) {\n\t\tif (this._inCreate) {\n\t\t\treturn this._create(type, data, baseContext);\n\t\t}\n\t\ttry {\n\t\t\tthis._inCreate = true;\n\t\t\treturn this._create(type, data, baseContext);\n\t\t} finally {\n\t\t\tfor (const key of Object.keys(this._caches))\n\t\t\t\tthis._caches[/** @type {keyof StatsFactoryHooks} */ (key)].clear();\n\t\t\tthis._inCreate = false;\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} type type\n\t * @param {FactoryData} data factory data\n\t * @param {Omit<StatsFactoryContext, \"type\">} baseContext context used as base\n\t * @returns {CreatedObject} created object\n\t * @private\n\t */\n\t_create(type, data, baseContext) {\n\t\tconst context = /** @type {StatsFactoryContext} */ ({\n\t\t\t...baseContext,\n\t\t\ttype,\n\t\t\t[type]: data\n\t\t});\n\t\tif (Array.isArray(data)) {\n\t\t\t// run filter on unsorted items\n\t\t\tconst items = this._forEachLevelFilter(\n\t\t\t\tthis.hooks.filter,\n\t\t\t\tthis._caches.filter,\n\t\t\t\ttype,\n\t\t\t\tdata,\n\t\t\t\t(h, r, idx, i) => h.call(r, context, idx, i),\n\t\t\t\ttrue\n\t\t\t);\n\n\t\t\t// sort items\n\t\t\t/** @type {Comparator[]} */\n\t\t\tconst comparators = [];\n\t\t\tthis._forEachLevel(this.hooks.sort, this._caches.sort, type, h =>\n\t\t\t\th.call(comparators, context)\n\t\t\t);\n\t\t\tif (comparators.length > 0) {\n\t\t\t\titems.sort(\n\t\t\t\t\t// @ts-expect-error number of arguments is correct\n\t\t\t\t\tconcatComparators(...comparators, keepOriginalOrder(items))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// run filter on sorted items\n\t\t\tconst items2 = this._forEachLevelFilter(\n\t\t\t\tthis.hooks.filterSorted,\n\t\t\t\tthis._caches.filterSorted,\n\t\t\t\ttype,\n\t\t\t\titems,\n\t\t\t\t(h, r, idx, i) => h.call(r, context, idx, i),\n\t\t\t\tfalse\n\t\t\t);\n\n\t\t\t// for each item\n\t\t\tlet resultItems = items2.map((item, i) => {\n\t\t\t\t/** @type {StatsFactoryContext} */\n\t\t\t\tconst itemContext = {\n\t\t\t\t\t...context,\n\t\t\t\t\t_index: i\n\t\t\t\t};\n\n\t\t\t\t// run getItemName\n\t\t\t\tconst itemName = this._forEachLevel(\n\t\t\t\t\tthis.hooks.getItemName,\n\t\t\t\t\tthis._caches.getItemName,\n\t\t\t\t\t`${type}[]`,\n\t\t\t\t\th => h.call(item, itemContext)\n\t\t\t\t);\n\t\t\t\tif (itemName) itemContext[itemName] = item;\n\t\t\t\tconst innerType = itemName ? `${type}[].${itemName}` : `${type}[]`;\n\n\t\t\t\t// run getItemFactory\n\t\t\t\tconst itemFactory =\n\t\t\t\t\tthis._forEachLevel(\n\t\t\t\t\t\tthis.hooks.getItemFactory,\n\t\t\t\t\t\tthis._caches.getItemFactory,\n\t\t\t\t\t\tinnerType,\n\t\t\t\t\t\th => h.call(item, itemContext)\n\t\t\t\t\t) || this;\n\n\t\t\t\t// run item factory\n\t\t\t\treturn itemFactory.create(innerType, item, itemContext);\n\t\t\t});\n\n\t\t\t// sort result items\n\t\t\t/** @type {Comparator[]} */\n\t\t\tconst comparators2 = [];\n\t\t\tthis._forEachLevel(\n\t\t\t\tthis.hooks.sortResults,\n\t\t\t\tthis._caches.sortResults,\n\t\t\t\ttype,\n\t\t\t\th => h.call(comparators2, context)\n\t\t\t);\n\t\t\tif (comparators2.length > 0) {\n\t\t\t\tresultItems.sort(\n\t\t\t\t\t// @ts-expect-error number of arguments is correct\n\t\t\t\t\tconcatComparators(...comparators2, keepOriginalOrder(resultItems))\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// group result items\n\t\t\t/** @type {GroupConfig[]} */\n\t\t\tconst groupConfigs = [];\n\t\t\tthis._forEachLevel(\n\t\t\t\tthis.hooks.groupResults,\n\t\t\t\tthis._caches.groupResults,\n\t\t\t\ttype,\n\t\t\t\th => h.call(groupConfigs, context)\n\t\t\t);\n\t\t\tif (groupConfigs.length > 0) {\n\t\t\t\tresultItems = smartGrouping(resultItems, groupConfigs);\n\t\t\t}\n\n\t\t\t// run filter on sorted result items\n\t\t\tconst finalResultItems = this._forEachLevelFilter(\n\t\t\t\tthis.hooks.filterResults,\n\t\t\t\tthis._caches.filterResults,\n\t\t\t\ttype,\n\t\t\t\tresultItems,\n\t\t\t\t(h, r, idx, i) => h.call(r, context, idx, i),\n\t\t\t\tfalse\n\t\t\t);\n\n\t\t\t// run merge on mapped items\n\t\t\tlet result = this._forEachLevel(\n\t\t\t\tthis.hooks.merge,\n\t\t\t\tthis._caches.merge,\n\t\t\t\ttype,\n\t\t\t\th => h.call(finalResultItems, context)\n\t\t\t);\n\t\t\tif (result === undefined) result = finalResultItems;\n\n\t\t\t// run result on merged items\n\t\t\treturn this._forEachLevelWaterfall(\n\t\t\t\tthis.hooks.result,\n\t\t\t\tthis._caches.result,\n\t\t\t\ttype,\n\t\t\t\tresult,\n\t\t\t\t(h, r) => h.call(r, context)\n\t\t\t);\n\t\t}\n\t\t/** @type {ObjectForExtract} */\n\t\tconst object = {};\n\n\t\t// run extract on value\n\t\tthis._forEachLevel(this.hooks.extract, this._caches.extract, type, h =>\n\t\t\th.call(object, data, context)\n\t\t);\n\n\t\t// run result on extracted object\n\t\treturn this._forEachLevelWaterfall(\n\t\t\tthis.hooks.result,\n\t\t\tthis._caches.result,\n\t\t\ttype,\n\t\t\tobject,\n\t\t\t(h, r) => h.call(r, context)\n\t\t);\n\t}\n}\nmodule.exports = StatsFactory;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}