{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __accessCheck = (obj, member, msg) => {\n  if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter) => {\n  __accessCheck(obj, member, \"read from private field\");\n  return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value) => {\n  if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter) => {\n  __accessCheck(obj, member, \"write to private field\");\n  setter ? setter.call(obj, value) : member.set(obj, value);\n  return value;\n};\nvar _currentLine;\nvar fn = new Intl.Collator(0, {\n  numeric: 1\n}).compare;\nfunction semiver(a, b, bool) {\n  a = a.split(\".\");\n  b = b.split(\".\");\n  return fn(a[0], b[0]) || fn(a[1], b[1]) || (b[2] = b.slice(2).join(\".\"), bool = /[.-]/.test(a[2] = a.slice(2).join(\".\")), bool == /[.-]/.test(b[2]) ? fn(a[2], b[2]) : bool ? -1 : 1);\n}\nconst HOST_URL = `host`;\nconst SSE_URL = `queue/data`;\nconst SSE_DATA_URL = `queue/join`;\nconst UPLOAD_URL = `upload`;\nconst LOGIN_URL = `login`;\nconst CONFIG_URL = `config`;\nconst API_INFO_URL = `info`;\nconst RUNTIME_URL = `runtime`;\nconst SLEEPTIME_URL = `sleeptime`;\nconst HEARTBEAT_URL = `heartbeat`;\nconst COMPONENT_SERVER_URL = `component_server`;\nconst RESET_URL = `reset`;\nconst CANCEL_URL = `cancel`;\nconst SPACE_FETCHER_URL = \"https://gradio-space-api-fetcher-v2.hf.space/api\";\nconst QUEUE_FULL_MSG = \"This application is currently busy. Please try again. \";\nconst BROKEN_CONNECTION_MSG = \"Connection errored out. \";\nconst CONFIG_ERROR_MSG = \"Could not resolve app config. \";\nconst SPACE_STATUS_ERROR_MSG = \"Could not get space status. \";\nconst API_INFO_ERROR_MSG = \"Could not get API info. \";\nconst SPACE_METADATA_ERROR_MSG = \"Space metadata could not be loaded. \";\nconst INVALID_URL_MSG = \"Invalid URL. A full URL path is required.\";\nconst UNAUTHORIZED_MSG = \"Not authorized to access this space. \";\nconst INVALID_CREDENTIALS_MSG = \"Invalid credentials. Could not login. \";\nconst MISSING_CREDENTIALS_MSG = \"Login credentials are required to access this space.\";\nconst NODEJS_FS_ERROR_MSG = \"File system access is only available in Node.js environments\";\nconst ROOT_URL_ERROR_MSG = \"Root URL not found in client config\";\nconst FILE_PROCESSING_ERROR_MSG = \"Error uploading file\";\nfunction resolve_root(base_url, root_path, prioritize_base) {\n  if (root_path.startsWith(\"http://\") || root_path.startsWith(\"https://\")) {\n    return prioritize_base ? base_url : root_path;\n  }\n  return base_url + root_path;\n}\nasync function get_jwt(space, token, cookies) {\n  try {\n    const r = await fetch(`https://huggingface.co/api/spaces/${space}/jwt`, {\n      headers: {\n        Authorization: `Bearer ${token}`,\n        ...(cookies ? {\n          Cookie: cookies\n        } : {})\n      }\n    });\n    const jwt = (await r.json()).token;\n    return jwt || false;\n  } catch (e) {\n    return false;\n  }\n}\nfunction map_names_to_ids(fns) {\n  let apis = {};\n  fns.forEach(({\n    api_name,\n    id\n  }) => {\n    if (api_name) apis[api_name] = id;\n  });\n  return apis;\n}\nasync function resolve_config(endpoint) {\n  var _a;\n  const headers = this.options.hf_token ? {\n    Authorization: `Bearer ${this.options.hf_token}`\n  } : {};\n  headers[\"Content-Type\"] = \"application/json\";\n  if (typeof window !== \"undefined\" && window.gradio_config && location.origin !== \"http://localhost:9876\" && !window.gradio_config.dev_mode) {\n    const path = window.gradio_config.root;\n    const config = window.gradio_config;\n    let config_root = resolve_root(endpoint, config.root, false);\n    config.root = config_root;\n    return {\n      ...config,\n      path\n    };\n  } else if (endpoint) {\n    const config_url = join_urls(endpoint, CONFIG_URL);\n    const response = await this.fetch(config_url, {\n      headers,\n      credentials: \"include\"\n    });\n    if ((response == null ? void 0 : response.status) === 401 && !this.options.auth) {\n      throw new Error(MISSING_CREDENTIALS_MSG);\n    } else if ((response == null ? void 0 : response.status) === 401 && this.options.auth) {\n      throw new Error(INVALID_CREDENTIALS_MSG);\n    }\n    if ((response == null ? void 0 : response.status) === 200) {\n      let config = await response.json();\n      config.path = config.path ?? \"\";\n      config.root = endpoint;\n      (_a = config.dependencies) == null ? void 0 : _a.forEach((dep, i) => {\n        if (dep.id === void 0) {\n          dep.id = i;\n        }\n      });\n      return config;\n    } else if ((response == null ? void 0 : response.status) === 401) {\n      throw new Error(UNAUTHORIZED_MSG);\n    }\n    throw new Error(CONFIG_ERROR_MSG);\n  }\n  throw new Error(CONFIG_ERROR_MSG);\n}\nasync function resolve_cookies() {\n  const {\n    http_protocol,\n    host\n  } = await process_endpoint(this.app_reference, this.options.hf_token);\n  try {\n    if (this.options.auth) {\n      const cookie_header = await get_cookie_header(http_protocol, host, this.options.auth, this.fetch, this.options.hf_token);\n      if (cookie_header) this.set_cookies(cookie_header);\n    }\n  } catch (e) {\n    throw Error(e.message);\n  }\n}\nasync function get_cookie_header(http_protocol, host, auth, _fetch, hf_token) {\n  const formData = new FormData();\n  formData.append(\"username\", auth == null ? void 0 : auth[0]);\n  formData.append(\"password\", auth == null ? void 0 : auth[1]);\n  let headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const res = await _fetch(`${http_protocol}//${host}/${LOGIN_URL}`, {\n    headers,\n    method: \"POST\",\n    body: formData,\n    credentials: \"include\"\n  });\n  if (res.status === 200) {\n    return res.headers.get(\"set-cookie\");\n  } else if (res.status === 401) {\n    throw new Error(INVALID_CREDENTIALS_MSG);\n  } else {\n    throw new Error(SPACE_METADATA_ERROR_MSG);\n  }\n}\nfunction determine_protocol(endpoint) {\n  if (endpoint.startsWith(\"http\")) {\n    const {\n      protocol,\n      host,\n      pathname\n    } = new URL(endpoint);\n    if (host.endsWith(\"hf.space\")) {\n      return {\n        ws_protocol: \"wss\",\n        host,\n        http_protocol: protocol\n      };\n    }\n    return {\n      ws_protocol: protocol === \"https:\" ? \"wss\" : \"ws\",\n      http_protocol: protocol,\n      host: host + (pathname !== \"/\" ? pathname : \"\")\n    };\n  } else if (endpoint.startsWith(\"file:\")) {\n    return {\n      ws_protocol: \"ws\",\n      http_protocol: \"http:\",\n      host: \"lite.local\"\n      // Special fake hostname only used for this case. This matches the hostname allowed in `is_self_host()` in `js/wasm/network/host.ts`.\n    };\n  }\n  return {\n    ws_protocol: \"wss\",\n    http_protocol: \"https:\",\n    host: new URL(endpoint).host\n  };\n}\nconst parse_and_set_cookies = cookie_header => {\n  let cookies = [];\n  const parts = cookie_header.split(/,(?=\\s*[^\\s=;]+=[^\\s=;]+)/);\n  parts.forEach(cookie => {\n    const [cookie_name, cookie_value] = cookie.split(\";\")[0].split(\"=\");\n    if (cookie_name && cookie_value) {\n      cookies.push(`${cookie_name.trim()}=${cookie_value.trim()}`);\n    }\n  });\n  return cookies;\n};\nconst RE_SPACE_NAME = /^[a-zA-Z0-9_\\-\\.]+\\/[a-zA-Z0-9_\\-\\.]+$/;\nconst RE_SPACE_DOMAIN = /.*hf\\.space\\/{0,1}$/;\nasync function process_endpoint(app_reference, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const _app_reference = app_reference.trim().replace(/\\/$/, \"\");\n  if (RE_SPACE_NAME.test(_app_reference)) {\n    try {\n      const res = await fetch(`https://huggingface.co/api/spaces/${_app_reference}/${HOST_URL}`, {\n        headers\n      });\n      const _host = (await res.json()).host;\n      return {\n        space_id: app_reference,\n        ...determine_protocol(_host)\n      };\n    } catch (e) {\n      throw new Error(SPACE_METADATA_ERROR_MSG);\n    }\n  }\n  if (RE_SPACE_DOMAIN.test(_app_reference)) {\n    const {\n      ws_protocol,\n      http_protocol,\n      host\n    } = determine_protocol(_app_reference);\n    return {\n      space_id: host.replace(\".hf.space\", \"\"),\n      ws_protocol,\n      http_protocol,\n      host\n    };\n  }\n  return {\n    space_id: false,\n    ...determine_protocol(_app_reference)\n  };\n}\nconst join_urls = (...urls) => {\n  try {\n    return urls.reduce((base_url, part) => {\n      base_url = base_url.replace(/\\/+$/, \"\");\n      part = part.replace(/^\\/+/, \"\");\n      return new URL(part, base_url + \"/\").toString();\n    });\n  } catch (e) {\n    throw new Error(INVALID_URL_MSG);\n  }\n};\nfunction transform_api_info(api_info, config, api_map) {\n  const transformed_info = {\n    named_endpoints: {},\n    unnamed_endpoints: {}\n  };\n  Object.keys(api_info).forEach(category => {\n    if (category === \"named_endpoints\" || category === \"unnamed_endpoints\") {\n      transformed_info[category] = {};\n      Object.entries(api_info[category]).forEach(([endpoint, {\n        parameters,\n        returns\n      }]) => {\n        var _a, _b, _c, _d;\n        const dependencyIndex = ((_a = config.dependencies.find(dep => dep.api_name === endpoint || dep.api_name === endpoint.replace(\"/\", \"\"))) == null ? void 0 : _a.id) || api_map[endpoint.replace(\"/\", \"\")] || -1;\n        const dependencyTypes = dependencyIndex !== -1 ? (_b = config.dependencies.find(dep => dep.id == dependencyIndex)) == null ? void 0 : _b.types : {\n          generator: false,\n          cancel: false\n        };\n        if (dependencyIndex !== -1 && ((_d = (_c = config.dependencies.find(dep => dep.id == dependencyIndex)) == null ? void 0 : _c.inputs) == null ? void 0 : _d.length) !== parameters.length) {\n          const components = config.dependencies.find(dep => dep.id == dependencyIndex).inputs.map(input => {\n            var _a2;\n            return (_a2 = config.components.find(c => c.id === input)) == null ? void 0 : _a2.type;\n          });\n          try {\n            components.forEach((comp, idx) => {\n              if (comp === \"state\") {\n                const new_param = {\n                  component: \"state\",\n                  example: null,\n                  parameter_default: null,\n                  parameter_has_default: true,\n                  parameter_name: null,\n                  hidden: true\n                };\n                parameters.splice(idx, 0, new_param);\n              }\n            });\n          } catch (e) {\n            console.error(e);\n          }\n        }\n        const transform_type = (data, component, serializer, signature_type) => ({\n          ...data,\n          description: get_description(data == null ? void 0 : data.type, serializer),\n          type: get_type(data == null ? void 0 : data.type, component, serializer, signature_type) || \"\"\n        });\n        transformed_info[category][endpoint] = {\n          parameters: parameters.map(p => transform_type(p, p == null ? void 0 : p.component, p == null ? void 0 : p.serializer, \"parameter\")),\n          returns: returns.map(r => transform_type(r, r == null ? void 0 : r.component, r == null ? void 0 : r.serializer, \"return\")),\n          type: dependencyTypes\n        };\n      });\n    }\n  });\n  return transformed_info;\n}\nfunction get_type(type, component, serializer, signature_type) {\n  switch (type == null ? void 0 : type.type) {\n    case \"string\":\n      return \"string\";\n    case \"boolean\":\n      return \"boolean\";\n    case \"number\":\n      return \"number\";\n  }\n  if (serializer === \"JSONSerializable\" || serializer === \"StringSerializable\") {\n    return \"any\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"string[]\";\n  } else if (component === \"Image\") {\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : \"string\";\n  } else if (serializer === \"FileSerializable\") {\n    if ((type == null ? void 0 : type.type) === \"array\") {\n      return signature_type === \"parameter\" ? \"(Blob | File | Buffer)[]\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]`;\n    }\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}`;\n  } else if (serializer === \"GallerySerializable\") {\n    return signature_type === \"parameter\" ? \"[(Blob | File | Buffer), (string | null)][]\" : `[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]`;\n  }\n}\nfunction get_description(type, serializer) {\n  if (serializer === \"GallerySerializable\") {\n    return \"array of [file, label] tuples\";\n  } else if (serializer === \"ListStringSerializable\") {\n    return \"array of strings\";\n  } else if (serializer === \"FileSerializable\") {\n    return \"array of files or single file\";\n  }\n  return type == null ? void 0 : type.description;\n}\nfunction handle_message(data, last_status) {\n  const queue = true;\n  switch (data.msg) {\n    case \"send_data\":\n      return {\n        type: \"data\"\n      };\n    case \"send_hash\":\n      return {\n        type: \"hash\"\n      };\n    case \"queue_full\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          message: QUEUE_FULL_MSG,\n          stage: \"error\",\n          code: data.code,\n          success: data.success\n        }\n      };\n    case \"heartbeat\":\n      return {\n        type: \"heartbeat\"\n      };\n    case \"unexpected_error\":\n      return {\n        type: \"unexpected_error\",\n        status: {\n          queue,\n          message: data.message,\n          stage: \"error\",\n          success: false\n        }\n      };\n    case \"estimation\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: last_status || \"pending\",\n          code: data.code,\n          size: data.queue_size,\n          position: data.rank,\n          eta: data.rank_eta,\n          success: data.success\n        }\n      };\n    case \"progress\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          progress_data: data.progress_data,\n          success: data.success\n        }\n      };\n    case \"log\":\n      return {\n        type: \"log\",\n        data\n      };\n    case \"process_generating\":\n      return {\n        type: \"generating\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : null,\n          stage: data.success ? \"generating\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          eta: data.average_duration,\n          changed_state_ids: data.success ? data.output.changed_state_ids : void 0\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_streaming\":\n      return {\n        type: \"streaming\",\n        status: {\n          queue,\n          message: data.output.error,\n          stage: \"streaming\",\n          time_limit: data.time_limit,\n          code: data.code,\n          progress_data: data.progress_data,\n          eta: data.eta\n        },\n        data: data.output\n      };\n    case \"process_completed\":\n      if (\"error\" in data.output) {\n        return {\n          type: \"update\",\n          status: {\n            queue,\n            message: data.output.error,\n            visible: data.output.visible,\n            duration: data.output.duration,\n            stage: \"error\",\n            code: data.code,\n            success: data.success\n          }\n        };\n      }\n      return {\n        type: \"complete\",\n        status: {\n          queue,\n          message: !data.success ? data.output.error : void 0,\n          stage: data.success ? \"complete\" : \"error\",\n          code: data.code,\n          progress_data: data.progress_data,\n          changed_state_ids: data.success ? data.output.changed_state_ids : void 0\n        },\n        data: data.success ? data.output : null\n      };\n    case \"process_starts\":\n      return {\n        type: \"update\",\n        status: {\n          queue,\n          stage: \"pending\",\n          code: data.code,\n          size: data.rank,\n          position: 0,\n          success: data.success,\n          eta: data.eta\n        },\n        original_msg: \"process_starts\"\n      };\n  }\n  return {\n    type: \"none\",\n    status: {\n      stage: \"error\",\n      queue\n    }\n  };\n}\nconst map_data_to_params = (data = [], endpoint_info) => {\n  const parameters = endpoint_info ? endpoint_info.parameters : [];\n  if (Array.isArray(data)) {\n    if (data.length > parameters.length) {\n      console.warn(\"Too many arguments provided for the endpoint.\");\n    }\n    return data;\n  }\n  const resolved_data = [];\n  const provided_keys = Object.keys(data);\n  parameters.forEach((param, index) => {\n    if (data.hasOwnProperty(param.parameter_name)) {\n      resolved_data[index] = data[param.parameter_name];\n    } else if (param.parameter_has_default) {\n      resolved_data[index] = param.parameter_default;\n    } else {\n      throw new Error(`No value provided for required parameter: ${param.parameter_name}`);\n    }\n  });\n  provided_keys.forEach(key => {\n    if (!parameters.some(param => param.parameter_name === key)) {\n      throw new Error(`Parameter \\`${key}\\` is not a valid keyword argument. Please refer to the API for usage.`);\n    }\n  });\n  resolved_data.forEach((value, idx) => {\n    if (value === void 0 && !parameters[idx].parameter_has_default) {\n      throw new Error(`No value provided for required parameter: ${parameters[idx].parameter_name}`);\n    }\n  });\n  return resolved_data;\n};\nasync function view_api() {\n  if (this.api_info) return this.api_info;\n  const {\n    hf_token\n  } = this.options;\n  const {\n    config\n  } = this;\n  const headers = {\n    \"Content-Type\": \"application/json\"\n  };\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  if (!config) {\n    return;\n  }\n  try {\n    let response;\n    let api_info;\n    if (typeof window !== \"undefined\" && window.gradio_api_info) {\n      api_info = window.gradio_api_info;\n    } else {\n      if (semiver((config == null ? void 0 : config.version) || \"2.0.0\", \"3.30\") < 0) {\n        response = await this.fetch(SPACE_FETCHER_URL, {\n          method: \"POST\",\n          body: JSON.stringify({\n            serialize: false,\n            config: JSON.stringify(config)\n          }),\n          headers,\n          credentials: \"include\"\n        });\n      } else {\n        const url = join_urls(config.root, this.api_prefix, API_INFO_URL);\n        response = await this.fetch(url, {\n          headers,\n          credentials: \"include\"\n        });\n      }\n      if (!response.ok) {\n        throw new Error(BROKEN_CONNECTION_MSG);\n      }\n      api_info = await response.json();\n    }\n    if (\"api\" in api_info) {\n      api_info = api_info.api;\n    }\n    if (api_info.named_endpoints[\"/predict\"] && !api_info.unnamed_endpoints[\"0\"]) {\n      api_info.unnamed_endpoints[0] = api_info.named_endpoints[\"/predict\"];\n    }\n    return transform_api_info(api_info, config, this.api_map);\n  } catch (e) {\n    \"Could not get API info. \" + e.message;\n  }\n}\nasync function upload_files(root_url, files, upload_id) {\n  var _a;\n  const headers = {};\n  if ((_a = this == null ? void 0 : this.options) == null ? void 0 : _a.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  const chunkSize = 1e3;\n  const uploadResponses = [];\n  let response;\n  for (let i = 0; i < files.length; i += chunkSize) {\n    const chunk = files.slice(i, i + chunkSize);\n    const formData = new FormData();\n    chunk.forEach(file => {\n      formData.append(\"files\", file);\n    });\n    try {\n      const upload_url = upload_id ? `${root_url}${this.api_prefix}/${UPLOAD_URL}?upload_id=${upload_id}` : `${root_url}${this.api_prefix}/${UPLOAD_URL}`;\n      response = await this.fetch(upload_url, {\n        method: \"POST\",\n        body: formData,\n        headers,\n        credentials: \"include\"\n      });\n    } catch (e) {\n      throw new Error(BROKEN_CONNECTION_MSG + e.message);\n    }\n    if (!response.ok) {\n      const error_text = await response.text();\n      return {\n        error: `HTTP ${response.status}: ${error_text}`\n      };\n    }\n    const output = await response.json();\n    if (output) {\n      uploadResponses.push(...output);\n    }\n  }\n  return {\n    files: uploadResponses\n  };\n}\nasync function upload(file_data, root_url, upload_id, max_file_size) {\n  let files = (Array.isArray(file_data) ? file_data : [file_data]).map(file_data2 => file_data2.blob);\n  const oversized_files = files.filter(f => f.size > (max_file_size ?? Infinity));\n  if (oversized_files.length) {\n    throw new Error(`File size exceeds the maximum allowed size of ${max_file_size} bytes: ${oversized_files.map(f => f.name).join(\", \")}`);\n  }\n  return await Promise.all(await this.upload_files(root_url, files, upload_id).then(async response => {\n    if (response.error) {\n      throw new Error(response.error);\n    } else {\n      if (response.files) {\n        return response.files.map((f, i) => {\n          const file = new FileData({\n            ...file_data[i],\n            path: f,\n            url: `${root_url}${this.api_prefix}/file=${f}`\n          });\n          return file;\n        });\n      }\n      return [];\n    }\n  }));\n}\nasync function prepare_files(files, is_stream) {\n  return files.map(f => new FileData({\n    path: f.name,\n    orig_name: f.name,\n    blob: f,\n    size: f.size,\n    mime_type: f.type,\n    is_stream\n  }));\n}\nclass FileData {\n  constructor({\n    path,\n    url,\n    orig_name,\n    size,\n    blob,\n    is_stream,\n    mime_type,\n    alt_text\n  }) {\n    __publicField(this, \"path\");\n    __publicField(this, \"url\");\n    __publicField(this, \"orig_name\");\n    __publicField(this, \"size\");\n    __publicField(this, \"blob\");\n    __publicField(this, \"is_stream\");\n    __publicField(this, \"mime_type\");\n    __publicField(this, \"alt_text\");\n    __publicField(this, \"meta\", {\n      _type: \"gradio.FileData\"\n    });\n    this.path = path;\n    this.url = url;\n    this.orig_name = orig_name;\n    this.size = size;\n    this.blob = url ? void 0 : blob;\n    this.is_stream = is_stream;\n    this.mime_type = mime_type;\n    this.alt_text = alt_text;\n  }\n}\nclass Command {\n  constructor(command, meta) {\n    __publicField(this, \"type\");\n    __publicField(this, \"command\");\n    __publicField(this, \"meta\");\n    __publicField(this, \"fileData\");\n    this.type = \"command\";\n    this.command = command;\n    this.meta = meta;\n  }\n}\nconst is_node = typeof process !== \"undefined\" && process.versions && process.versions.node;\nfunction update_object(object, newValue, stack) {\n  while (stack.length > 1) {\n    const key2 = stack.shift();\n    if (typeof key2 === \"string\" || typeof key2 === \"number\") {\n      object = object[key2];\n    } else {\n      throw new Error(\"Invalid key type\");\n    }\n  }\n  const key = stack.shift();\n  if (typeof key === \"string\" || typeof key === \"number\") {\n    object[key] = newValue;\n  } else {\n    throw new Error(\"Invalid key type\");\n  }\n}\nasync function walk_and_store_blobs(data, type = void 0, path = [], root = false, endpoint_info = void 0) {\n  if (Array.isArray(data)) {\n    let blob_refs = [];\n    await Promise.all(data.map(async (_, index) => {\n      var _a;\n      let new_path = path.slice();\n      new_path.push(String(index));\n      const array_refs = await walk_and_store_blobs(data[index], root ? ((_a = endpoint_info == null ? void 0 : endpoint_info.parameters[index]) == null ? void 0 : _a.component) || void 0 : type, new_path, false, endpoint_info);\n      blob_refs = blob_refs.concat(array_refs);\n    }));\n    return blob_refs;\n  } else if (globalThis.Buffer && data instanceof globalThis.Buffer || data instanceof Blob) {\n    return [{\n      path,\n      blob: new Blob([data]),\n      type\n    }];\n  } else if (typeof data === \"object\" && data !== null) {\n    let blob_refs = [];\n    for (const key of Object.keys(data)) {\n      const new_path = [...path, key];\n      const value = data[key];\n      blob_refs = blob_refs.concat(await walk_and_store_blobs(value, void 0, new_path, false, endpoint_info));\n    }\n    return blob_refs;\n  }\n  return [];\n}\nfunction skip_queue(id, config) {\n  var _a, _b;\n  let fn_queue = (_b = (_a = config == null ? void 0 : config.dependencies) == null ? void 0 : _a.find(dep => dep.id == id)) == null ? void 0 : _b.queue;\n  if (fn_queue != null) {\n    return !fn_queue;\n  }\n  return !config.enable_queue;\n}\nfunction post_message(message, origin) {\n  return new Promise((res, _rej) => {\n    const channel = new MessageChannel();\n    channel.port1.onmessage = ({\n      data\n    }) => {\n      channel.port1.close();\n      res(data);\n    };\n    window.parent.postMessage(message, origin, [channel.port2]);\n  });\n}\nfunction handle_file(file_or_url) {\n  if (typeof file_or_url === \"string\") {\n    if (file_or_url.startsWith(\"http://\") || file_or_url.startsWith(\"https://\")) {\n      return {\n        path: file_or_url,\n        url: file_or_url,\n        orig_name: file_or_url.split(\"/\").pop() ?? \"unknown\",\n        meta: {\n          _type: \"gradio.FileData\"\n        }\n      };\n    }\n    if (is_node) {\n      return new Command(\"upload_file\", {\n        path: file_or_url,\n        name: file_or_url,\n        orig_path: file_or_url\n      });\n    }\n  } else if (typeof File !== \"undefined\" && file_or_url instanceof File) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Buffer) {\n    return new Blob([file_or_url]);\n  } else if (file_or_url instanceof Blob) {\n    return file_or_url;\n  }\n  throw new Error(\"Invalid input: must be a URL, File, Blob, or Buffer object.\");\n}\nfunction handle_payload(resolved_payload, dependency, components, type, with_null_state = false) {\n  if (type === \"input\" && !with_null_state) {\n    throw new Error(\"Invalid code path. Cannot skip state inputs for input.\");\n  }\n  if (type === \"output\" && with_null_state) {\n    return resolved_payload;\n  }\n  let updated_payload = [];\n  let payload_index = 0;\n  const deps = type === \"input\" ? dependency.inputs : dependency.outputs;\n  for (let i = 0; i < deps.length; i++) {\n    const input_id = deps[i];\n    const component = components.find(c => c.id === input_id);\n    if ((component == null ? void 0 : component.type) === \"state\") {\n      if (with_null_state) {\n        if (resolved_payload.length === deps.length) {\n          const value = resolved_payload[payload_index];\n          updated_payload.push(value);\n          payload_index++;\n        } else {\n          updated_payload.push(null);\n        }\n      } else {\n        payload_index++;\n        continue;\n      }\n      continue;\n    } else {\n      const value = resolved_payload[payload_index];\n      updated_payload.push(value);\n      payload_index++;\n    }\n  }\n  return updated_payload;\n}\nasync function handle_blob(endpoint, data, api_info) {\n  const self = this;\n  await process_local_file_commands(self, data);\n  const blobRefs = await walk_and_store_blobs(data, void 0, [], true, api_info);\n  const results = await Promise.all(blobRefs.map(async ({\n    path,\n    blob,\n    type\n  }) => {\n    if (!blob) return {\n      path,\n      type\n    };\n    const response = await self.upload_files(endpoint, [blob]);\n    const file_url = response.files && response.files[0];\n    return {\n      path,\n      file_url,\n      type,\n      name: typeof File !== \"undefined\" && blob instanceof File ? blob == null ? void 0 : blob.name : void 0\n    };\n  }));\n  results.forEach(({\n    path,\n    file_url,\n    type,\n    name\n  }) => {\n    if (type === \"Gallery\") {\n      update_object(data, file_url, path);\n    } else if (file_url) {\n      const file = new FileData({\n        path: file_url,\n        orig_name: name\n      });\n      update_object(data, file, path);\n    }\n  });\n  return data;\n}\nasync function process_local_file_commands(client2, data) {\n  var _a, _b;\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  await recursively_process_commands(client2, data);\n}\nasync function recursively_process_commands(client2, data, path = []) {\n  for (const key in data) {\n    if (data[key] instanceof Command) {\n      await process_single_command(client2, data, key);\n    } else if (typeof data[key] === \"object\" && data[key] !== null) {\n      await recursively_process_commands(client2, data[key], [...path, key]);\n    }\n  }\n}\nasync function process_single_command(client2, data, key) {\n  var _a, _b;\n  let cmd_item = data[key];\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\n  if (!root) {\n    throw new Error(ROOT_URL_ERROR_MSG);\n  }\n  try {\n    let fileBuffer;\n    let fullPath;\n    if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\n      const fs = await import(\"fs/promises\");\n      const path = await import(\"path\");\n      fullPath = path.resolve(process.cwd(), cmd_item.meta.path);\n      fileBuffer = await fs.readFile(fullPath);\n    } else {\n      throw new Error(NODEJS_FS_ERROR_MSG);\n    }\n    const file = new Blob([fileBuffer], {\n      type: \"application/octet-stream\"\n    });\n    const response = await client2.upload_files(root, [file]);\n    const file_url = response.files && response.files[0];\n    if (file_url) {\n      const fileData = new FileData({\n        path: file_url,\n        orig_name: cmd_item.meta.name || \"\"\n      });\n      data[key] = fileData;\n    }\n  } catch (error) {\n    console.error(FILE_PROCESSING_ERROR_MSG, error);\n  }\n}\nasync function post_data(url, body, additional_headers) {\n  const headers = {\n    \"Content-Type\": \"application/json\"\n  };\n  if (this.options.hf_token) {\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\n  }\n  try {\n    var response = await this.fetch(url, {\n      method: \"POST\",\n      body: JSON.stringify(body),\n      headers: {\n        ...headers,\n        ...additional_headers\n      },\n      credentials: \"include\"\n    });\n  } catch (e) {\n    return [{\n      error: BROKEN_CONNECTION_MSG\n    }, 500];\n  }\n  let output;\n  let status;\n  try {\n    output = await response.json();\n    status = response.status;\n  } catch (e) {\n    output = {\n      error: `Could not parse server response: ${e}`\n    };\n    status = 500;\n  }\n  return [output, status];\n}\nasync function predict(endpoint, data = {}) {\n  let data_returned = false;\n  let status_complete = false;\n  if (!this.config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  if (typeof endpoint === \"number\") {\n    this.config.dependencies.find(dep => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    this.config.dependencies.find(dep => dep.id == this.api_map[trimmed_endpoint]);\n  }\n  return new Promise(async (resolve, reject) => {\n    const app = this.submit(endpoint, data, null, null, true);\n    let result;\n    for await (const message of app) {\n      if (message.type === \"data\") {\n        if (status_complete) {\n          resolve(result);\n        }\n        data_returned = true;\n        result = message;\n      }\n      if (message.type === \"status\") {\n        if (message.stage === \"error\") reject(message);\n        if (message.stage === \"complete\") {\n          status_complete = true;\n          if (data_returned) {\n            resolve(result);\n          }\n        }\n      }\n    }\n  });\n}\nasync function check_space_status(id, type, status_callback) {\n  let endpoint = type === \"subdomain\" ? `https://huggingface.co/api/spaces/by-subdomain/${id}` : `https://huggingface.co/api/spaces/${id}`;\n  let response;\n  let _status;\n  try {\n    response = await fetch(endpoint);\n    _status = response.status;\n    if (_status !== 200) {\n      throw new Error();\n    }\n    response = await response.json();\n  } catch (e) {\n    status_callback({\n      status: \"error\",\n      load_status: \"error\",\n      message: SPACE_STATUS_ERROR_MSG,\n      detail: \"NOT_FOUND\"\n    });\n    return;\n  }\n  if (!response || _status !== 200) return;\n  const {\n    runtime: {\n      stage\n    },\n    id: space_name\n  } = response;\n  switch (stage) {\n    case \"STOPPED\":\n    case \"SLEEPING\":\n      status_callback({\n        status: \"sleeping\",\n        load_status: \"pending\",\n        message: \"Space is asleep. Waking it up...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"PAUSED\":\n      status_callback({\n        status: \"paused\",\n        load_status: \"error\",\n        message: \"This space has been paused by the author. If you would like to try this demo, consider duplicating the space.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n    case \"RUNNING\":\n    case \"RUNNING_BUILDING\":\n      status_callback({\n        status: \"running\",\n        load_status: \"complete\",\n        message: \"Space is running.\",\n        detail: stage\n      });\n      break;\n    case \"BUILDING\":\n      status_callback({\n        status: \"building\",\n        load_status: \"pending\",\n        message: \"Space is building...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    case \"APP_STARTING\":\n      status_callback({\n        status: \"starting\",\n        load_status: \"pending\",\n        message: \"Space is starting...\",\n        detail: stage\n      });\n      setTimeout(() => {\n        check_space_status(id, type, status_callback);\n      }, 1e3);\n      break;\n    default:\n      status_callback({\n        status: \"space_error\",\n        load_status: \"error\",\n        message: \"This space is experiencing an issue.\",\n        detail: stage,\n        discussions_enabled: await discussions_enabled(space_name)\n      });\n      break;\n  }\n}\nconst check_and_wake_space = async (space_id, status_callback) => {\n  let retries = 0;\n  const max_retries = 12;\n  const check_interval = 5e3;\n  return new Promise(resolve => {\n    check_space_status(space_id, RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\", status => {\n      status_callback(status);\n      if (status.status === \"running\") {\n        resolve();\n      } else if (status.status === \"error\" || status.status === \"paused\" || status.status === \"space_error\") {\n        resolve();\n      } else if (status.status === \"sleeping\" || status.status === \"building\") {\n        if (retries < max_retries) {\n          retries++;\n          setTimeout(() => {\n            check_and_wake_space(space_id, status_callback).then(resolve);\n          }, check_interval);\n        } else {\n          resolve();\n        }\n      }\n    });\n  });\n};\nconst RE_DISABLED_DISCUSSION = /^(?=[^]*\\b[dD]iscussions{0,1}\\b)(?=[^]*\\b[dD]isabled\\b)[^]*$/;\nasync function discussions_enabled(space_id) {\n  try {\n    const r = await fetch(`https://huggingface.co/api/spaces/${space_id}/discussions`, {\n      method: \"HEAD\"\n    });\n    const error = r.headers.get(\"x-error-message\");\n    if (!r.ok || error && RE_DISABLED_DISCUSSION.test(error)) return false;\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nasync function get_space_hardware(space_id, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  try {\n    const res = await fetch(`https://huggingface.co/api/spaces/${space_id}/${RUNTIME_URL}`, {\n      headers\n    });\n    if (res.status !== 200) throw new Error(\"Space hardware could not be obtained.\");\n    const {\n      hardware\n    } = await res.json();\n    return hardware.current;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nasync function set_space_timeout(space_id, timeout, hf_token) {\n  const headers = {};\n  if (hf_token) {\n    headers.Authorization = `Bearer ${hf_token}`;\n  }\n  const body = {\n    seconds: timeout\n  };\n  try {\n    const res = await fetch(`https://huggingface.co/api/spaces/${space_id}/${SLEEPTIME_URL}`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      body: JSON.stringify(body)\n    });\n    if (res.status !== 200) {\n      throw new Error(\"Could not set sleep timeout on duplicated Space. Please visit *ADD HF LINK TO SETTINGS* to set a timeout manually to reduce billing charges.\");\n    }\n    const response = await res.json();\n    return response;\n  } catch (e) {\n    throw new Error(e.message);\n  }\n}\nconst hardware_types = [\"cpu-basic\", \"cpu-upgrade\", \"cpu-xl\", \"t4-small\", \"t4-medium\", \"a10g-small\", \"a10g-large\", \"a10g-largex2\", \"a10g-largex4\", \"a100-large\", \"zero-a10g\", \"h100\", \"h100x8\"];\nasync function duplicate(app_reference, options) {\n  const {\n    hf_token,\n    private: _private,\n    hardware,\n    timeout,\n    auth\n  } = options;\n  if (hardware && !hardware_types.includes(hardware)) {\n    throw new Error(`Invalid hardware type provided. Valid types are: ${hardware_types.map(v => `\"${v}\"`).join(\",\")}.`);\n  }\n  const {\n    http_protocol,\n    host\n  } = await process_endpoint(app_reference, hf_token);\n  let cookies = null;\n  if (auth) {\n    const cookie_header = await get_cookie_header(http_protocol, host, auth, fetch);\n    if (cookie_header) cookies = parse_and_set_cookies(cookie_header);\n  }\n  const headers = {\n    Authorization: `Bearer ${hf_token}`,\n    \"Content-Type\": \"application/json\",\n    ...(cookies ? {\n      Cookie: cookies.join(\"; \")\n    } : {})\n  };\n  const user = (await (await fetch(`https://huggingface.co/api/whoami-v2`, {\n    headers\n  })).json()).name;\n  const space_name = app_reference.split(\"/\")[1];\n  const body = {\n    repository: `${user}/${space_name}`\n  };\n  if (_private) {\n    body.private = true;\n  }\n  let original_hardware;\n  try {\n    if (!hardware) {\n      original_hardware = await get_space_hardware(app_reference, hf_token);\n    }\n  } catch (e) {\n    throw Error(SPACE_METADATA_ERROR_MSG + e.message);\n  }\n  const requested_hardware = hardware || original_hardware || \"cpu-basic\";\n  body.hardware = requested_hardware;\n  try {\n    const response = await fetch(`https://huggingface.co/api/spaces/${app_reference}/duplicate`, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify(body)\n    });\n    if (response.status === 409) {\n      try {\n        const client2 = await Client.connect(`${user}/${space_name}`, options);\n        return client2;\n      } catch (error) {\n        console.error(\"Failed to connect Client instance:\", error);\n        throw error;\n      }\n    } else if (response.status !== 200) {\n      throw new Error(response.statusText);\n    }\n    const duplicated_space = await response.json();\n    await set_space_timeout(`${user}/${space_name}`, timeout || 300, hf_token);\n    return await Client.connect(get_space_reference(duplicated_space.url), options);\n  } catch (e) {\n    throw new Error(e);\n  }\n}\nfunction get_space_reference(url) {\n  const regex = /https:\\/\\/huggingface.co\\/spaces\\/([^/]+\\/[^/]+)/;\n  const match = url.match(regex);\n  if (match) {\n    return match[1];\n  }\n}\nclass TextLineStream extends TransformStream {\n  /** Constructs a new instance. */\n  constructor(options = {\n    allowCR: false\n  }) {\n    super({\n      transform: (chars, controller) => {\n        chars = __privateGet(this, _currentLine) + chars;\n        while (true) {\n          const lfIndex = chars.indexOf(\"\\n\");\n          const crIndex = options.allowCR ? chars.indexOf(\"\\r\") : -1;\n          if (crIndex !== -1 && crIndex !== chars.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {\n            controller.enqueue(chars.slice(0, crIndex));\n            chars = chars.slice(crIndex + 1);\n            continue;\n          }\n          if (lfIndex === -1) break;\n          const endIndex = chars[lfIndex - 1] === \"\\r\" ? lfIndex - 1 : lfIndex;\n          controller.enqueue(chars.slice(0, endIndex));\n          chars = chars.slice(lfIndex + 1);\n        }\n        __privateSet(this, _currentLine, chars);\n      },\n      flush: controller => {\n        if (__privateGet(this, _currentLine) === \"\") return;\n        const currentLine = options.allowCR && __privateGet(this, _currentLine).endsWith(\"\\r\") ? __privateGet(this, _currentLine).slice(0, -1) : __privateGet(this, _currentLine);\n        controller.enqueue(currentLine);\n      }\n    });\n    __privateAdd(this, _currentLine, \"\");\n  }\n}\n_currentLine = new WeakMap();\nfunction stream$1(input) {\n  let decoder = new TextDecoderStream();\n  let split2 = new TextLineStream({\n    allowCR: true\n  });\n  return input.pipeThrough(decoder).pipeThrough(split2);\n}\nfunction split(input) {\n  let rgx = /[:]\\s*/;\n  let match = rgx.exec(input);\n  let idx = match && match.index;\n  if (idx) {\n    return [input.substring(0, idx), input.substring(idx + match[0].length)];\n  }\n}\nfunction fallback(headers, key, value) {\n  let tmp = headers.get(key);\n  if (!tmp) headers.set(key, value);\n}\nasync function* events(res, signal) {\n  if (!res.body) return;\n  let iter = stream$1(res.body);\n  let line,\n    reader = iter.getReader();\n  let event;\n  for (;;) {\n    if (signal && signal.aborted) {\n      return reader.cancel();\n    }\n    line = await reader.read();\n    if (line.done) return;\n    if (!line.value) {\n      if (event) yield event;\n      event = void 0;\n      continue;\n    }\n    let [field, value] = split(line.value) || [];\n    if (!field) continue;\n    if (field === \"data\") {\n      event || (event = {});\n      event[field] = event[field] ? event[field] + \"\\n\" + value : value;\n    } else if (field === \"event\") {\n      event || (event = {});\n      event[field] = value;\n    } else if (field === \"id\") {\n      event || (event = {});\n      event[field] = +value || value;\n    } else if (field === \"retry\") {\n      event || (event = {});\n      event[field] = +value || void 0;\n    }\n  }\n}\nasync function stream(input, init) {\n  let req = new Request(input, init);\n  fallback(req.headers, \"Accept\", \"text/event-stream\");\n  fallback(req.headers, \"Content-Type\", \"application/json\");\n  let r = await fetch(req);\n  if (!r.ok) throw r;\n  return events(r, req.signal);\n}\nasync function open_stream() {\n  let {\n    event_callbacks,\n    unclosed_events,\n    pending_stream_messages,\n    stream_status,\n    config,\n    jwt\n  } = this;\n  const that = this;\n  if (!config) {\n    throw new Error(\"Could not resolve app config\");\n  }\n  stream_status.open = true;\n  let stream2 = null;\n  let params = new URLSearchParams({\n    session_hash: this.session_hash\n  }).toString();\n  let url = new URL(`${config.root}${this.api_prefix}/${SSE_URL}?${params}`);\n  if (jwt) {\n    url.searchParams.set(\"__sign\", jwt);\n  }\n  stream2 = this.stream(url);\n  if (!stream2) {\n    console.warn(\"Cannot connect to SSE endpoint: \" + url.toString());\n    return;\n  }\n  stream2.onmessage = async function (event) {\n    let _data = JSON.parse(event.data);\n    if (_data.msg === \"close_stream\") {\n      close_stream(stream_status, that.abort_controller);\n      return;\n    }\n    const event_id = _data.event_id;\n    if (!event_id) {\n      await Promise.all(Object.keys(event_callbacks).map(event_id2 => event_callbacks[event_id2](_data)));\n    } else if (event_callbacks[event_id] && config) {\n      if (_data.msg === \"process_completed\" && [\"sse\", \"sse_v1\", \"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(config.protocol)) {\n        unclosed_events.delete(event_id);\n      }\n      let fn2 = event_callbacks[event_id];\n      if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n        setTimeout(fn2, 0, _data);\n      } else {\n        fn2(_data);\n      }\n    } else {\n      if (!pending_stream_messages[event_id]) {\n        pending_stream_messages[event_id] = [];\n      }\n      pending_stream_messages[event_id].push(_data);\n    }\n  };\n  stream2.onerror = async function () {\n    await Promise.all(Object.keys(event_callbacks).map(event_id => event_callbacks[event_id]({\n      msg: \"unexpected_error\",\n      message: BROKEN_CONNECTION_MSG\n    })));\n  };\n}\nfunction close_stream(stream_status, abort_controller) {\n  if (stream_status) {\n    stream_status.open = false;\n    abort_controller == null ? void 0 : abort_controller.abort();\n  }\n}\nfunction apply_diff_stream(pending_diff_streams, event_id, data) {\n  let is_first_generation = !pending_diff_streams[event_id];\n  if (is_first_generation) {\n    pending_diff_streams[event_id] = [];\n    data.data.forEach((value, i) => {\n      pending_diff_streams[event_id][i] = value;\n    });\n  } else {\n    data.data.forEach((value, i) => {\n      let new_data = apply_diff(pending_diff_streams[event_id][i], value);\n      pending_diff_streams[event_id][i] = new_data;\n      data.data[i] = new_data;\n    });\n  }\n}\nfunction apply_diff(obj, diff) {\n  diff.forEach(([action, path, value]) => {\n    obj = apply_edit(obj, path, action, value);\n  });\n  return obj;\n}\nfunction apply_edit(target, path, action, value) {\n  if (path.length === 0) {\n    if (action === \"replace\") {\n      return value;\n    } else if (action === \"append\") {\n      return target + value;\n    }\n    throw new Error(`Unsupported action: ${action}`);\n  }\n  let current = target;\n  for (let i = 0; i < path.length - 1; i++) {\n    current = current[path[i]];\n  }\n  const last_path = path[path.length - 1];\n  switch (action) {\n    case \"replace\":\n      current[last_path] = value;\n      break;\n    case \"append\":\n      current[last_path] += value;\n      break;\n    case \"add\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 0, value);\n      } else {\n        current[last_path] = value;\n      }\n      break;\n    case \"delete\":\n      if (Array.isArray(current)) {\n        current.splice(Number(last_path), 1);\n      } else {\n        delete current[last_path];\n      }\n      break;\n    default:\n      throw new Error(`Unknown action: ${action}`);\n  }\n  return target;\n}\nfunction readable_stream(input, init = {}) {\n  const instance = {\n    close: () => {\n      console.warn(\"Method not implemented.\");\n    },\n    onerror: null,\n    onmessage: null,\n    onopen: null,\n    readyState: 0,\n    url: input.toString(),\n    withCredentials: false,\n    CONNECTING: 0,\n    OPEN: 1,\n    CLOSED: 2,\n    addEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    dispatchEvent: () => {\n      throw new Error(\"Method not implemented.\");\n    },\n    removeEventListener: () => {\n      throw new Error(\"Method not implemented.\");\n    }\n  };\n  stream(input, init).then(async res => {\n    instance.readyState = instance.OPEN;\n    try {\n      for await (const chunk of res) {\n        instance.onmessage && instance.onmessage(chunk);\n      }\n      instance.readyState = instance.CLOSED;\n    } catch (e) {\n      instance.onerror && instance.onerror(e);\n      instance.readyState = instance.CLOSED;\n    }\n  }).catch(e => {\n    console.error(e);\n    instance.onerror && instance.onerror(e);\n    instance.readyState = instance.CLOSED;\n  });\n  return instance;\n}\nfunction submit(endpoint, data = {}, event_data, trigger_id, all_events) {\n  var _a;\n  try {\n    let fire_event = function (event) {\n        if (all_events || events_to_publish[event.type]) {\n          push_event(event);\n        }\n      },\n      close = function () {\n        done = true;\n        while (resolvers.length > 0) resolvers.shift()({\n          value: void 0,\n          done: true\n        });\n      },\n      push = function (data2) {\n        if (done) return;\n        if (resolvers.length > 0) {\n          resolvers.shift()(data2);\n        } else {\n          values.push(data2);\n        }\n      },\n      push_error = function (error) {\n        push(thenable_reject(error));\n        close();\n      },\n      push_event = function (event) {\n        push({\n          value: event,\n          done: false\n        });\n      },\n      next = function () {\n        if (values.length > 0) return Promise.resolve(values.shift());\n        if (done) return Promise.resolve({\n          value: void 0,\n          done: true\n        });\n        return new Promise(resolve => resolvers.push(resolve));\n      };\n    const {\n      hf_token\n    } = this.options;\n    const {\n      fetch: fetch2,\n      app_reference,\n      config,\n      session_hash,\n      api_info,\n      api_map,\n      stream_status,\n      pending_stream_messages,\n      pending_diff_streams,\n      event_callbacks,\n      unclosed_events,\n      post_data: post_data2,\n      options,\n      api_prefix\n    } = this;\n    const that = this;\n    if (!api_info) throw new Error(\"No API found\");\n    if (!config) throw new Error(\"Could not resolve app config\");\n    let {\n      fn_index,\n      endpoint_info,\n      dependency\n    } = get_endpoint_info(api_info, endpoint, api_map, config);\n    let resolved_data = map_data_to_params(data, endpoint_info);\n    let websocket;\n    let stream2;\n    let protocol = config.protocol ?? \"ws\";\n    let event_id_final = \"\";\n    let event_id_cb = () => event_id_final;\n    const _endpoint = typeof endpoint === \"number\" ? \"/predict\" : endpoint;\n    let payload;\n    let event_id = null;\n    let complete = false;\n    let last_status = {};\n    let url_params = typeof window !== \"undefined\" && typeof document !== \"undefined\" ? new URLSearchParams(window.location.search).toString() : \"\";\n    const events_to_publish = ((_a = options == null ? void 0 : options.events) == null ? void 0 : _a.reduce((acc, event) => {\n      acc[event] = true;\n      return acc;\n    }, {})) || {};\n    async function cancel() {\n      const _status = {\n        stage: \"complete\",\n        queue: false,\n        time: /* @__PURE__ */new Date()\n      };\n      complete = _status;\n      fire_event({\n        ..._status,\n        type: \"status\",\n        endpoint: _endpoint,\n        fn_index\n      });\n      let reset_request = {};\n      let cancel_request = {};\n      if (protocol === \"ws\") {\n        if (websocket && websocket.readyState === 0) {\n          websocket.addEventListener(\"open\", () => {\n            websocket.close();\n          });\n        } else {\n          websocket.close();\n        }\n        reset_request = {\n          fn_index,\n          session_hash\n        };\n      } else {\n        close_stream(stream_status, that.abort_controller);\n        close();\n        reset_request = {\n          event_id\n        };\n        cancel_request = {\n          event_id,\n          session_hash,\n          fn_index\n        };\n      }\n      try {\n        if (!config) {\n          throw new Error(\"Could not resolve app config\");\n        }\n        if (\"event_id\" in cancel_request) {\n          await fetch2(`${config.root}${api_prefix}/${CANCEL_URL}`, {\n            headers: {\n              \"Content-Type\": \"application/json\"\n            },\n            method: \"POST\",\n            body: JSON.stringify(cancel_request)\n          });\n        }\n        await fetch2(`${config.root}${api_prefix}/${RESET_URL}`, {\n          headers: {\n            \"Content-Type\": \"application/json\"\n          },\n          method: \"POST\",\n          body: JSON.stringify(reset_request)\n        });\n      } catch (e) {\n        console.warn(\"The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable.\");\n      }\n    }\n    const resolve_heartbeat = async config2 => {\n      await this._resolve_hearbeat(config2);\n    };\n    async function handle_render_config(render_config) {\n      if (!config) return;\n      let render_id = render_config.render_id;\n      config.components = [...config.components.filter(c => c.props.rendered_in !== render_id), ...render_config.components];\n      config.dependencies = [...config.dependencies.filter(d => d.rendered_in !== render_id), ...render_config.dependencies];\n      const any_state = config.components.some(c => c.type === \"state\");\n      const any_unload = config.dependencies.some(d => d.targets.some(t => t[1] === \"unload\"));\n      config.connect_heartbeat = any_state || any_unload;\n      await resolve_heartbeat(config);\n      fire_event({\n        type: \"render\",\n        data: render_config,\n        endpoint: _endpoint,\n        fn_index\n      });\n    }\n    this.handle_blob(config.root, resolved_data, endpoint_info).then(async _payload => {\n      var _a2;\n      let input_data = handle_payload(_payload, dependency, config.components, \"input\", true);\n      payload = {\n        data: input_data || [],\n        event_data,\n        fn_index,\n        trigger_id\n      };\n      if (skip_queue(fn_index, config)) {\n        fire_event({\n          type: \"status\",\n          endpoint: _endpoint,\n          stage: \"pending\",\n          queue: false,\n          fn_index,\n          time: /* @__PURE__ */new Date()\n        });\n        post_data2(`${config.root}${api_prefix}/run${_endpoint.startsWith(\"/\") ? _endpoint : `/${_endpoint}`}${url_params ? \"?\" + url_params : \"\"}`, {\n          ...payload,\n          session_hash\n        }).then(([output, status_code]) => {\n          const data2 = output.data;\n          if (status_code == 200) {\n            fire_event({\n              type: \"data\",\n              endpoint: _endpoint,\n              fn_index,\n              data: handle_payload(data2, dependency, config.components, \"output\", options.with_null_state),\n              time: /* @__PURE__ */new Date(),\n              event_data,\n              trigger_id\n            });\n            if (output.render_config) {\n              handle_render_config(output.render_config);\n            }\n            fire_event({\n              type: \"status\",\n              endpoint: _endpoint,\n              fn_index,\n              stage: \"complete\",\n              eta: output.average_duration,\n              queue: false,\n              time: /* @__PURE__ */new Date()\n            });\n          } else {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              endpoint: _endpoint,\n              fn_index,\n              message: output.error,\n              queue: false,\n              time: /* @__PURE__ */new Date()\n            });\n          }\n        }).catch(e => {\n          fire_event({\n            type: \"status\",\n            stage: \"error\",\n            message: e.message,\n            endpoint: _endpoint,\n            fn_index,\n            queue: false,\n            time: /* @__PURE__ */new Date()\n          });\n        });\n      } else if (protocol == \"ws\") {\n        const {\n          ws_protocol,\n          host\n        } = await process_endpoint(app_reference, hf_token);\n        fire_event({\n          type: \"status\",\n          stage: \"pending\",\n          queue: true,\n          endpoint: _endpoint,\n          fn_index,\n          time: /* @__PURE__ */new Date()\n        });\n        let url = new URL(`${ws_protocol}://${resolve_root(host, config.path, true)}/queue/join${url_params ? \"?\" + url_params : \"\"}`);\n        if (this.jwt) {\n          url.searchParams.set(\"__sign\", this.jwt);\n        }\n        websocket = new WebSocket(url);\n        websocket.onclose = evt => {\n          if (!evt.wasClean) {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              broken: true,\n              message: BROKEN_CONNECTION_MSG,\n              queue: true,\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date()\n            });\n          }\n        };\n        websocket.onmessage = function (event) {\n          const _data = JSON.parse(event.data);\n          const {\n            type,\n            status,\n            data: data2\n          } = handle_message(_data, last_status[fn_index]);\n          if (type === \"update\" && status && !complete) {\n            fire_event({\n              type: \"status\",\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date(),\n              ...status\n            });\n            if (status.stage === \"error\") {\n              websocket.close();\n            }\n          } else if (type === \"hash\") {\n            websocket.send(JSON.stringify({\n              fn_index,\n              session_hash\n            }));\n            return;\n          } else if (type === \"data\") {\n            websocket.send(JSON.stringify({\n              ...payload,\n              session_hash\n            }));\n          } else if (type === \"complete\") {\n            complete = status;\n          } else if (type === \"log\") {\n            fire_event({\n              type: \"log\",\n              log: data2.log,\n              level: data2.level,\n              endpoint: _endpoint,\n              duration: data2.duration,\n              visible: data2.visible,\n              fn_index\n            });\n          } else if (type === \"generating\") {\n            fire_event({\n              type: \"status\",\n              time: /* @__PURE__ */new Date(),\n              ...status,\n              stage: status == null ? void 0 : status.stage,\n              queue: true,\n              endpoint: _endpoint,\n              fn_index\n            });\n          }\n          if (data2) {\n            fire_event({\n              type: \"data\",\n              time: /* @__PURE__ */new Date(),\n              data: handle_payload(data2.data, dependency, config.components, \"output\", options.with_null_state),\n              endpoint: _endpoint,\n              fn_index,\n              event_data,\n              trigger_id\n            });\n            if (complete) {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */new Date(),\n                ...complete,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n              websocket.close();\n            }\n          }\n        };\n        if (semiver(config.version || \"2.0.0\", \"3.6\") < 0) {\n          addEventListener(\"open\", () => websocket.send(JSON.stringify({\n            hash: session_hash\n          })));\n        }\n      } else if (protocol == \"sse\") {\n        fire_event({\n          type: \"status\",\n          stage: \"pending\",\n          queue: true,\n          endpoint: _endpoint,\n          fn_index,\n          time: /* @__PURE__ */new Date()\n        });\n        var params = new URLSearchParams({\n          fn_index: fn_index.toString(),\n          session_hash\n        }).toString();\n        let url = new URL(`${config.root}${api_prefix}/${SSE_URL}?${url_params ? url_params + \"&\" : \"\"}${params}`);\n        if (this.jwt) {\n          url.searchParams.set(\"__sign\", this.jwt);\n        }\n        stream2 = this.stream(url);\n        if (!stream2) {\n          return Promise.reject(new Error(\"Cannot connect to SSE endpoint: \" + url.toString()));\n        }\n        stream2.onmessage = async function (event) {\n          const _data = JSON.parse(event.data);\n          const {\n            type,\n            status,\n            data: data2\n          } = handle_message(_data, last_status[fn_index]);\n          if (type === \"update\" && status && !complete) {\n            fire_event({\n              type: \"status\",\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date(),\n              ...status\n            });\n            if (status.stage === \"error\") {\n              stream2 == null ? void 0 : stream2.close();\n              close();\n            }\n          } else if (type === \"data\") {\n            let [_, status2] = await post_data2(`${config.root}${api_prefix}/queue/data`, {\n              ...payload,\n              session_hash,\n              event_id\n            });\n            if (status2 !== 200) {\n              fire_event({\n                type: \"status\",\n                stage: \"error\",\n                message: BROKEN_CONNECTION_MSG,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index,\n                time: /* @__PURE__ */new Date()\n              });\n              stream2 == null ? void 0 : stream2.close();\n              close();\n            }\n          } else if (type === \"complete\") {\n            complete = status;\n          } else if (type === \"log\") {\n            fire_event({\n              type: \"log\",\n              log: data2.log,\n              level: data2.level,\n              endpoint: _endpoint,\n              duration: data2.duration,\n              visible: data2.visible,\n              fn_index\n            });\n          } else if (type === \"generating\" || type === \"streaming\") {\n            fire_event({\n              type: \"status\",\n              time: /* @__PURE__ */new Date(),\n              ...status,\n              stage: status == null ? void 0 : status.stage,\n              queue: true,\n              endpoint: _endpoint,\n              fn_index\n            });\n          }\n          if (data2) {\n            fire_event({\n              type: \"data\",\n              time: /* @__PURE__ */new Date(),\n              data: handle_payload(data2.data, dependency, config.components, \"output\", options.with_null_state),\n              endpoint: _endpoint,\n              fn_index,\n              event_data,\n              trigger_id\n            });\n            if (complete) {\n              fire_event({\n                type: \"status\",\n                time: /* @__PURE__ */new Date(),\n                ...complete,\n                stage: status == null ? void 0 : status.stage,\n                queue: true,\n                endpoint: _endpoint,\n                fn_index\n              });\n              stream2 == null ? void 0 : stream2.close();\n              close();\n            }\n          }\n        };\n      } else if (protocol == \"sse_v1\" || protocol == \"sse_v2\" || protocol == \"sse_v2.1\" || protocol == \"sse_v3\") {\n        fire_event({\n          type: \"status\",\n          stage: \"pending\",\n          queue: true,\n          endpoint: _endpoint,\n          fn_index,\n          time: /* @__PURE__ */new Date()\n        });\n        let hostname = \"\";\n        if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n          hostname = (_a2 = window == null ? void 0 : window.location) == null ? void 0 : _a2.hostname;\n        }\n        let hfhubdev = \"dev.spaces.huggingface.tech\";\n        const origin = hostname.includes(\".dev.\") ? `https://moon-${hostname.split(\".\")[1]}.${hfhubdev}` : `https://huggingface.co`;\n        const is_iframe = typeof window !== \"undefined\" && typeof document !== \"undefined\" && window.parent != window;\n        const is_zerogpu_space = dependency.zerogpu && config.space_id;\n        const zerogpu_auth_promise = is_iframe && is_zerogpu_space ? post_message(\"zerogpu-headers\", origin) : Promise.resolve(null);\n        const post_data_promise = zerogpu_auth_promise.then(headers => {\n          return post_data2(`${config.root}${api_prefix}/${SSE_DATA_URL}?${url_params}`, {\n            ...payload,\n            session_hash\n          }, headers);\n        });\n        post_data_promise.then(async ([response, status]) => {\n          if (status === 503) {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              message: QUEUE_FULL_MSG,\n              queue: true,\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date()\n            });\n          } else if (status !== 200) {\n            fire_event({\n              type: \"status\",\n              stage: \"error\",\n              message: BROKEN_CONNECTION_MSG,\n              queue: true,\n              endpoint: _endpoint,\n              fn_index,\n              time: /* @__PURE__ */new Date()\n            });\n          } else {\n            event_id = response.event_id;\n            event_id_final = event_id;\n            let callback = async function (_data) {\n              try {\n                const {\n                  type,\n                  status: status2,\n                  data: data2,\n                  original_msg\n                } = handle_message(_data, last_status[fn_index]);\n                if (type == \"heartbeat\") {\n                  return;\n                }\n                if (type === \"update\" && status2 && !complete) {\n                  fire_event({\n                    type: \"status\",\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */new Date(),\n                    original_msg,\n                    ...status2\n                  });\n                } else if (type === \"complete\") {\n                  complete = status2;\n                } else if (type == \"unexpected_error\") {\n                  console.error(\"Unexpected error\", status2 == null ? void 0 : status2.message);\n                  fire_event({\n                    type: \"status\",\n                    stage: \"error\",\n                    message: (status2 == null ? void 0 : status2.message) || \"An Unexpected Error Occurred!\",\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index,\n                    time: /* @__PURE__ */new Date()\n                  });\n                } else if (type === \"log\") {\n                  fire_event({\n                    type: \"log\",\n                    log: data2.log,\n                    level: data2.level,\n                    endpoint: _endpoint,\n                    duration: data2.duration,\n                    visible: data2.visible,\n                    fn_index\n                  });\n                  return;\n                } else if (type === \"generating\" || type === \"streaming\") {\n                  fire_event({\n                    type: \"status\",\n                    time: /* @__PURE__ */new Date(),\n                    ...status2,\n                    stage: status2 == null ? void 0 : status2.stage,\n                    queue: true,\n                    endpoint: _endpoint,\n                    fn_index\n                  });\n                  if (data2 && dependency.connection !== \"stream\" && [\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                    apply_diff_stream(pending_diff_streams, event_id, data2);\n                  }\n                }\n                if (data2) {\n                  fire_event({\n                    type: \"data\",\n                    time: /* @__PURE__ */new Date(),\n                    data: handle_payload(data2.data, dependency, config.components, \"output\", options.with_null_state),\n                    endpoint: _endpoint,\n                    fn_index\n                  });\n                  if (data2.render_config) {\n                    await handle_render_config(data2.render_config);\n                  }\n                  if (complete) {\n                    fire_event({\n                      type: \"status\",\n                      time: /* @__PURE__ */new Date(),\n                      ...complete,\n                      stage: status2 == null ? void 0 : status2.stage,\n                      queue: true,\n                      endpoint: _endpoint,\n                      fn_index\n                    });\n                    close();\n                  }\n                }\n                if ((status2 == null ? void 0 : status2.stage) === \"complete\" || (status2 == null ? void 0 : status2.stage) === \"error\") {\n                  if (event_callbacks[event_id]) {\n                    delete event_callbacks[event_id];\n                  }\n                  if (event_id in pending_diff_streams) {\n                    delete pending_diff_streams[event_id];\n                  }\n                }\n              } catch (e) {\n                console.error(\"Unexpected client exception\", e);\n                fire_event({\n                  type: \"status\",\n                  stage: \"error\",\n                  message: \"An Unexpected Error Occurred!\",\n                  queue: true,\n                  endpoint: _endpoint,\n                  fn_index,\n                  time: /* @__PURE__ */new Date()\n                });\n                if ([\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\n                  close_stream(stream_status, that.abort_controller);\n                  stream_status.open = false;\n                  close();\n                }\n              }\n            };\n            if (event_id in pending_stream_messages) {\n              pending_stream_messages[event_id].forEach(msg => callback(msg));\n              delete pending_stream_messages[event_id];\n            }\n            event_callbacks[event_id] = callback;\n            unclosed_events.add(event_id);\n            if (!stream_status.open) {\n              await this.open_stream();\n            }\n          }\n        });\n      }\n    });\n    let done = false;\n    const values = [];\n    const resolvers = [];\n    const iterator = {\n      [Symbol.asyncIterator]: () => iterator,\n      next,\n      throw: async value => {\n        push_error(value);\n        return next();\n      },\n      return: async () => {\n        close();\n        return next();\n      },\n      cancel,\n      event_id: event_id_cb\n    };\n    return iterator;\n  } catch (error) {\n    console.error(\"Submit function encountered an error:\", error);\n    throw error;\n  }\n}\nfunction thenable_reject(error) {\n  return {\n    then: (resolve, reject) => reject(error)\n  };\n}\nfunction get_endpoint_info(api_info, endpoint, api_map, config) {\n  let fn_index;\n  let endpoint_info;\n  let dependency;\n  if (typeof endpoint === \"number\") {\n    fn_index = endpoint;\n    endpoint_info = api_info.unnamed_endpoints[fn_index];\n    dependency = config.dependencies.find(dep => dep.id == endpoint);\n  } else {\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\n    fn_index = api_map[trimmed_endpoint];\n    endpoint_info = api_info.named_endpoints[endpoint.trim()];\n    dependency = config.dependencies.find(dep => dep.id == api_map[trimmed_endpoint]);\n  }\n  if (typeof fn_index !== \"number\") {\n    throw new Error(\"There is no endpoint matching that name of fn_index matching that number.\");\n  }\n  return {\n    fn_index,\n    endpoint_info,\n    dependency\n  };\n}\nclass Client {\n  constructor(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    __publicField(this, \"app_reference\");\n    __publicField(this, \"options\");\n    __publicField(this, \"config\");\n    __publicField(this, \"api_prefix\", \"\");\n    __publicField(this, \"api_info\");\n    __publicField(this, \"api_map\", {});\n    __publicField(this, \"session_hash\", Math.random().toString(36).substring(2));\n    __publicField(this, \"jwt\", false);\n    __publicField(this, \"last_status\", {});\n    __publicField(this, \"cookies\", null);\n    // streaming\n    __publicField(this, \"stream_status\", {\n      open: false\n    });\n    __publicField(this, \"pending_stream_messages\", {});\n    __publicField(this, \"pending_diff_streams\", {});\n    __publicField(this, \"event_callbacks\", {});\n    __publicField(this, \"unclosed_events\", /* @__PURE__ */new Set());\n    __publicField(this, \"heartbeat_event\", null);\n    __publicField(this, \"abort_controller\", null);\n    __publicField(this, \"stream_instance\", null);\n    __publicField(this, \"current_payload\");\n    __publicField(this, \"view_api\");\n    __publicField(this, \"upload_files\");\n    __publicField(this, \"upload\");\n    __publicField(this, \"handle_blob\");\n    __publicField(this, \"post_data\");\n    __publicField(this, \"submit\");\n    __publicField(this, \"predict\");\n    __publicField(this, \"open_stream\");\n    __publicField(this, \"resolve_config\");\n    __publicField(this, \"resolve_cookies\");\n    this.app_reference = app_reference;\n    if (!options.events) {\n      options.events = [\"data\"];\n    }\n    this.options = options;\n    this.current_payload = {};\n    this.view_api = view_api.bind(this);\n    this.upload_files = upload_files.bind(this);\n    this.handle_blob = handle_blob.bind(this);\n    this.post_data = post_data.bind(this);\n    this.submit = submit.bind(this);\n    this.predict = predict.bind(this);\n    this.open_stream = open_stream.bind(this);\n    this.resolve_config = resolve_config.bind(this);\n    this.resolve_cookies = resolve_cookies.bind(this);\n    this.upload = upload.bind(this);\n    this.fetch = this.fetch.bind(this);\n    this.handle_space_success = this.handle_space_success.bind(this);\n    this.stream = this.stream.bind(this);\n  }\n  fetch(input, init) {\n    const headers = new Headers((init == null ? void 0 : init.headers) || {});\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    return fetch(input, {\n      ...init,\n      headers\n    });\n  }\n  stream(url) {\n    const headers = new Headers();\n    if (this && this.cookies) {\n      headers.append(\"Cookie\", this.cookies);\n    }\n    this.abort_controller = new AbortController();\n    this.stream_instance = readable_stream(url.toString(), {\n      credentials: \"include\",\n      headers,\n      signal: this.abort_controller.signal\n    });\n    return this.stream_instance;\n  }\n  async init() {\n    var _a;\n    if ((typeof window === \"undefined\" || !(\"WebSocket\" in window)) && !global.WebSocket) {\n      const ws = await import(\"./wrapper-CviSselG.js\");\n      global.WebSocket = ws.WebSocket;\n    }\n    if (this.options.auth) {\n      await this.resolve_cookies();\n    }\n    await this._resolve_config().then(({\n      config\n    }) => this._resolve_hearbeat(config));\n    this.api_info = await this.view_api();\n    this.api_map = map_names_to_ids(((_a = this.config) == null ? void 0 : _a.dependencies) || []);\n  }\n  async _resolve_hearbeat(_config) {\n    if (_config) {\n      this.config = _config;\n      this.api_prefix = _config.api_prefix || \"\";\n      if (this.config && this.config.connect_heartbeat) {\n        if (this.config.space_id && this.options.hf_token) {\n          this.jwt = await get_jwt(this.config.space_id, this.options.hf_token, this.cookies);\n        }\n      }\n    }\n    if (_config.space_id && this.options.hf_token) {\n      this.jwt = await get_jwt(_config.space_id, this.options.hf_token);\n    }\n    if (this.config && this.config.connect_heartbeat) {\n      const heartbeat_url = new URL(`${this.config.root}${this.api_prefix}/${HEARTBEAT_URL}/${this.session_hash}`);\n      if (this.jwt) {\n        heartbeat_url.searchParams.set(\"__sign\", this.jwt);\n      }\n      if (!this.heartbeat_event) {\n        this.heartbeat_event = this.stream(heartbeat_url);\n      }\n    }\n  }\n  static async connect(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    const client2 = new this(app_reference, options);\n    await client2.init();\n    return client2;\n  }\n  close() {\n    close_stream(this.stream_status, this.abort_controller);\n  }\n  set_current_payload(payload) {\n    this.current_payload = payload;\n  }\n  static async duplicate(app_reference, options = {\n    events: [\"data\"]\n  }) {\n    return duplicate(app_reference, options);\n  }\n  async _resolve_config() {\n    const {\n      http_protocol,\n      host,\n      space_id\n    } = await process_endpoint(this.app_reference, this.options.hf_token);\n    const {\n      status_callback\n    } = this.options;\n    if (space_id && status_callback) {\n      await check_and_wake_space(space_id, status_callback);\n    }\n    let config;\n    try {\n      config = await this.resolve_config(`${http_protocol}//${host}`);\n      if (!config) {\n        throw new Error(CONFIG_ERROR_MSG);\n      }\n      return this.config_success(config);\n    } catch (e) {\n      if (space_id && status_callback) {\n        check_space_status(space_id, RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\", this.handle_space_success);\n      } else {\n        if (status_callback) status_callback({\n          status: \"error\",\n          message: \"Could not load this space.\",\n          load_status: \"error\",\n          detail: \"NOT_FOUND\"\n        });\n        throw Error(e);\n      }\n    }\n  }\n  async config_success(_config) {\n    this.config = _config;\n    this.api_prefix = _config.api_prefix || \"\";\n    if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\n      if (window.location.protocol === \"https:\") {\n        this.config.root = this.config.root.replace(\"http://\", \"https://\");\n      }\n    }\n    if (this.config.auth_required) {\n      return this.prepare_return_obj();\n    }\n    try {\n      this.api_info = await this.view_api();\n    } catch (e) {\n      console.error(API_INFO_ERROR_MSG + e.message);\n    }\n    return this.prepare_return_obj();\n  }\n  async handle_space_success(status) {\n    var _a;\n    if (!this) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const {\n      status_callback\n    } = this.options;\n    if (status_callback) status_callback(status);\n    if (status.status === \"running\") {\n      try {\n        this.config = await this._resolve_config();\n        this.api_prefix = ((_a = this == null ? void 0 : this.config) == null ? void 0 : _a.api_prefix) || \"\";\n        if (!this.config) {\n          throw new Error(CONFIG_ERROR_MSG);\n        }\n        const _config = await this.config_success(this.config);\n        return _config;\n      } catch (e) {\n        if (status_callback) {\n          status_callback({\n            status: \"error\",\n            message: \"Could not load this space.\",\n            load_status: \"error\",\n            detail: \"NOT_FOUND\"\n          });\n        }\n        throw e;\n      }\n    }\n  }\n  async component_server(component_id, fn_name, data) {\n    var _a;\n    if (!this.config) {\n      throw new Error(CONFIG_ERROR_MSG);\n    }\n    const headers = {};\n    const {\n      hf_token\n    } = this.options;\n    const {\n      session_hash\n    } = this;\n    if (hf_token) {\n      headers.Authorization = `Bearer ${this.options.hf_token}`;\n    }\n    let root_url;\n    let component = this.config.components.find(comp => comp.id === component_id);\n    if ((_a = component == null ? void 0 : component.props) == null ? void 0 : _a.root_url) {\n      root_url = component.props.root_url;\n    } else {\n      root_url = this.config.root;\n    }\n    let body;\n    if (\"binary\" in data) {\n      body = new FormData();\n      for (const key in data.data) {\n        if (key === \"binary\") continue;\n        body.append(key, data.data[key]);\n      }\n      body.set(\"component_id\", component_id.toString());\n      body.set(\"fn_name\", fn_name);\n      body.set(\"session_hash\", session_hash);\n    } else {\n      body = JSON.stringify({\n        data,\n        component_id,\n        fn_name,\n        session_hash\n      });\n      headers[\"Content-Type\"] = \"application/json\";\n    }\n    if (hf_token) {\n      headers.Authorization = `Bearer ${hf_token}`;\n    }\n    try {\n      const response = await this.fetch(`${root_url}${this.api_prefix}/${COMPONENT_SERVER_URL}/`, {\n        method: \"POST\",\n        body,\n        headers,\n        credentials: \"include\"\n      });\n      if (!response.ok) {\n        throw new Error(\"Could not connect to component server: \" + response.statusText);\n      }\n      const output = await response.json();\n      return output;\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n  set_cookies(raw_cookies) {\n    this.cookies = parse_and_set_cookies(raw_cookies).join(\"; \");\n  }\n  prepare_return_obj() {\n    return {\n      config: this.config,\n      predict: this.predict,\n      submit: this.submit,\n      view_api: this.view_api,\n      component_server: this.component_server\n    };\n  }\n}\nasync function client(app_reference, options = {\n  events: [\"data\"]\n}) {\n  return await Client.connect(app_reference, options);\n}\nasync function duplicate_space(app_reference, options) {\n  return await Client.duplicate(app_reference, options);\n}\nexport { Client, FileData, client, duplicate_space as duplicate, handle_file, predict, prepare_files, submit, upload, upload_files };","map":{"version":3,"names":["__defProp","Object","defineProperty","__defNormalProp","obj","key","value","enumerable","configurable","writable","__publicField","__accessCheck","member","msg","has","TypeError","__privateGet","getter","call","get","__privateAdd","WeakSet","add","set","__privateSet","setter","_currentLine","fn","Intl","Collator","numeric","compare","semiver","a","b","bool","split","slice","join","test","HOST_URL","SSE_URL","SSE_DATA_URL","UPLOAD_URL","LOGIN_URL","CONFIG_URL","API_INFO_URL","RUNTIME_URL","SLEEPTIME_URL","HEARTBEAT_URL","COMPONENT_SERVER_URL","RESET_URL","CANCEL_URL","SPACE_FETCHER_URL","QUEUE_FULL_MSG","BROKEN_CONNECTION_MSG","CONFIG_ERROR_MSG","SPACE_STATUS_ERROR_MSG","API_INFO_ERROR_MSG","SPACE_METADATA_ERROR_MSG","INVALID_URL_MSG","UNAUTHORIZED_MSG","INVALID_CREDENTIALS_MSG","MISSING_CREDENTIALS_MSG","NODEJS_FS_ERROR_MSG","ROOT_URL_ERROR_MSG","FILE_PROCESSING_ERROR_MSG","resolve_root","base_url","root_path","prioritize_base","startsWith","get_jwt","space","token","cookies","r","fetch","headers","Authorization","Cookie","jwt","json","e","map_names_to_ids","fns","apis","forEach","api_name","id","resolve_config","endpoint","_a","options","hf_token","window","gradio_config","location","origin","dev_mode","path","root","config","config_root","config_url","join_urls","response","credentials","status","auth","Error","dependencies","dep","i","resolve_cookies","http_protocol","host","process_endpoint","app_reference","cookie_header","get_cookie_header","set_cookies","message","_fetch","formData","FormData","append","res","method","body","determine_protocol","protocol","pathname","URL","endsWith","ws_protocol","parse_and_set_cookies","parts","cookie","cookie_name","cookie_value","push","trim","RE_SPACE_NAME","RE_SPACE_DOMAIN","_app_reference","replace","_host","space_id","urls","reduce","part","toString","transform_api_info","api_info","api_map","transformed_info","named_endpoints","unnamed_endpoints","keys","category","entries","parameters","returns","_b","_c","_d","dependencyIndex","find","dependencyTypes","types","generator","cancel","inputs","length","components","map","input","_a2","c","type","comp","idx","new_param","component","example","parameter_default","parameter_has_default","parameter_name","hidden","splice","console","error","transform_type","data","serializer","signature_type","description","get_description","get_type","p","handle_message","last_status","queue","stage","code","success","size","queue_size","position","rank","eta","rank_eta","progress_data","output","average_duration","changed_state_ids","time_limit","visible","duration","original_msg","map_data_to_params","endpoint_info","Array","isArray","warn","resolved_data","provided_keys","param","index","hasOwnProperty","some","view_api","gradio_api_info","version","JSON","stringify","serialize","url","api_prefix","ok","api","upload_files","root_url","files","upload_id","chunkSize","uploadResponses","chunk","file","upload_url","error_text","text","upload","file_data","max_file_size","file_data2","blob","oversized_files","filter","f","Infinity","name","Promise","all","then","FileData","prepare_files","is_stream","orig_name","mime_type","constructor","alt_text","_type","Command","command","meta","is_node","process","versions","node","update_object","object","newValue","stack","key2","shift","walk_and_store_blobs","blob_refs","_","new_path","String","array_refs","concat","globalThis","Buffer","Blob","skip_queue","fn_queue","enable_queue","post_message","_rej","channel","MessageChannel","port1","onmessage","close","parent","postMessage","port2","handle_file","file_or_url","pop","orig_path","File","handle_payload","resolved_payload","dependency","with_null_state","updated_payload","payload_index","deps","outputs","input_id","handle_blob","self","process_local_file_commands","blobRefs","results","file_url","client2","recursively_process_commands","process_single_command","cmd_item","fileBuffer","fullPath","fs","resolve","cwd","readFile","fileData","post_data","additional_headers","predict","data_returned","status_complete","trimmed_endpoint","reject","app","submit","result","check_space_status","status_callback","_status","load_status","detail","runtime","space_name","setTimeout","discussions_enabled","check_and_wake_space","retries","max_retries","check_interval","RE_DISABLED_DISCUSSION","get_space_hardware","hardware","current","set_space_timeout","timeout","seconds","hardware_types","duplicate","private","_private","includes","v","user","repository","original_hardware","requested_hardware","Client","connect","statusText","duplicated_space","get_space_reference","regex","match","TextLineStream","TransformStream","allowCR","transform","chars","controller","lfIndex","indexOf","crIndex","enqueue","endIndex","flush","currentLine","WeakMap","stream$1","decoder","TextDecoderStream","split2","pipeThrough","rgx","exec","substring","fallback","tmp","events","signal","iter","line","reader","getReader","event","aborted","read","done","field","stream","init","req","Request","open_stream","event_callbacks","unclosed_events","pending_stream_messages","stream_status","that","open","stream2","params","URLSearchParams","session_hash","searchParams","_data","parse","close_stream","abort_controller","event_id","event_id2","delete","fn2","document","onerror","abort","apply_diff_stream","pending_diff_streams","is_first_generation","new_data","apply_diff","diff","action","apply_edit","target","last_path","Number","readable_stream","instance","onopen","readyState","withCredentials","CONNECTING","OPEN","CLOSED","addEventListener","dispatchEvent","removeEventListener","catch","event_data","trigger_id","all_events","fire_event","events_to_publish","push_event","resolvers","data2","values","push_error","thenable_reject","next","fetch2","post_data2","fn_index","get_endpoint_info","websocket","event_id_final","event_id_cb","_endpoint","payload","complete","url_params","search","acc","time","Date","reset_request","cancel_request","resolve_heartbeat","config2","_resolve_hearbeat","handle_render_config","render_config","render_id","props","rendered_in","d","any_state","any_unload","targets","t","connect_heartbeat","_payload","input_data","status_code","WebSocket","onclose","evt","wasClean","broken","send","log","level","hash","status2","hostname","hfhubdev","is_iframe","is_zerogpu_space","zerogpu","zerogpu_auth_promise","post_data_promise","callback","connection","iterator","Symbol","asyncIterator","throw","return","Math","random","Set","current_payload","bind","handle_space_success","Headers","AbortController","stream_instance","global","ws","_resolve_config","_config","heartbeat_url","heartbeat_event","set_current_payload","config_success","auth_required","prepare_return_obj","component_server","component_id","fn_name","raw_cookies","client","duplicate_space"],"sources":["C:/Users/kevin/Desktop/School/Senior Project/Github Branch/Mellowdies/mellowdies/node_modules/@gradio/client/dist/index.js"],"sourcesContent":["var __defProp = Object.defineProperty;\r\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __publicField = (obj, key, value) => {\r\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\r\n  return value;\r\n};\r\nvar __accessCheck = (obj, member, msg) => {\r\n  if (!member.has(obj))\r\n    throw TypeError(\"Cannot \" + msg);\r\n};\r\nvar __privateGet = (obj, member, getter) => {\r\n  __accessCheck(obj, member, \"read from private field\");\r\n  return getter ? getter.call(obj) : member.get(obj);\r\n};\r\nvar __privateAdd = (obj, member, value) => {\r\n  if (member.has(obj))\r\n    throw TypeError(\"Cannot add the same private member more than once\");\r\n  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\r\n};\r\nvar __privateSet = (obj, member, value, setter) => {\r\n  __accessCheck(obj, member, \"write to private field\");\r\n  setter ? setter.call(obj, value) : member.set(obj, value);\r\n  return value;\r\n};\r\nvar _currentLine;\r\nvar fn = new Intl.Collator(0, { numeric: 1 }).compare;\r\nfunction semiver(a, b, bool) {\r\n  a = a.split(\".\");\r\n  b = b.split(\".\");\r\n  return fn(a[0], b[0]) || fn(a[1], b[1]) || (b[2] = b.slice(2).join(\".\"), bool = /[.-]/.test(a[2] = a.slice(2).join(\".\")), bool == /[.-]/.test(b[2]) ? fn(a[2], b[2]) : bool ? -1 : 1);\r\n}\r\nconst HOST_URL = `host`;\r\nconst SSE_URL = `queue/data`;\r\nconst SSE_DATA_URL = `queue/join`;\r\nconst UPLOAD_URL = `upload`;\r\nconst LOGIN_URL = `login`;\r\nconst CONFIG_URL = `config`;\r\nconst API_INFO_URL = `info`;\r\nconst RUNTIME_URL = `runtime`;\r\nconst SLEEPTIME_URL = `sleeptime`;\r\nconst HEARTBEAT_URL = `heartbeat`;\r\nconst COMPONENT_SERVER_URL = `component_server`;\r\nconst RESET_URL = `reset`;\r\nconst CANCEL_URL = `cancel`;\r\nconst SPACE_FETCHER_URL = \"https://gradio-space-api-fetcher-v2.hf.space/api\";\r\nconst QUEUE_FULL_MSG = \"This application is currently busy. Please try again. \";\r\nconst BROKEN_CONNECTION_MSG = \"Connection errored out. \";\r\nconst CONFIG_ERROR_MSG = \"Could not resolve app config. \";\r\nconst SPACE_STATUS_ERROR_MSG = \"Could not get space status. \";\r\nconst API_INFO_ERROR_MSG = \"Could not get API info. \";\r\nconst SPACE_METADATA_ERROR_MSG = \"Space metadata could not be loaded. \";\r\nconst INVALID_URL_MSG = \"Invalid URL. A full URL path is required.\";\r\nconst UNAUTHORIZED_MSG = \"Not authorized to access this space. \";\r\nconst INVALID_CREDENTIALS_MSG = \"Invalid credentials. Could not login. \";\r\nconst MISSING_CREDENTIALS_MSG = \"Login credentials are required to access this space.\";\r\nconst NODEJS_FS_ERROR_MSG = \"File system access is only available in Node.js environments\";\r\nconst ROOT_URL_ERROR_MSG = \"Root URL not found in client config\";\r\nconst FILE_PROCESSING_ERROR_MSG = \"Error uploading file\";\r\nfunction resolve_root(base_url, root_path, prioritize_base) {\r\n  if (root_path.startsWith(\"http://\") || root_path.startsWith(\"https://\")) {\r\n    return prioritize_base ? base_url : root_path;\r\n  }\r\n  return base_url + root_path;\r\n}\r\nasync function get_jwt(space, token, cookies) {\r\n  try {\r\n    const r = await fetch(`https://huggingface.co/api/spaces/${space}/jwt`, {\r\n      headers: {\r\n        Authorization: `Bearer ${token}`,\r\n        ...cookies ? { Cookie: cookies } : {}\r\n      }\r\n    });\r\n    const jwt = (await r.json()).token;\r\n    return jwt || false;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\nfunction map_names_to_ids(fns) {\r\n  let apis = {};\r\n  fns.forEach(({ api_name, id }) => {\r\n    if (api_name)\r\n      apis[api_name] = id;\r\n  });\r\n  return apis;\r\n}\r\nasync function resolve_config(endpoint) {\r\n  var _a;\r\n  const headers = this.options.hf_token ? { Authorization: `Bearer ${this.options.hf_token}` } : {};\r\n  headers[\"Content-Type\"] = \"application/json\";\r\n  if (typeof window !== \"undefined\" && window.gradio_config && location.origin !== \"http://localhost:9876\" && !window.gradio_config.dev_mode) {\r\n    const path = window.gradio_config.root;\r\n    const config = window.gradio_config;\r\n    let config_root = resolve_root(endpoint, config.root, false);\r\n    config.root = config_root;\r\n    return { ...config, path };\r\n  } else if (endpoint) {\r\n    const config_url = join_urls(endpoint, CONFIG_URL);\r\n    const response = await this.fetch(config_url, {\r\n      headers,\r\n      credentials: \"include\"\r\n    });\r\n    if ((response == null ? void 0 : response.status) === 401 && !this.options.auth) {\r\n      throw new Error(MISSING_CREDENTIALS_MSG);\r\n    } else if ((response == null ? void 0 : response.status) === 401 && this.options.auth) {\r\n      throw new Error(INVALID_CREDENTIALS_MSG);\r\n    }\r\n    if ((response == null ? void 0 : response.status) === 200) {\r\n      let config = await response.json();\r\n      config.path = config.path ?? \"\";\r\n      config.root = endpoint;\r\n      (_a = config.dependencies) == null ? void 0 : _a.forEach((dep, i) => {\r\n        if (dep.id === void 0) {\r\n          dep.id = i;\r\n        }\r\n      });\r\n      return config;\r\n    } else if ((response == null ? void 0 : response.status) === 401) {\r\n      throw new Error(UNAUTHORIZED_MSG);\r\n    }\r\n    throw new Error(CONFIG_ERROR_MSG);\r\n  }\r\n  throw new Error(CONFIG_ERROR_MSG);\r\n}\r\nasync function resolve_cookies() {\r\n  const { http_protocol, host } = await process_endpoint(\r\n    this.app_reference,\r\n    this.options.hf_token\r\n  );\r\n  try {\r\n    if (this.options.auth) {\r\n      const cookie_header = await get_cookie_header(\r\n        http_protocol,\r\n        host,\r\n        this.options.auth,\r\n        this.fetch,\r\n        this.options.hf_token\r\n      );\r\n      if (cookie_header)\r\n        this.set_cookies(cookie_header);\r\n    }\r\n  } catch (e) {\r\n    throw Error(e.message);\r\n  }\r\n}\r\nasync function get_cookie_header(http_protocol, host, auth, _fetch, hf_token) {\r\n  const formData = new FormData();\r\n  formData.append(\"username\", auth == null ? void 0 : auth[0]);\r\n  formData.append(\"password\", auth == null ? void 0 : auth[1]);\r\n  let headers = {};\r\n  if (hf_token) {\r\n    headers.Authorization = `Bearer ${hf_token}`;\r\n  }\r\n  const res = await _fetch(`${http_protocol}//${host}/${LOGIN_URL}`, {\r\n    headers,\r\n    method: \"POST\",\r\n    body: formData,\r\n    credentials: \"include\"\r\n  });\r\n  if (res.status === 200) {\r\n    return res.headers.get(\"set-cookie\");\r\n  } else if (res.status === 401) {\r\n    throw new Error(INVALID_CREDENTIALS_MSG);\r\n  } else {\r\n    throw new Error(SPACE_METADATA_ERROR_MSG);\r\n  }\r\n}\r\nfunction determine_protocol(endpoint) {\r\n  if (endpoint.startsWith(\"http\")) {\r\n    const { protocol, host, pathname } = new URL(endpoint);\r\n    if (host.endsWith(\"hf.space\")) {\r\n      return {\r\n        ws_protocol: \"wss\",\r\n        host,\r\n        http_protocol: protocol\r\n      };\r\n    }\r\n    return {\r\n      ws_protocol: protocol === \"https:\" ? \"wss\" : \"ws\",\r\n      http_protocol: protocol,\r\n      host: host + (pathname !== \"/\" ? pathname : \"\")\r\n    };\r\n  } else if (endpoint.startsWith(\"file:\")) {\r\n    return {\r\n      ws_protocol: \"ws\",\r\n      http_protocol: \"http:\",\r\n      host: \"lite.local\"\r\n      // Special fake hostname only used for this case. This matches the hostname allowed in `is_self_host()` in `js/wasm/network/host.ts`.\r\n    };\r\n  }\r\n  return {\r\n    ws_protocol: \"wss\",\r\n    http_protocol: \"https:\",\r\n    host: new URL(endpoint).host\r\n  };\r\n}\r\nconst parse_and_set_cookies = (cookie_header) => {\r\n  let cookies = [];\r\n  const parts = cookie_header.split(/,(?=\\s*[^\\s=;]+=[^\\s=;]+)/);\r\n  parts.forEach((cookie) => {\r\n    const [cookie_name, cookie_value] = cookie.split(\";\")[0].split(\"=\");\r\n    if (cookie_name && cookie_value) {\r\n      cookies.push(`${cookie_name.trim()}=${cookie_value.trim()}`);\r\n    }\r\n  });\r\n  return cookies;\r\n};\r\nconst RE_SPACE_NAME = /^[a-zA-Z0-9_\\-\\.]+\\/[a-zA-Z0-9_\\-\\.]+$/;\r\nconst RE_SPACE_DOMAIN = /.*hf\\.space\\/{0,1}$/;\r\nasync function process_endpoint(app_reference, hf_token) {\r\n  const headers = {};\r\n  if (hf_token) {\r\n    headers.Authorization = `Bearer ${hf_token}`;\r\n  }\r\n  const _app_reference = app_reference.trim().replace(/\\/$/, \"\");\r\n  if (RE_SPACE_NAME.test(_app_reference)) {\r\n    try {\r\n      const res = await fetch(\r\n        `https://huggingface.co/api/spaces/${_app_reference}/${HOST_URL}`,\r\n        { headers }\r\n      );\r\n      const _host = (await res.json()).host;\r\n      return {\r\n        space_id: app_reference,\r\n        ...determine_protocol(_host)\r\n      };\r\n    } catch (e) {\r\n      throw new Error(SPACE_METADATA_ERROR_MSG);\r\n    }\r\n  }\r\n  if (RE_SPACE_DOMAIN.test(_app_reference)) {\r\n    const { ws_protocol, http_protocol, host } = determine_protocol(_app_reference);\r\n    return {\r\n      space_id: host.replace(\".hf.space\", \"\"),\r\n      ws_protocol,\r\n      http_protocol,\r\n      host\r\n    };\r\n  }\r\n  return {\r\n    space_id: false,\r\n    ...determine_protocol(_app_reference)\r\n  };\r\n}\r\nconst join_urls = (...urls) => {\r\n  try {\r\n    return urls.reduce((base_url, part) => {\r\n      base_url = base_url.replace(/\\/+$/, \"\");\r\n      part = part.replace(/^\\/+/, \"\");\r\n      return new URL(part, base_url + \"/\").toString();\r\n    });\r\n  } catch (e) {\r\n    throw new Error(INVALID_URL_MSG);\r\n  }\r\n};\r\nfunction transform_api_info(api_info, config, api_map) {\r\n  const transformed_info = {\r\n    named_endpoints: {},\r\n    unnamed_endpoints: {}\r\n  };\r\n  Object.keys(api_info).forEach((category) => {\r\n    if (category === \"named_endpoints\" || category === \"unnamed_endpoints\") {\r\n      transformed_info[category] = {};\r\n      Object.entries(api_info[category]).forEach(\r\n        ([endpoint, { parameters, returns }]) => {\r\n          var _a, _b, _c, _d;\r\n          const dependencyIndex = ((_a = config.dependencies.find(\r\n            (dep) => dep.api_name === endpoint || dep.api_name === endpoint.replace(\"/\", \"\")\r\n          )) == null ? void 0 : _a.id) || api_map[endpoint.replace(\"/\", \"\")] || -1;\r\n          const dependencyTypes = dependencyIndex !== -1 ? (_b = config.dependencies.find((dep) => dep.id == dependencyIndex)) == null ? void 0 : _b.types : { generator: false, cancel: false };\r\n          if (dependencyIndex !== -1 && ((_d = (_c = config.dependencies.find((dep) => dep.id == dependencyIndex)) == null ? void 0 : _c.inputs) == null ? void 0 : _d.length) !== parameters.length) {\r\n            const components = config.dependencies.find((dep) => dep.id == dependencyIndex).inputs.map(\r\n              (input) => {\r\n                var _a2;\r\n                return (_a2 = config.components.find((c) => c.id === input)) == null ? void 0 : _a2.type;\r\n              }\r\n            );\r\n            try {\r\n              components.forEach((comp, idx) => {\r\n                if (comp === \"state\") {\r\n                  const new_param = {\r\n                    component: \"state\",\r\n                    example: null,\r\n                    parameter_default: null,\r\n                    parameter_has_default: true,\r\n                    parameter_name: null,\r\n                    hidden: true\r\n                  };\r\n                  parameters.splice(idx, 0, new_param);\r\n                }\r\n              });\r\n            } catch (e) {\r\n              console.error(e);\r\n            }\r\n          }\r\n          const transform_type = (data, component, serializer, signature_type) => ({\r\n            ...data,\r\n            description: get_description(data == null ? void 0 : data.type, serializer),\r\n            type: get_type(data == null ? void 0 : data.type, component, serializer, signature_type) || \"\"\r\n          });\r\n          transformed_info[category][endpoint] = {\r\n            parameters: parameters.map(\r\n              (p) => transform_type(p, p == null ? void 0 : p.component, p == null ? void 0 : p.serializer, \"parameter\")\r\n            ),\r\n            returns: returns.map(\r\n              (r) => transform_type(r, r == null ? void 0 : r.component, r == null ? void 0 : r.serializer, \"return\")\r\n            ),\r\n            type: dependencyTypes\r\n          };\r\n        }\r\n      );\r\n    }\r\n  });\r\n  return transformed_info;\r\n}\r\nfunction get_type(type, component, serializer, signature_type) {\r\n  switch (type == null ? void 0 : type.type) {\r\n    case \"string\":\r\n      return \"string\";\r\n    case \"boolean\":\r\n      return \"boolean\";\r\n    case \"number\":\r\n      return \"number\";\r\n  }\r\n  if (serializer === \"JSONSerializable\" || serializer === \"StringSerializable\") {\r\n    return \"any\";\r\n  } else if (serializer === \"ListStringSerializable\") {\r\n    return \"string[]\";\r\n  } else if (component === \"Image\") {\r\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : \"string\";\r\n  } else if (serializer === \"FileSerializable\") {\r\n    if ((type == null ? void 0 : type.type) === \"array\") {\r\n      return signature_type === \"parameter\" ? \"(Blob | File | Buffer)[]\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}[]`;\r\n    }\r\n    return signature_type === \"parameter\" ? \"Blob | File | Buffer\" : `{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}`;\r\n  } else if (serializer === \"GallerySerializable\") {\r\n    return signature_type === \"parameter\" ? \"[(Blob | File | Buffer), (string | null)][]\" : `[{ name: string; data: string; size?: number; is_file?: boolean; orig_name?: string}, (string | null))][]`;\r\n  }\r\n}\r\nfunction get_description(type, serializer) {\r\n  if (serializer === \"GallerySerializable\") {\r\n    return \"array of [file, label] tuples\";\r\n  } else if (serializer === \"ListStringSerializable\") {\r\n    return \"array of strings\";\r\n  } else if (serializer === \"FileSerializable\") {\r\n    return \"array of files or single file\";\r\n  }\r\n  return type == null ? void 0 : type.description;\r\n}\r\nfunction handle_message(data, last_status) {\r\n  const queue = true;\r\n  switch (data.msg) {\r\n    case \"send_data\":\r\n      return { type: \"data\" };\r\n    case \"send_hash\":\r\n      return { type: \"hash\" };\r\n    case \"queue_full\":\r\n      return {\r\n        type: \"update\",\r\n        status: {\r\n          queue,\r\n          message: QUEUE_FULL_MSG,\r\n          stage: \"error\",\r\n          code: data.code,\r\n          success: data.success\r\n        }\r\n      };\r\n    case \"heartbeat\":\r\n      return {\r\n        type: \"heartbeat\"\r\n      };\r\n    case \"unexpected_error\":\r\n      return {\r\n        type: \"unexpected_error\",\r\n        status: {\r\n          queue,\r\n          message: data.message,\r\n          stage: \"error\",\r\n          success: false\r\n        }\r\n      };\r\n    case \"estimation\":\r\n      return {\r\n        type: \"update\",\r\n        status: {\r\n          queue,\r\n          stage: last_status || \"pending\",\r\n          code: data.code,\r\n          size: data.queue_size,\r\n          position: data.rank,\r\n          eta: data.rank_eta,\r\n          success: data.success\r\n        }\r\n      };\r\n    case \"progress\":\r\n      return {\r\n        type: \"update\",\r\n        status: {\r\n          queue,\r\n          stage: \"pending\",\r\n          code: data.code,\r\n          progress_data: data.progress_data,\r\n          success: data.success\r\n        }\r\n      };\r\n    case \"log\":\r\n      return { type: \"log\", data };\r\n    case \"process_generating\":\r\n      return {\r\n        type: \"generating\",\r\n        status: {\r\n          queue,\r\n          message: !data.success ? data.output.error : null,\r\n          stage: data.success ? \"generating\" : \"error\",\r\n          code: data.code,\r\n          progress_data: data.progress_data,\r\n          eta: data.average_duration,\r\n          changed_state_ids: data.success ? data.output.changed_state_ids : void 0\r\n        },\r\n        data: data.success ? data.output : null\r\n      };\r\n    case \"process_streaming\":\r\n      return {\r\n        type: \"streaming\",\r\n        status: {\r\n          queue,\r\n          message: data.output.error,\r\n          stage: \"streaming\",\r\n          time_limit: data.time_limit,\r\n          code: data.code,\r\n          progress_data: data.progress_data,\r\n          eta: data.eta\r\n        },\r\n        data: data.output\r\n      };\r\n    case \"process_completed\":\r\n      if (\"error\" in data.output) {\r\n        return {\r\n          type: \"update\",\r\n          status: {\r\n            queue,\r\n            message: data.output.error,\r\n            visible: data.output.visible,\r\n            duration: data.output.duration,\r\n            stage: \"error\",\r\n            code: data.code,\r\n            success: data.success\r\n          }\r\n        };\r\n      }\r\n      return {\r\n        type: \"complete\",\r\n        status: {\r\n          queue,\r\n          message: !data.success ? data.output.error : void 0,\r\n          stage: data.success ? \"complete\" : \"error\",\r\n          code: data.code,\r\n          progress_data: data.progress_data,\r\n          changed_state_ids: data.success ? data.output.changed_state_ids : void 0\r\n        },\r\n        data: data.success ? data.output : null\r\n      };\r\n    case \"process_starts\":\r\n      return {\r\n        type: \"update\",\r\n        status: {\r\n          queue,\r\n          stage: \"pending\",\r\n          code: data.code,\r\n          size: data.rank,\r\n          position: 0,\r\n          success: data.success,\r\n          eta: data.eta\r\n        },\r\n        original_msg: \"process_starts\"\r\n      };\r\n  }\r\n  return { type: \"none\", status: { stage: \"error\", queue } };\r\n}\r\nconst map_data_to_params = (data = [], endpoint_info) => {\r\n  const parameters = endpoint_info ? endpoint_info.parameters : [];\r\n  if (Array.isArray(data)) {\r\n    if (data.length > parameters.length) {\r\n      console.warn(\"Too many arguments provided for the endpoint.\");\r\n    }\r\n    return data;\r\n  }\r\n  const resolved_data = [];\r\n  const provided_keys = Object.keys(data);\r\n  parameters.forEach((param, index) => {\r\n    if (data.hasOwnProperty(param.parameter_name)) {\r\n      resolved_data[index] = data[param.parameter_name];\r\n    } else if (param.parameter_has_default) {\r\n      resolved_data[index] = param.parameter_default;\r\n    } else {\r\n      throw new Error(\r\n        `No value provided for required parameter: ${param.parameter_name}`\r\n      );\r\n    }\r\n  });\r\n  provided_keys.forEach((key) => {\r\n    if (!parameters.some((param) => param.parameter_name === key)) {\r\n      throw new Error(\r\n        `Parameter \\`${key}\\` is not a valid keyword argument. Please refer to the API for usage.`\r\n      );\r\n    }\r\n  });\r\n  resolved_data.forEach((value, idx) => {\r\n    if (value === void 0 && !parameters[idx].parameter_has_default) {\r\n      throw new Error(\r\n        `No value provided for required parameter: ${parameters[idx].parameter_name}`\r\n      );\r\n    }\r\n  });\r\n  return resolved_data;\r\n};\r\nasync function view_api() {\r\n  if (this.api_info)\r\n    return this.api_info;\r\n  const { hf_token } = this.options;\r\n  const { config } = this;\r\n  const headers = { \"Content-Type\": \"application/json\" };\r\n  if (hf_token) {\r\n    headers.Authorization = `Bearer ${hf_token}`;\r\n  }\r\n  if (!config) {\r\n    return;\r\n  }\r\n  try {\r\n    let response;\r\n    let api_info;\r\n    if (typeof window !== \"undefined\" && window.gradio_api_info) {\r\n      api_info = window.gradio_api_info;\r\n    } else {\r\n      if (semiver((config == null ? void 0 : config.version) || \"2.0.0\", \"3.30\") < 0) {\r\n        response = await this.fetch(SPACE_FETCHER_URL, {\r\n          method: \"POST\",\r\n          body: JSON.stringify({\r\n            serialize: false,\r\n            config: JSON.stringify(config)\r\n          }),\r\n          headers,\r\n          credentials: \"include\"\r\n        });\r\n      } else {\r\n        const url = join_urls(config.root, this.api_prefix, API_INFO_URL);\r\n        response = await this.fetch(url, {\r\n          headers,\r\n          credentials: \"include\"\r\n        });\r\n      }\r\n      if (!response.ok) {\r\n        throw new Error(BROKEN_CONNECTION_MSG);\r\n      }\r\n      api_info = await response.json();\r\n    }\r\n    if (\"api\" in api_info) {\r\n      api_info = api_info.api;\r\n    }\r\n    if (api_info.named_endpoints[\"/predict\"] && !api_info.unnamed_endpoints[\"0\"]) {\r\n      api_info.unnamed_endpoints[0] = api_info.named_endpoints[\"/predict\"];\r\n    }\r\n    return transform_api_info(api_info, config, this.api_map);\r\n  } catch (e) {\r\n    \"Could not get API info. \" + e.message;\r\n  }\r\n}\r\nasync function upload_files(root_url, files, upload_id) {\r\n  var _a;\r\n  const headers = {};\r\n  if ((_a = this == null ? void 0 : this.options) == null ? void 0 : _a.hf_token) {\r\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\r\n  }\r\n  const chunkSize = 1e3;\r\n  const uploadResponses = [];\r\n  let response;\r\n  for (let i = 0; i < files.length; i += chunkSize) {\r\n    const chunk = files.slice(i, i + chunkSize);\r\n    const formData = new FormData();\r\n    chunk.forEach((file) => {\r\n      formData.append(\"files\", file);\r\n    });\r\n    try {\r\n      const upload_url = upload_id ? `${root_url}${this.api_prefix}/${UPLOAD_URL}?upload_id=${upload_id}` : `${root_url}${this.api_prefix}/${UPLOAD_URL}`;\r\n      response = await this.fetch(upload_url, {\r\n        method: \"POST\",\r\n        body: formData,\r\n        headers,\r\n        credentials: \"include\"\r\n      });\r\n    } catch (e) {\r\n      throw new Error(BROKEN_CONNECTION_MSG + e.message);\r\n    }\r\n    if (!response.ok) {\r\n      const error_text = await response.text();\r\n      return { error: `HTTP ${response.status}: ${error_text}` };\r\n    }\r\n    const output = await response.json();\r\n    if (output) {\r\n      uploadResponses.push(...output);\r\n    }\r\n  }\r\n  return { files: uploadResponses };\r\n}\r\nasync function upload(file_data, root_url, upload_id, max_file_size) {\r\n  let files = (Array.isArray(file_data) ? file_data : [file_data]).map(\r\n    (file_data2) => file_data2.blob\r\n  );\r\n  const oversized_files = files.filter(\r\n    (f) => f.size > (max_file_size ?? Infinity)\r\n  );\r\n  if (oversized_files.length) {\r\n    throw new Error(\r\n      `File size exceeds the maximum allowed size of ${max_file_size} bytes: ${oversized_files.map((f) => f.name).join(\", \")}`\r\n    );\r\n  }\r\n  return await Promise.all(\r\n    await this.upload_files(root_url, files, upload_id).then(\r\n      async (response) => {\r\n        if (response.error) {\r\n          throw new Error(response.error);\r\n        } else {\r\n          if (response.files) {\r\n            return response.files.map((f, i) => {\r\n              const file = new FileData({\r\n                ...file_data[i],\r\n                path: f,\r\n                url: `${root_url}${this.api_prefix}/file=${f}`\r\n              });\r\n              return file;\r\n            });\r\n          }\r\n          return [];\r\n        }\r\n      }\r\n    )\r\n  );\r\n}\r\nasync function prepare_files(files, is_stream) {\r\n  return files.map(\r\n    (f) => new FileData({\r\n      path: f.name,\r\n      orig_name: f.name,\r\n      blob: f,\r\n      size: f.size,\r\n      mime_type: f.type,\r\n      is_stream\r\n    })\r\n  );\r\n}\r\nclass FileData {\r\n  constructor({\r\n    path,\r\n    url,\r\n    orig_name,\r\n    size,\r\n    blob,\r\n    is_stream,\r\n    mime_type,\r\n    alt_text\r\n  }) {\r\n    __publicField(this, \"path\");\r\n    __publicField(this, \"url\");\r\n    __publicField(this, \"orig_name\");\r\n    __publicField(this, \"size\");\r\n    __publicField(this, \"blob\");\r\n    __publicField(this, \"is_stream\");\r\n    __publicField(this, \"mime_type\");\r\n    __publicField(this, \"alt_text\");\r\n    __publicField(this, \"meta\", { _type: \"gradio.FileData\" });\r\n    this.path = path;\r\n    this.url = url;\r\n    this.orig_name = orig_name;\r\n    this.size = size;\r\n    this.blob = url ? void 0 : blob;\r\n    this.is_stream = is_stream;\r\n    this.mime_type = mime_type;\r\n    this.alt_text = alt_text;\r\n  }\r\n}\r\nclass Command {\r\n  constructor(command, meta) {\r\n    __publicField(this, \"type\");\r\n    __publicField(this, \"command\");\r\n    __publicField(this, \"meta\");\r\n    __publicField(this, \"fileData\");\r\n    this.type = \"command\";\r\n    this.command = command;\r\n    this.meta = meta;\r\n  }\r\n}\r\nconst is_node = typeof process !== \"undefined\" && process.versions && process.versions.node;\r\nfunction update_object(object, newValue, stack) {\r\n  while (stack.length > 1) {\r\n    const key2 = stack.shift();\r\n    if (typeof key2 === \"string\" || typeof key2 === \"number\") {\r\n      object = object[key2];\r\n    } else {\r\n      throw new Error(\"Invalid key type\");\r\n    }\r\n  }\r\n  const key = stack.shift();\r\n  if (typeof key === \"string\" || typeof key === \"number\") {\r\n    object[key] = newValue;\r\n  } else {\r\n    throw new Error(\"Invalid key type\");\r\n  }\r\n}\r\nasync function walk_and_store_blobs(data, type = void 0, path = [], root = false, endpoint_info = void 0) {\r\n  if (Array.isArray(data)) {\r\n    let blob_refs = [];\r\n    await Promise.all(\r\n      data.map(async (_, index) => {\r\n        var _a;\r\n        let new_path = path.slice();\r\n        new_path.push(String(index));\r\n        const array_refs = await walk_and_store_blobs(\r\n          data[index],\r\n          root ? ((_a = endpoint_info == null ? void 0 : endpoint_info.parameters[index]) == null ? void 0 : _a.component) || void 0 : type,\r\n          new_path,\r\n          false,\r\n          endpoint_info\r\n        );\r\n        blob_refs = blob_refs.concat(array_refs);\r\n      })\r\n    );\r\n    return blob_refs;\r\n  } else if (globalThis.Buffer && data instanceof globalThis.Buffer || data instanceof Blob) {\r\n    return [\r\n      {\r\n        path,\r\n        blob: new Blob([data]),\r\n        type\r\n      }\r\n    ];\r\n  } else if (typeof data === \"object\" && data !== null) {\r\n    let blob_refs = [];\r\n    for (const key of Object.keys(data)) {\r\n      const new_path = [...path, key];\r\n      const value = data[key];\r\n      blob_refs = blob_refs.concat(\r\n        await walk_and_store_blobs(\r\n          value,\r\n          void 0,\r\n          new_path,\r\n          false,\r\n          endpoint_info\r\n        )\r\n      );\r\n    }\r\n    return blob_refs;\r\n  }\r\n  return [];\r\n}\r\nfunction skip_queue(id, config) {\r\n  var _a, _b;\r\n  let fn_queue = (_b = (_a = config == null ? void 0 : config.dependencies) == null ? void 0 : _a.find((dep) => dep.id == id)) == null ? void 0 : _b.queue;\r\n  if (fn_queue != null) {\r\n    return !fn_queue;\r\n  }\r\n  return !config.enable_queue;\r\n}\r\nfunction post_message(message, origin) {\r\n  return new Promise((res, _rej) => {\r\n    const channel = new MessageChannel();\r\n    channel.port1.onmessage = ({ data }) => {\r\n      channel.port1.close();\r\n      res(data);\r\n    };\r\n    window.parent.postMessage(message, origin, [channel.port2]);\r\n  });\r\n}\r\nfunction handle_file(file_or_url) {\r\n  if (typeof file_or_url === \"string\") {\r\n    if (file_or_url.startsWith(\"http://\") || file_or_url.startsWith(\"https://\")) {\r\n      return {\r\n        path: file_or_url,\r\n        url: file_or_url,\r\n        orig_name: file_or_url.split(\"/\").pop() ?? \"unknown\",\r\n        meta: { _type: \"gradio.FileData\" }\r\n      };\r\n    }\r\n    if (is_node) {\r\n      return new Command(\"upload_file\", {\r\n        path: file_or_url,\r\n        name: file_or_url,\r\n        orig_path: file_or_url\r\n      });\r\n    }\r\n  } else if (typeof File !== \"undefined\" && file_or_url instanceof File) {\r\n    return new Blob([file_or_url]);\r\n  } else if (file_or_url instanceof Buffer) {\r\n    return new Blob([file_or_url]);\r\n  } else if (file_or_url instanceof Blob) {\r\n    return file_or_url;\r\n  }\r\n  throw new Error(\r\n    \"Invalid input: must be a URL, File, Blob, or Buffer object.\"\r\n  );\r\n}\r\nfunction handle_payload(resolved_payload, dependency, components, type, with_null_state = false) {\r\n  if (type === \"input\" && !with_null_state) {\r\n    throw new Error(\"Invalid code path. Cannot skip state inputs for input.\");\r\n  }\r\n  if (type === \"output\" && with_null_state) {\r\n    return resolved_payload;\r\n  }\r\n  let updated_payload = [];\r\n  let payload_index = 0;\r\n  const deps = type === \"input\" ? dependency.inputs : dependency.outputs;\r\n  for (let i = 0; i < deps.length; i++) {\r\n    const input_id = deps[i];\r\n    const component = components.find((c) => c.id === input_id);\r\n    if ((component == null ? void 0 : component.type) === \"state\") {\r\n      if (with_null_state) {\r\n        if (resolved_payload.length === deps.length) {\r\n          const value = resolved_payload[payload_index];\r\n          updated_payload.push(value);\r\n          payload_index++;\r\n        } else {\r\n          updated_payload.push(null);\r\n        }\r\n      } else {\r\n        payload_index++;\r\n        continue;\r\n      }\r\n      continue;\r\n    } else {\r\n      const value = resolved_payload[payload_index];\r\n      updated_payload.push(value);\r\n      payload_index++;\r\n    }\r\n  }\r\n  return updated_payload;\r\n}\r\nasync function handle_blob(endpoint, data, api_info) {\r\n  const self = this;\r\n  await process_local_file_commands(self, data);\r\n  const blobRefs = await walk_and_store_blobs(\r\n    data,\r\n    void 0,\r\n    [],\r\n    true,\r\n    api_info\r\n  );\r\n  const results = await Promise.all(\r\n    blobRefs.map(async ({ path, blob, type }) => {\r\n      if (!blob)\r\n        return { path, type };\r\n      const response = await self.upload_files(endpoint, [blob]);\r\n      const file_url = response.files && response.files[0];\r\n      return {\r\n        path,\r\n        file_url,\r\n        type,\r\n        name: typeof File !== \"undefined\" && blob instanceof File ? blob == null ? void 0 : blob.name : void 0\r\n      };\r\n    })\r\n  );\r\n  results.forEach(({ path, file_url, type, name }) => {\r\n    if (type === \"Gallery\") {\r\n      update_object(data, file_url, path);\r\n    } else if (file_url) {\r\n      const file = new FileData({ path: file_url, orig_name: name });\r\n      update_object(data, file, path);\r\n    }\r\n  });\r\n  return data;\r\n}\r\nasync function process_local_file_commands(client2, data) {\r\n  var _a, _b;\r\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\r\n  if (!root) {\r\n    throw new Error(ROOT_URL_ERROR_MSG);\r\n  }\r\n  await recursively_process_commands(client2, data);\r\n}\r\nasync function recursively_process_commands(client2, data, path = []) {\r\n  for (const key in data) {\r\n    if (data[key] instanceof Command) {\r\n      await process_single_command(client2, data, key);\r\n    } else if (typeof data[key] === \"object\" && data[key] !== null) {\r\n      await recursively_process_commands(client2, data[key], [...path, key]);\r\n    }\r\n  }\r\n}\r\nasync function process_single_command(client2, data, key) {\r\n  var _a, _b;\r\n  let cmd_item = data[key];\r\n  const root = ((_a = client2.config) == null ? void 0 : _a.root) || ((_b = client2.config) == null ? void 0 : _b.root_url);\r\n  if (!root) {\r\n    throw new Error(ROOT_URL_ERROR_MSG);\r\n  }\r\n  try {\r\n    let fileBuffer;\r\n    let fullPath;\r\n    if (typeof process !== \"undefined\" && process.versions && process.versions.node) {\r\n      const fs = await import(\"fs/promises\");\r\n      const path = await import(\"path\");\r\n      fullPath = path.resolve(process.cwd(), cmd_item.meta.path);\r\n      fileBuffer = await fs.readFile(fullPath);\r\n    } else {\r\n      throw new Error(NODEJS_FS_ERROR_MSG);\r\n    }\r\n    const file = new Blob([fileBuffer], { type: \"application/octet-stream\" });\r\n    const response = await client2.upload_files(root, [file]);\r\n    const file_url = response.files && response.files[0];\r\n    if (file_url) {\r\n      const fileData = new FileData({\r\n        path: file_url,\r\n        orig_name: cmd_item.meta.name || \"\"\r\n      });\r\n      data[key] = fileData;\r\n    }\r\n  } catch (error) {\r\n    console.error(FILE_PROCESSING_ERROR_MSG, error);\r\n  }\r\n}\r\nasync function post_data(url, body, additional_headers) {\r\n  const headers = { \"Content-Type\": \"application/json\" };\r\n  if (this.options.hf_token) {\r\n    headers.Authorization = `Bearer ${this.options.hf_token}`;\r\n  }\r\n  try {\r\n    var response = await this.fetch(url, {\r\n      method: \"POST\",\r\n      body: JSON.stringify(body),\r\n      headers: { ...headers, ...additional_headers },\r\n      credentials: \"include\"\r\n    });\r\n  } catch (e) {\r\n    return [{ error: BROKEN_CONNECTION_MSG }, 500];\r\n  }\r\n  let output;\r\n  let status;\r\n  try {\r\n    output = await response.json();\r\n    status = response.status;\r\n  } catch (e) {\r\n    output = { error: `Could not parse server response: ${e}` };\r\n    status = 500;\r\n  }\r\n  return [output, status];\r\n}\r\nasync function predict(endpoint, data = {}) {\r\n  let data_returned = false;\r\n  let status_complete = false;\r\n  if (!this.config) {\r\n    throw new Error(\"Could not resolve app config\");\r\n  }\r\n  if (typeof endpoint === \"number\") {\r\n    this.config.dependencies.find((dep) => dep.id == endpoint);\r\n  } else {\r\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\r\n    this.config.dependencies.find(\r\n      (dep) => dep.id == this.api_map[trimmed_endpoint]\r\n    );\r\n  }\r\n  return new Promise(async (resolve, reject) => {\r\n    const app = this.submit(endpoint, data, null, null, true);\r\n    let result;\r\n    for await (const message of app) {\r\n      if (message.type === \"data\") {\r\n        if (status_complete) {\r\n          resolve(result);\r\n        }\r\n        data_returned = true;\r\n        result = message;\r\n      }\r\n      if (message.type === \"status\") {\r\n        if (message.stage === \"error\")\r\n          reject(message);\r\n        if (message.stage === \"complete\") {\r\n          status_complete = true;\r\n          if (data_returned) {\r\n            resolve(result);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n}\r\nasync function check_space_status(id, type, status_callback) {\r\n  let endpoint = type === \"subdomain\" ? `https://huggingface.co/api/spaces/by-subdomain/${id}` : `https://huggingface.co/api/spaces/${id}`;\r\n  let response;\r\n  let _status;\r\n  try {\r\n    response = await fetch(endpoint);\r\n    _status = response.status;\r\n    if (_status !== 200) {\r\n      throw new Error();\r\n    }\r\n    response = await response.json();\r\n  } catch (e) {\r\n    status_callback({\r\n      status: \"error\",\r\n      load_status: \"error\",\r\n      message: SPACE_STATUS_ERROR_MSG,\r\n      detail: \"NOT_FOUND\"\r\n    });\r\n    return;\r\n  }\r\n  if (!response || _status !== 200)\r\n    return;\r\n  const {\r\n    runtime: { stage },\r\n    id: space_name\r\n  } = response;\r\n  switch (stage) {\r\n    case \"STOPPED\":\r\n    case \"SLEEPING\":\r\n      status_callback({\r\n        status: \"sleeping\",\r\n        load_status: \"pending\",\r\n        message: \"Space is asleep. Waking it up...\",\r\n        detail: stage\r\n      });\r\n      setTimeout(() => {\r\n        check_space_status(id, type, status_callback);\r\n      }, 1e3);\r\n      break;\r\n    case \"PAUSED\":\r\n      status_callback({\r\n        status: \"paused\",\r\n        load_status: \"error\",\r\n        message: \"This space has been paused by the author. If you would like to try this demo, consider duplicating the space.\",\r\n        detail: stage,\r\n        discussions_enabled: await discussions_enabled(space_name)\r\n      });\r\n      break;\r\n    case \"RUNNING\":\r\n    case \"RUNNING_BUILDING\":\r\n      status_callback({\r\n        status: \"running\",\r\n        load_status: \"complete\",\r\n        message: \"Space is running.\",\r\n        detail: stage\r\n      });\r\n      break;\r\n    case \"BUILDING\":\r\n      status_callback({\r\n        status: \"building\",\r\n        load_status: \"pending\",\r\n        message: \"Space is building...\",\r\n        detail: stage\r\n      });\r\n      setTimeout(() => {\r\n        check_space_status(id, type, status_callback);\r\n      }, 1e3);\r\n      break;\r\n    case \"APP_STARTING\":\r\n      status_callback({\r\n        status: \"starting\",\r\n        load_status: \"pending\",\r\n        message: \"Space is starting...\",\r\n        detail: stage\r\n      });\r\n      setTimeout(() => {\r\n        check_space_status(id, type, status_callback);\r\n      }, 1e3);\r\n      break;\r\n    default:\r\n      status_callback({\r\n        status: \"space_error\",\r\n        load_status: \"error\",\r\n        message: \"This space is experiencing an issue.\",\r\n        detail: stage,\r\n        discussions_enabled: await discussions_enabled(space_name)\r\n      });\r\n      break;\r\n  }\r\n}\r\nconst check_and_wake_space = async (space_id, status_callback) => {\r\n  let retries = 0;\r\n  const max_retries = 12;\r\n  const check_interval = 5e3;\r\n  return new Promise((resolve) => {\r\n    check_space_status(\r\n      space_id,\r\n      RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\",\r\n      (status) => {\r\n        status_callback(status);\r\n        if (status.status === \"running\") {\r\n          resolve();\r\n        } else if (status.status === \"error\" || status.status === \"paused\" || status.status === \"space_error\") {\r\n          resolve();\r\n        } else if (status.status === \"sleeping\" || status.status === \"building\") {\r\n          if (retries < max_retries) {\r\n            retries++;\r\n            setTimeout(() => {\r\n              check_and_wake_space(space_id, status_callback).then(resolve);\r\n            }, check_interval);\r\n          } else {\r\n            resolve();\r\n          }\r\n        }\r\n      }\r\n    );\r\n  });\r\n};\r\nconst RE_DISABLED_DISCUSSION = /^(?=[^]*\\b[dD]iscussions{0,1}\\b)(?=[^]*\\b[dD]isabled\\b)[^]*$/;\r\nasync function discussions_enabled(space_id) {\r\n  try {\r\n    const r = await fetch(\r\n      `https://huggingface.co/api/spaces/${space_id}/discussions`,\r\n      {\r\n        method: \"HEAD\"\r\n      }\r\n    );\r\n    const error = r.headers.get(\"x-error-message\");\r\n    if (!r.ok || error && RE_DISABLED_DISCUSSION.test(error))\r\n      return false;\r\n    return true;\r\n  } catch (e) {\r\n    return false;\r\n  }\r\n}\r\nasync function get_space_hardware(space_id, hf_token) {\r\n  const headers = {};\r\n  if (hf_token) {\r\n    headers.Authorization = `Bearer ${hf_token}`;\r\n  }\r\n  try {\r\n    const res = await fetch(\r\n      `https://huggingface.co/api/spaces/${space_id}/${RUNTIME_URL}`,\r\n      { headers }\r\n    );\r\n    if (res.status !== 200)\r\n      throw new Error(\"Space hardware could not be obtained.\");\r\n    const { hardware } = await res.json();\r\n    return hardware.current;\r\n  } catch (e) {\r\n    throw new Error(e.message);\r\n  }\r\n}\r\nasync function set_space_timeout(space_id, timeout, hf_token) {\r\n  const headers = {};\r\n  if (hf_token) {\r\n    headers.Authorization = `Bearer ${hf_token}`;\r\n  }\r\n  const body = {\r\n    seconds: timeout\r\n  };\r\n  try {\r\n    const res = await fetch(\r\n      `https://huggingface.co/api/spaces/${space_id}/${SLEEPTIME_URL}`,\r\n      {\r\n        method: \"POST\",\r\n        headers: { \"Content-Type\": \"application/json\", ...headers },\r\n        body: JSON.stringify(body)\r\n      }\r\n    );\r\n    if (res.status !== 200) {\r\n      throw new Error(\r\n        \"Could not set sleep timeout on duplicated Space. Please visit *ADD HF LINK TO SETTINGS* to set a timeout manually to reduce billing charges.\"\r\n      );\r\n    }\r\n    const response = await res.json();\r\n    return response;\r\n  } catch (e) {\r\n    throw new Error(e.message);\r\n  }\r\n}\r\nconst hardware_types = [\r\n  \"cpu-basic\",\r\n  \"cpu-upgrade\",\r\n  \"cpu-xl\",\r\n  \"t4-small\",\r\n  \"t4-medium\",\r\n  \"a10g-small\",\r\n  \"a10g-large\",\r\n  \"a10g-largex2\",\r\n  \"a10g-largex4\",\r\n  \"a100-large\",\r\n  \"zero-a10g\",\r\n  \"h100\",\r\n  \"h100x8\"\r\n];\r\nasync function duplicate(app_reference, options) {\r\n  const { hf_token, private: _private, hardware, timeout, auth } = options;\r\n  if (hardware && !hardware_types.includes(hardware)) {\r\n    throw new Error(\r\n      `Invalid hardware type provided. Valid types are: ${hardware_types.map((v) => `\"${v}\"`).join(\",\")}.`\r\n    );\r\n  }\r\n  const { http_protocol, host } = await process_endpoint(\r\n    app_reference,\r\n    hf_token\r\n  );\r\n  let cookies = null;\r\n  if (auth) {\r\n    const cookie_header = await get_cookie_header(\r\n      http_protocol,\r\n      host,\r\n      auth,\r\n      fetch\r\n    );\r\n    if (cookie_header)\r\n      cookies = parse_and_set_cookies(cookie_header);\r\n  }\r\n  const headers = {\r\n    Authorization: `Bearer ${hf_token}`,\r\n    \"Content-Type\": \"application/json\",\r\n    ...cookies ? { Cookie: cookies.join(\"; \") } : {}\r\n  };\r\n  const user = (await (await fetch(`https://huggingface.co/api/whoami-v2`, {\r\n    headers\r\n  })).json()).name;\r\n  const space_name = app_reference.split(\"/\")[1];\r\n  const body = {\r\n    repository: `${user}/${space_name}`\r\n  };\r\n  if (_private) {\r\n    body.private = true;\r\n  }\r\n  let original_hardware;\r\n  try {\r\n    if (!hardware) {\r\n      original_hardware = await get_space_hardware(app_reference, hf_token);\r\n    }\r\n  } catch (e) {\r\n    throw Error(SPACE_METADATA_ERROR_MSG + e.message);\r\n  }\r\n  const requested_hardware = hardware || original_hardware || \"cpu-basic\";\r\n  body.hardware = requested_hardware;\r\n  try {\r\n    const response = await fetch(\r\n      `https://huggingface.co/api/spaces/${app_reference}/duplicate`,\r\n      {\r\n        method: \"POST\",\r\n        headers,\r\n        body: JSON.stringify(body)\r\n      }\r\n    );\r\n    if (response.status === 409) {\r\n      try {\r\n        const client2 = await Client.connect(`${user}/${space_name}`, options);\r\n        return client2;\r\n      } catch (error) {\r\n        console.error(\"Failed to connect Client instance:\", error);\r\n        throw error;\r\n      }\r\n    } else if (response.status !== 200) {\r\n      throw new Error(response.statusText);\r\n    }\r\n    const duplicated_space = await response.json();\r\n    await set_space_timeout(`${user}/${space_name}`, timeout || 300, hf_token);\r\n    return await Client.connect(\r\n      get_space_reference(duplicated_space.url),\r\n      options\r\n    );\r\n  } catch (e) {\r\n    throw new Error(e);\r\n  }\r\n}\r\nfunction get_space_reference(url) {\r\n  const regex = /https:\\/\\/huggingface.co\\/spaces\\/([^/]+\\/[^/]+)/;\r\n  const match = url.match(regex);\r\n  if (match) {\r\n    return match[1];\r\n  }\r\n}\r\nclass TextLineStream extends TransformStream {\r\n  /** Constructs a new instance. */\r\n  constructor(options = { allowCR: false }) {\r\n    super({\r\n      transform: (chars, controller) => {\r\n        chars = __privateGet(this, _currentLine) + chars;\r\n        while (true) {\r\n          const lfIndex = chars.indexOf(\"\\n\");\r\n          const crIndex = options.allowCR ? chars.indexOf(\"\\r\") : -1;\r\n          if (crIndex !== -1 && crIndex !== chars.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {\r\n            controller.enqueue(chars.slice(0, crIndex));\r\n            chars = chars.slice(crIndex + 1);\r\n            continue;\r\n          }\r\n          if (lfIndex === -1)\r\n            break;\r\n          const endIndex = chars[lfIndex - 1] === \"\\r\" ? lfIndex - 1 : lfIndex;\r\n          controller.enqueue(chars.slice(0, endIndex));\r\n          chars = chars.slice(lfIndex + 1);\r\n        }\r\n        __privateSet(this, _currentLine, chars);\r\n      },\r\n      flush: (controller) => {\r\n        if (__privateGet(this, _currentLine) === \"\")\r\n          return;\r\n        const currentLine = options.allowCR && __privateGet(this, _currentLine).endsWith(\"\\r\") ? __privateGet(this, _currentLine).slice(0, -1) : __privateGet(this, _currentLine);\r\n        controller.enqueue(currentLine);\r\n      }\r\n    });\r\n    __privateAdd(this, _currentLine, \"\");\r\n  }\r\n}\r\n_currentLine = new WeakMap();\r\nfunction stream$1(input) {\r\n  let decoder = new TextDecoderStream();\r\n  let split2 = new TextLineStream({ allowCR: true });\r\n  return input.pipeThrough(decoder).pipeThrough(split2);\r\n}\r\nfunction split(input) {\r\n  let rgx = /[:]\\s*/;\r\n  let match = rgx.exec(input);\r\n  let idx = match && match.index;\r\n  if (idx) {\r\n    return [\r\n      input.substring(0, idx),\r\n      input.substring(idx + match[0].length)\r\n    ];\r\n  }\r\n}\r\nfunction fallback(headers, key, value) {\r\n  let tmp = headers.get(key);\r\n  if (!tmp)\r\n    headers.set(key, value);\r\n}\r\nasync function* events(res, signal) {\r\n  if (!res.body)\r\n    return;\r\n  let iter = stream$1(res.body);\r\n  let line, reader = iter.getReader();\r\n  let event;\r\n  for (; ; ) {\r\n    if (signal && signal.aborted) {\r\n      return reader.cancel();\r\n    }\r\n    line = await reader.read();\r\n    if (line.done)\r\n      return;\r\n    if (!line.value) {\r\n      if (event)\r\n        yield event;\r\n      event = void 0;\r\n      continue;\r\n    }\r\n    let [field, value] = split(line.value) || [];\r\n    if (!field)\r\n      continue;\r\n    if (field === \"data\") {\r\n      event || (event = {});\r\n      event[field] = event[field] ? event[field] + \"\\n\" + value : value;\r\n    } else if (field === \"event\") {\r\n      event || (event = {});\r\n      event[field] = value;\r\n    } else if (field === \"id\") {\r\n      event || (event = {});\r\n      event[field] = +value || value;\r\n    } else if (field === \"retry\") {\r\n      event || (event = {});\r\n      event[field] = +value || void 0;\r\n    }\r\n  }\r\n}\r\nasync function stream(input, init) {\r\n  let req = new Request(input, init);\r\n  fallback(req.headers, \"Accept\", \"text/event-stream\");\r\n  fallback(req.headers, \"Content-Type\", \"application/json\");\r\n  let r = await fetch(req);\r\n  if (!r.ok)\r\n    throw r;\r\n  return events(r, req.signal);\r\n}\r\nasync function open_stream() {\r\n  let {\r\n    event_callbacks,\r\n    unclosed_events,\r\n    pending_stream_messages,\r\n    stream_status,\r\n    config,\r\n    jwt\r\n  } = this;\r\n  const that = this;\r\n  if (!config) {\r\n    throw new Error(\"Could not resolve app config\");\r\n  }\r\n  stream_status.open = true;\r\n  let stream2 = null;\r\n  let params = new URLSearchParams({\r\n    session_hash: this.session_hash\r\n  }).toString();\r\n  let url = new URL(`${config.root}${this.api_prefix}/${SSE_URL}?${params}`);\r\n  if (jwt) {\r\n    url.searchParams.set(\"__sign\", jwt);\r\n  }\r\n  stream2 = this.stream(url);\r\n  if (!stream2) {\r\n    console.warn(\"Cannot connect to SSE endpoint: \" + url.toString());\r\n    return;\r\n  }\r\n  stream2.onmessage = async function(event) {\r\n    let _data = JSON.parse(event.data);\r\n    if (_data.msg === \"close_stream\") {\r\n      close_stream(stream_status, that.abort_controller);\r\n      return;\r\n    }\r\n    const event_id = _data.event_id;\r\n    if (!event_id) {\r\n      await Promise.all(\r\n        Object.keys(event_callbacks).map(\r\n          (event_id2) => event_callbacks[event_id2](_data)\r\n        )\r\n      );\r\n    } else if (event_callbacks[event_id] && config) {\r\n      if (_data.msg === \"process_completed\" && [\"sse\", \"sse_v1\", \"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(\r\n        config.protocol\r\n      )) {\r\n        unclosed_events.delete(event_id);\r\n      }\r\n      let fn2 = event_callbacks[event_id];\r\n      if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\r\n        setTimeout(fn2, 0, _data);\r\n      } else {\r\n        fn2(_data);\r\n      }\r\n    } else {\r\n      if (!pending_stream_messages[event_id]) {\r\n        pending_stream_messages[event_id] = [];\r\n      }\r\n      pending_stream_messages[event_id].push(_data);\r\n    }\r\n  };\r\n  stream2.onerror = async function() {\r\n    await Promise.all(\r\n      Object.keys(event_callbacks).map(\r\n        (event_id) => event_callbacks[event_id]({\r\n          msg: \"unexpected_error\",\r\n          message: BROKEN_CONNECTION_MSG\r\n        })\r\n      )\r\n    );\r\n  };\r\n}\r\nfunction close_stream(stream_status, abort_controller) {\r\n  if (stream_status) {\r\n    stream_status.open = false;\r\n    abort_controller == null ? void 0 : abort_controller.abort();\r\n  }\r\n}\r\nfunction apply_diff_stream(pending_diff_streams, event_id, data) {\r\n  let is_first_generation = !pending_diff_streams[event_id];\r\n  if (is_first_generation) {\r\n    pending_diff_streams[event_id] = [];\r\n    data.data.forEach((value, i) => {\r\n      pending_diff_streams[event_id][i] = value;\r\n    });\r\n  } else {\r\n    data.data.forEach((value, i) => {\r\n      let new_data = apply_diff(pending_diff_streams[event_id][i], value);\r\n      pending_diff_streams[event_id][i] = new_data;\r\n      data.data[i] = new_data;\r\n    });\r\n  }\r\n}\r\nfunction apply_diff(obj, diff) {\r\n  diff.forEach(([action, path, value]) => {\r\n    obj = apply_edit(obj, path, action, value);\r\n  });\r\n  return obj;\r\n}\r\nfunction apply_edit(target, path, action, value) {\r\n  if (path.length === 0) {\r\n    if (action === \"replace\") {\r\n      return value;\r\n    } else if (action === \"append\") {\r\n      return target + value;\r\n    }\r\n    throw new Error(`Unsupported action: ${action}`);\r\n  }\r\n  let current = target;\r\n  for (let i = 0; i < path.length - 1; i++) {\r\n    current = current[path[i]];\r\n  }\r\n  const last_path = path[path.length - 1];\r\n  switch (action) {\r\n    case \"replace\":\r\n      current[last_path] = value;\r\n      break;\r\n    case \"append\":\r\n      current[last_path] += value;\r\n      break;\r\n    case \"add\":\r\n      if (Array.isArray(current)) {\r\n        current.splice(Number(last_path), 0, value);\r\n      } else {\r\n        current[last_path] = value;\r\n      }\r\n      break;\r\n    case \"delete\":\r\n      if (Array.isArray(current)) {\r\n        current.splice(Number(last_path), 1);\r\n      } else {\r\n        delete current[last_path];\r\n      }\r\n      break;\r\n    default:\r\n      throw new Error(`Unknown action: ${action}`);\r\n  }\r\n  return target;\r\n}\r\nfunction readable_stream(input, init = {}) {\r\n  const instance = {\r\n    close: () => {\r\n      console.warn(\"Method not implemented.\");\r\n    },\r\n    onerror: null,\r\n    onmessage: null,\r\n    onopen: null,\r\n    readyState: 0,\r\n    url: input.toString(),\r\n    withCredentials: false,\r\n    CONNECTING: 0,\r\n    OPEN: 1,\r\n    CLOSED: 2,\r\n    addEventListener: () => {\r\n      throw new Error(\"Method not implemented.\");\r\n    },\r\n    dispatchEvent: () => {\r\n      throw new Error(\"Method not implemented.\");\r\n    },\r\n    removeEventListener: () => {\r\n      throw new Error(\"Method not implemented.\");\r\n    }\r\n  };\r\n  stream(input, init).then(async (res) => {\r\n    instance.readyState = instance.OPEN;\r\n    try {\r\n      for await (const chunk of res) {\r\n        instance.onmessage && instance.onmessage(chunk);\r\n      }\r\n      instance.readyState = instance.CLOSED;\r\n    } catch (e) {\r\n      instance.onerror && instance.onerror(e);\r\n      instance.readyState = instance.CLOSED;\r\n    }\r\n  }).catch((e) => {\r\n    console.error(e);\r\n    instance.onerror && instance.onerror(e);\r\n    instance.readyState = instance.CLOSED;\r\n  });\r\n  return instance;\r\n}\r\nfunction submit(endpoint, data = {}, event_data, trigger_id, all_events) {\r\n  var _a;\r\n  try {\r\n    let fire_event = function(event) {\r\n      if (all_events || events_to_publish[event.type]) {\r\n        push_event(event);\r\n      }\r\n    }, close = function() {\r\n      done = true;\r\n      while (resolvers.length > 0)\r\n        resolvers.shift()({\r\n          value: void 0,\r\n          done: true\r\n        });\r\n    }, push = function(data2) {\r\n      if (done)\r\n        return;\r\n      if (resolvers.length > 0) {\r\n        resolvers.shift()(data2);\r\n      } else {\r\n        values.push(data2);\r\n      }\r\n    }, push_error = function(error) {\r\n      push(thenable_reject(error));\r\n      close();\r\n    }, push_event = function(event) {\r\n      push({ value: event, done: false });\r\n    }, next = function() {\r\n      if (values.length > 0)\r\n        return Promise.resolve(values.shift());\r\n      if (done)\r\n        return Promise.resolve({ value: void 0, done: true });\r\n      return new Promise((resolve) => resolvers.push(resolve));\r\n    };\r\n    const { hf_token } = this.options;\r\n    const {\r\n      fetch: fetch2,\r\n      app_reference,\r\n      config,\r\n      session_hash,\r\n      api_info,\r\n      api_map,\r\n      stream_status,\r\n      pending_stream_messages,\r\n      pending_diff_streams,\r\n      event_callbacks,\r\n      unclosed_events,\r\n      post_data: post_data2,\r\n      options,\r\n      api_prefix\r\n    } = this;\r\n    const that = this;\r\n    if (!api_info)\r\n      throw new Error(\"No API found\");\r\n    if (!config)\r\n      throw new Error(\"Could not resolve app config\");\r\n    let { fn_index, endpoint_info, dependency } = get_endpoint_info(\r\n      api_info,\r\n      endpoint,\r\n      api_map,\r\n      config\r\n    );\r\n    let resolved_data = map_data_to_params(data, endpoint_info);\r\n    let websocket;\r\n    let stream2;\r\n    let protocol = config.protocol ?? \"ws\";\r\n    let event_id_final = \"\";\r\n    let event_id_cb = () => event_id_final;\r\n    const _endpoint = typeof endpoint === \"number\" ? \"/predict\" : endpoint;\r\n    let payload;\r\n    let event_id = null;\r\n    let complete = false;\r\n    let last_status = {};\r\n    let url_params = typeof window !== \"undefined\" && typeof document !== \"undefined\" ? new URLSearchParams(window.location.search).toString() : \"\";\r\n    const events_to_publish = ((_a = options == null ? void 0 : options.events) == null ? void 0 : _a.reduce(\r\n      (acc, event) => {\r\n        acc[event] = true;\r\n        return acc;\r\n      },\r\n      {}\r\n    )) || {};\r\n    async function cancel() {\r\n      const _status = {\r\n        stage: \"complete\",\r\n        queue: false,\r\n        time: /* @__PURE__ */ new Date()\r\n      };\r\n      complete = _status;\r\n      fire_event({\r\n        ..._status,\r\n        type: \"status\",\r\n        endpoint: _endpoint,\r\n        fn_index\r\n      });\r\n      let reset_request = {};\r\n      let cancel_request = {};\r\n      if (protocol === \"ws\") {\r\n        if (websocket && websocket.readyState === 0) {\r\n          websocket.addEventListener(\"open\", () => {\r\n            websocket.close();\r\n          });\r\n        } else {\r\n          websocket.close();\r\n        }\r\n        reset_request = { fn_index, session_hash };\r\n      } else {\r\n        close_stream(stream_status, that.abort_controller);\r\n        close();\r\n        reset_request = { event_id };\r\n        cancel_request = { event_id, session_hash, fn_index };\r\n      }\r\n      try {\r\n        if (!config) {\r\n          throw new Error(\"Could not resolve app config\");\r\n        }\r\n        if (\"event_id\" in cancel_request) {\r\n          await fetch2(`${config.root}${api_prefix}/${CANCEL_URL}`, {\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            method: \"POST\",\r\n            body: JSON.stringify(cancel_request)\r\n          });\r\n        }\r\n        await fetch2(`${config.root}${api_prefix}/${RESET_URL}`, {\r\n          headers: { \"Content-Type\": \"application/json\" },\r\n          method: \"POST\",\r\n          body: JSON.stringify(reset_request)\r\n        });\r\n      } catch (e) {\r\n        console.warn(\r\n          \"The `/reset` endpoint could not be called. Subsequent endpoint results may be unreliable.\"\r\n        );\r\n      }\r\n    }\r\n    const resolve_heartbeat = async (config2) => {\r\n      await this._resolve_hearbeat(config2);\r\n    };\r\n    async function handle_render_config(render_config) {\r\n      if (!config)\r\n        return;\r\n      let render_id = render_config.render_id;\r\n      config.components = [\r\n        ...config.components.filter((c) => c.props.rendered_in !== render_id),\r\n        ...render_config.components\r\n      ];\r\n      config.dependencies = [\r\n        ...config.dependencies.filter((d) => d.rendered_in !== render_id),\r\n        ...render_config.dependencies\r\n      ];\r\n      const any_state = config.components.some((c) => c.type === \"state\");\r\n      const any_unload = config.dependencies.some(\r\n        (d) => d.targets.some((t) => t[1] === \"unload\")\r\n      );\r\n      config.connect_heartbeat = any_state || any_unload;\r\n      await resolve_heartbeat(config);\r\n      fire_event({\r\n        type: \"render\",\r\n        data: render_config,\r\n        endpoint: _endpoint,\r\n        fn_index\r\n      });\r\n    }\r\n    this.handle_blob(config.root, resolved_data, endpoint_info).then(\r\n      async (_payload) => {\r\n        var _a2;\r\n        let input_data = handle_payload(\r\n          _payload,\r\n          dependency,\r\n          config.components,\r\n          \"input\",\r\n          true\r\n        );\r\n        payload = {\r\n          data: input_data || [],\r\n          event_data,\r\n          fn_index,\r\n          trigger_id\r\n        };\r\n        if (skip_queue(fn_index, config)) {\r\n          fire_event({\r\n            type: \"status\",\r\n            endpoint: _endpoint,\r\n            stage: \"pending\",\r\n            queue: false,\r\n            fn_index,\r\n            time: /* @__PURE__ */ new Date()\r\n          });\r\n          post_data2(\r\n            `${config.root}${api_prefix}/run${_endpoint.startsWith(\"/\") ? _endpoint : `/${_endpoint}`}${url_params ? \"?\" + url_params : \"\"}`,\r\n            {\r\n              ...payload,\r\n              session_hash\r\n            }\r\n          ).then(([output, status_code]) => {\r\n            const data2 = output.data;\r\n            if (status_code == 200) {\r\n              fire_event({\r\n                type: \"data\",\r\n                endpoint: _endpoint,\r\n                fn_index,\r\n                data: handle_payload(\r\n                  data2,\r\n                  dependency,\r\n                  config.components,\r\n                  \"output\",\r\n                  options.with_null_state\r\n                ),\r\n                time: /* @__PURE__ */ new Date(),\r\n                event_data,\r\n                trigger_id\r\n              });\r\n              if (output.render_config) {\r\n                handle_render_config(output.render_config);\r\n              }\r\n              fire_event({\r\n                type: \"status\",\r\n                endpoint: _endpoint,\r\n                fn_index,\r\n                stage: \"complete\",\r\n                eta: output.average_duration,\r\n                queue: false,\r\n                time: /* @__PURE__ */ new Date()\r\n              });\r\n            } else {\r\n              fire_event({\r\n                type: \"status\",\r\n                stage: \"error\",\r\n                endpoint: _endpoint,\r\n                fn_index,\r\n                message: output.error,\r\n                queue: false,\r\n                time: /* @__PURE__ */ new Date()\r\n              });\r\n            }\r\n          }).catch((e) => {\r\n            fire_event({\r\n              type: \"status\",\r\n              stage: \"error\",\r\n              message: e.message,\r\n              endpoint: _endpoint,\r\n              fn_index,\r\n              queue: false,\r\n              time: /* @__PURE__ */ new Date()\r\n            });\r\n          });\r\n        } else if (protocol == \"ws\") {\r\n          const { ws_protocol, host } = await process_endpoint(\r\n            app_reference,\r\n            hf_token\r\n          );\r\n          fire_event({\r\n            type: \"status\",\r\n            stage: \"pending\",\r\n            queue: true,\r\n            endpoint: _endpoint,\r\n            fn_index,\r\n            time: /* @__PURE__ */ new Date()\r\n          });\r\n          let url = new URL(\r\n            `${ws_protocol}://${resolve_root(\r\n              host,\r\n              config.path,\r\n              true\r\n            )}/queue/join${url_params ? \"?\" + url_params : \"\"}`\r\n          );\r\n          if (this.jwt) {\r\n            url.searchParams.set(\"__sign\", this.jwt);\r\n          }\r\n          websocket = new WebSocket(url);\r\n          websocket.onclose = (evt) => {\r\n            if (!evt.wasClean) {\r\n              fire_event({\r\n                type: \"status\",\r\n                stage: \"error\",\r\n                broken: true,\r\n                message: BROKEN_CONNECTION_MSG,\r\n                queue: true,\r\n                endpoint: _endpoint,\r\n                fn_index,\r\n                time: /* @__PURE__ */ new Date()\r\n              });\r\n            }\r\n          };\r\n          websocket.onmessage = function(event) {\r\n            const _data = JSON.parse(event.data);\r\n            const { type, status, data: data2 } = handle_message(\r\n              _data,\r\n              last_status[fn_index]\r\n            );\r\n            if (type === \"update\" && status && !complete) {\r\n              fire_event({\r\n                type: \"status\",\r\n                endpoint: _endpoint,\r\n                fn_index,\r\n                time: /* @__PURE__ */ new Date(),\r\n                ...status\r\n              });\r\n              if (status.stage === \"error\") {\r\n                websocket.close();\r\n              }\r\n            } else if (type === \"hash\") {\r\n              websocket.send(JSON.stringify({ fn_index, session_hash }));\r\n              return;\r\n            } else if (type === \"data\") {\r\n              websocket.send(JSON.stringify({ ...payload, session_hash }));\r\n            } else if (type === \"complete\") {\r\n              complete = status;\r\n            } else if (type === \"log\") {\r\n              fire_event({\r\n                type: \"log\",\r\n                log: data2.log,\r\n                level: data2.level,\r\n                endpoint: _endpoint,\r\n                duration: data2.duration,\r\n                visible: data2.visible,\r\n                fn_index\r\n              });\r\n            } else if (type === \"generating\") {\r\n              fire_event({\r\n                type: \"status\",\r\n                time: /* @__PURE__ */ new Date(),\r\n                ...status,\r\n                stage: status == null ? void 0 : status.stage,\r\n                queue: true,\r\n                endpoint: _endpoint,\r\n                fn_index\r\n              });\r\n            }\r\n            if (data2) {\r\n              fire_event({\r\n                type: \"data\",\r\n                time: /* @__PURE__ */ new Date(),\r\n                data: handle_payload(\r\n                  data2.data,\r\n                  dependency,\r\n                  config.components,\r\n                  \"output\",\r\n                  options.with_null_state\r\n                ),\r\n                endpoint: _endpoint,\r\n                fn_index,\r\n                event_data,\r\n                trigger_id\r\n              });\r\n              if (complete) {\r\n                fire_event({\r\n                  type: \"status\",\r\n                  time: /* @__PURE__ */ new Date(),\r\n                  ...complete,\r\n                  stage: status == null ? void 0 : status.stage,\r\n                  queue: true,\r\n                  endpoint: _endpoint,\r\n                  fn_index\r\n                });\r\n                websocket.close();\r\n              }\r\n            }\r\n          };\r\n          if (semiver(config.version || \"2.0.0\", \"3.6\") < 0) {\r\n            addEventListener(\r\n              \"open\",\r\n              () => websocket.send(JSON.stringify({ hash: session_hash }))\r\n            );\r\n          }\r\n        } else if (protocol == \"sse\") {\r\n          fire_event({\r\n            type: \"status\",\r\n            stage: \"pending\",\r\n            queue: true,\r\n            endpoint: _endpoint,\r\n            fn_index,\r\n            time: /* @__PURE__ */ new Date()\r\n          });\r\n          var params = new URLSearchParams({\r\n            fn_index: fn_index.toString(),\r\n            session_hash\r\n          }).toString();\r\n          let url = new URL(\r\n            `${config.root}${api_prefix}/${SSE_URL}?${url_params ? url_params + \"&\" : \"\"}${params}`\r\n          );\r\n          if (this.jwt) {\r\n            url.searchParams.set(\"__sign\", this.jwt);\r\n          }\r\n          stream2 = this.stream(url);\r\n          if (!stream2) {\r\n            return Promise.reject(\r\n              new Error(\"Cannot connect to SSE endpoint: \" + url.toString())\r\n            );\r\n          }\r\n          stream2.onmessage = async function(event) {\r\n            const _data = JSON.parse(event.data);\r\n            const { type, status, data: data2 } = handle_message(\r\n              _data,\r\n              last_status[fn_index]\r\n            );\r\n            if (type === \"update\" && status && !complete) {\r\n              fire_event({\r\n                type: \"status\",\r\n                endpoint: _endpoint,\r\n                fn_index,\r\n                time: /* @__PURE__ */ new Date(),\r\n                ...status\r\n              });\r\n              if (status.stage === \"error\") {\r\n                stream2 == null ? void 0 : stream2.close();\r\n                close();\r\n              }\r\n            } else if (type === \"data\") {\r\n              let [_, status2] = await post_data2(\r\n                `${config.root}${api_prefix}/queue/data`,\r\n                {\r\n                  ...payload,\r\n                  session_hash,\r\n                  event_id\r\n                }\r\n              );\r\n              if (status2 !== 200) {\r\n                fire_event({\r\n                  type: \"status\",\r\n                  stage: \"error\",\r\n                  message: BROKEN_CONNECTION_MSG,\r\n                  queue: true,\r\n                  endpoint: _endpoint,\r\n                  fn_index,\r\n                  time: /* @__PURE__ */ new Date()\r\n                });\r\n                stream2 == null ? void 0 : stream2.close();\r\n                close();\r\n              }\r\n            } else if (type === \"complete\") {\r\n              complete = status;\r\n            } else if (type === \"log\") {\r\n              fire_event({\r\n                type: \"log\",\r\n                log: data2.log,\r\n                level: data2.level,\r\n                endpoint: _endpoint,\r\n                duration: data2.duration,\r\n                visible: data2.visible,\r\n                fn_index\r\n              });\r\n            } else if (type === \"generating\" || type === \"streaming\") {\r\n              fire_event({\r\n                type: \"status\",\r\n                time: /* @__PURE__ */ new Date(),\r\n                ...status,\r\n                stage: status == null ? void 0 : status.stage,\r\n                queue: true,\r\n                endpoint: _endpoint,\r\n                fn_index\r\n              });\r\n            }\r\n            if (data2) {\r\n              fire_event({\r\n                type: \"data\",\r\n                time: /* @__PURE__ */ new Date(),\r\n                data: handle_payload(\r\n                  data2.data,\r\n                  dependency,\r\n                  config.components,\r\n                  \"output\",\r\n                  options.with_null_state\r\n                ),\r\n                endpoint: _endpoint,\r\n                fn_index,\r\n                event_data,\r\n                trigger_id\r\n              });\r\n              if (complete) {\r\n                fire_event({\r\n                  type: \"status\",\r\n                  time: /* @__PURE__ */ new Date(),\r\n                  ...complete,\r\n                  stage: status == null ? void 0 : status.stage,\r\n                  queue: true,\r\n                  endpoint: _endpoint,\r\n                  fn_index\r\n                });\r\n                stream2 == null ? void 0 : stream2.close();\r\n                close();\r\n              }\r\n            }\r\n          };\r\n        } else if (protocol == \"sse_v1\" || protocol == \"sse_v2\" || protocol == \"sse_v2.1\" || protocol == \"sse_v3\") {\r\n          fire_event({\r\n            type: \"status\",\r\n            stage: \"pending\",\r\n            queue: true,\r\n            endpoint: _endpoint,\r\n            fn_index,\r\n            time: /* @__PURE__ */ new Date()\r\n          });\r\n          let hostname = \"\";\r\n          if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\r\n            hostname = (_a2 = window == null ? void 0 : window.location) == null ? void 0 : _a2.hostname;\r\n          }\r\n          let hfhubdev = \"dev.spaces.huggingface.tech\";\r\n          const origin = hostname.includes(\".dev.\") ? `https://moon-${hostname.split(\".\")[1]}.${hfhubdev}` : `https://huggingface.co`;\r\n          const is_iframe = typeof window !== \"undefined\" && typeof document !== \"undefined\" && window.parent != window;\r\n          const is_zerogpu_space = dependency.zerogpu && config.space_id;\r\n          const zerogpu_auth_promise = is_iframe && is_zerogpu_space ? post_message(\"zerogpu-headers\", origin) : Promise.resolve(null);\r\n          const post_data_promise = zerogpu_auth_promise.then((headers) => {\r\n            return post_data2(\r\n              `${config.root}${api_prefix}/${SSE_DATA_URL}?${url_params}`,\r\n              {\r\n                ...payload,\r\n                session_hash\r\n              },\r\n              headers\r\n            );\r\n          });\r\n          post_data_promise.then(async ([response, status]) => {\r\n            if (status === 503) {\r\n              fire_event({\r\n                type: \"status\",\r\n                stage: \"error\",\r\n                message: QUEUE_FULL_MSG,\r\n                queue: true,\r\n                endpoint: _endpoint,\r\n                fn_index,\r\n                time: /* @__PURE__ */ new Date()\r\n              });\r\n            } else if (status !== 200) {\r\n              fire_event({\r\n                type: \"status\",\r\n                stage: \"error\",\r\n                message: BROKEN_CONNECTION_MSG,\r\n                queue: true,\r\n                endpoint: _endpoint,\r\n                fn_index,\r\n                time: /* @__PURE__ */ new Date()\r\n              });\r\n            } else {\r\n              event_id = response.event_id;\r\n              event_id_final = event_id;\r\n              let callback = async function(_data) {\r\n                try {\r\n                  const { type, status: status2, data: data2, original_msg } = handle_message(\r\n                    _data,\r\n                    last_status[fn_index]\r\n                  );\r\n                  if (type == \"heartbeat\") {\r\n                    return;\r\n                  }\r\n                  if (type === \"update\" && status2 && !complete) {\r\n                    fire_event({\r\n                      type: \"status\",\r\n                      endpoint: _endpoint,\r\n                      fn_index,\r\n                      time: /* @__PURE__ */ new Date(),\r\n                      original_msg,\r\n                      ...status2\r\n                    });\r\n                  } else if (type === \"complete\") {\r\n                    complete = status2;\r\n                  } else if (type == \"unexpected_error\") {\r\n                    console.error(\"Unexpected error\", status2 == null ? void 0 : status2.message);\r\n                    fire_event({\r\n                      type: \"status\",\r\n                      stage: \"error\",\r\n                      message: (status2 == null ? void 0 : status2.message) || \"An Unexpected Error Occurred!\",\r\n                      queue: true,\r\n                      endpoint: _endpoint,\r\n                      fn_index,\r\n                      time: /* @__PURE__ */ new Date()\r\n                    });\r\n                  } else if (type === \"log\") {\r\n                    fire_event({\r\n                      type: \"log\",\r\n                      log: data2.log,\r\n                      level: data2.level,\r\n                      endpoint: _endpoint,\r\n                      duration: data2.duration,\r\n                      visible: data2.visible,\r\n                      fn_index\r\n                    });\r\n                    return;\r\n                  } else if (type === \"generating\" || type === \"streaming\") {\r\n                    fire_event({\r\n                      type: \"status\",\r\n                      time: /* @__PURE__ */ new Date(),\r\n                      ...status2,\r\n                      stage: status2 == null ? void 0 : status2.stage,\r\n                      queue: true,\r\n                      endpoint: _endpoint,\r\n                      fn_index\r\n                    });\r\n                    if (data2 && dependency.connection !== \"stream\" && [\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\r\n                      apply_diff_stream(pending_diff_streams, event_id, data2);\r\n                    }\r\n                  }\r\n                  if (data2) {\r\n                    fire_event({\r\n                      type: \"data\",\r\n                      time: /* @__PURE__ */ new Date(),\r\n                      data: handle_payload(\r\n                        data2.data,\r\n                        dependency,\r\n                        config.components,\r\n                        \"output\",\r\n                        options.with_null_state\r\n                      ),\r\n                      endpoint: _endpoint,\r\n                      fn_index\r\n                    });\r\n                    if (data2.render_config) {\r\n                      await handle_render_config(data2.render_config);\r\n                    }\r\n                    if (complete) {\r\n                      fire_event({\r\n                        type: \"status\",\r\n                        time: /* @__PURE__ */ new Date(),\r\n                        ...complete,\r\n                        stage: status2 == null ? void 0 : status2.stage,\r\n                        queue: true,\r\n                        endpoint: _endpoint,\r\n                        fn_index\r\n                      });\r\n                      close();\r\n                    }\r\n                  }\r\n                  if ((status2 == null ? void 0 : status2.stage) === \"complete\" || (status2 == null ? void 0 : status2.stage) === \"error\") {\r\n                    if (event_callbacks[event_id]) {\r\n                      delete event_callbacks[event_id];\r\n                    }\r\n                    if (event_id in pending_diff_streams) {\r\n                      delete pending_diff_streams[event_id];\r\n                    }\r\n                  }\r\n                } catch (e) {\r\n                  console.error(\"Unexpected client exception\", e);\r\n                  fire_event({\r\n                    type: \"status\",\r\n                    stage: \"error\",\r\n                    message: \"An Unexpected Error Occurred!\",\r\n                    queue: true,\r\n                    endpoint: _endpoint,\r\n                    fn_index,\r\n                    time: /* @__PURE__ */ new Date()\r\n                  });\r\n                  if ([\"sse_v2\", \"sse_v2.1\", \"sse_v3\"].includes(protocol)) {\r\n                    close_stream(stream_status, that.abort_controller);\r\n                    stream_status.open = false;\r\n                    close();\r\n                  }\r\n                }\r\n              };\r\n              if (event_id in pending_stream_messages) {\r\n                pending_stream_messages[event_id].forEach(\r\n                  (msg) => callback(msg)\r\n                );\r\n                delete pending_stream_messages[event_id];\r\n              }\r\n              event_callbacks[event_id] = callback;\r\n              unclosed_events.add(event_id);\r\n              if (!stream_status.open) {\r\n                await this.open_stream();\r\n              }\r\n            }\r\n          });\r\n        }\r\n      }\r\n    );\r\n    let done = false;\r\n    const values = [];\r\n    const resolvers = [];\r\n    const iterator = {\r\n      [Symbol.asyncIterator]: () => iterator,\r\n      next,\r\n      throw: async (value) => {\r\n        push_error(value);\r\n        return next();\r\n      },\r\n      return: async () => {\r\n        close();\r\n        return next();\r\n      },\r\n      cancel,\r\n      event_id: event_id_cb\r\n    };\r\n    return iterator;\r\n  } catch (error) {\r\n    console.error(\"Submit function encountered an error:\", error);\r\n    throw error;\r\n  }\r\n}\r\nfunction thenable_reject(error) {\r\n  return {\r\n    then: (resolve, reject) => reject(error)\r\n  };\r\n}\r\nfunction get_endpoint_info(api_info, endpoint, api_map, config) {\r\n  let fn_index;\r\n  let endpoint_info;\r\n  let dependency;\r\n  if (typeof endpoint === \"number\") {\r\n    fn_index = endpoint;\r\n    endpoint_info = api_info.unnamed_endpoints[fn_index];\r\n    dependency = config.dependencies.find((dep) => dep.id == endpoint);\r\n  } else {\r\n    const trimmed_endpoint = endpoint.replace(/^\\//, \"\");\r\n    fn_index = api_map[trimmed_endpoint];\r\n    endpoint_info = api_info.named_endpoints[endpoint.trim()];\r\n    dependency = config.dependencies.find(\r\n      (dep) => dep.id == api_map[trimmed_endpoint]\r\n    );\r\n  }\r\n  if (typeof fn_index !== \"number\") {\r\n    throw new Error(\r\n      \"There is no endpoint matching that name of fn_index matching that number.\"\r\n    );\r\n  }\r\n  return { fn_index, endpoint_info, dependency };\r\n}\r\nclass Client {\r\n  constructor(app_reference, options = { events: [\"data\"] }) {\r\n    __publicField(this, \"app_reference\");\r\n    __publicField(this, \"options\");\r\n    __publicField(this, \"config\");\r\n    __publicField(this, \"api_prefix\", \"\");\r\n    __publicField(this, \"api_info\");\r\n    __publicField(this, \"api_map\", {});\r\n    __publicField(this, \"session_hash\", Math.random().toString(36).substring(2));\r\n    __publicField(this, \"jwt\", false);\r\n    __publicField(this, \"last_status\", {});\r\n    __publicField(this, \"cookies\", null);\r\n    // streaming\r\n    __publicField(this, \"stream_status\", { open: false });\r\n    __publicField(this, \"pending_stream_messages\", {});\r\n    __publicField(this, \"pending_diff_streams\", {});\r\n    __publicField(this, \"event_callbacks\", {});\r\n    __publicField(this, \"unclosed_events\", /* @__PURE__ */ new Set());\r\n    __publicField(this, \"heartbeat_event\", null);\r\n    __publicField(this, \"abort_controller\", null);\r\n    __publicField(this, \"stream_instance\", null);\r\n    __publicField(this, \"current_payload\");\r\n    __publicField(this, \"view_api\");\r\n    __publicField(this, \"upload_files\");\r\n    __publicField(this, \"upload\");\r\n    __publicField(this, \"handle_blob\");\r\n    __publicField(this, \"post_data\");\r\n    __publicField(this, \"submit\");\r\n    __publicField(this, \"predict\");\r\n    __publicField(this, \"open_stream\");\r\n    __publicField(this, \"resolve_config\");\r\n    __publicField(this, \"resolve_cookies\");\r\n    this.app_reference = app_reference;\r\n    if (!options.events) {\r\n      options.events = [\"data\"];\r\n    }\r\n    this.options = options;\r\n    this.current_payload = {};\r\n    this.view_api = view_api.bind(this);\r\n    this.upload_files = upload_files.bind(this);\r\n    this.handle_blob = handle_blob.bind(this);\r\n    this.post_data = post_data.bind(this);\r\n    this.submit = submit.bind(this);\r\n    this.predict = predict.bind(this);\r\n    this.open_stream = open_stream.bind(this);\r\n    this.resolve_config = resolve_config.bind(this);\r\n    this.resolve_cookies = resolve_cookies.bind(this);\r\n    this.upload = upload.bind(this);\r\n    this.fetch = this.fetch.bind(this);\r\n    this.handle_space_success = this.handle_space_success.bind(this);\r\n    this.stream = this.stream.bind(this);\r\n  }\r\n  fetch(input, init) {\r\n    const headers = new Headers((init == null ? void 0 : init.headers) || {});\r\n    if (this && this.cookies) {\r\n      headers.append(\"Cookie\", this.cookies);\r\n    }\r\n    return fetch(input, { ...init, headers });\r\n  }\r\n  stream(url) {\r\n    const headers = new Headers();\r\n    if (this && this.cookies) {\r\n      headers.append(\"Cookie\", this.cookies);\r\n    }\r\n    this.abort_controller = new AbortController();\r\n    this.stream_instance = readable_stream(url.toString(), {\r\n      credentials: \"include\",\r\n      headers,\r\n      signal: this.abort_controller.signal\r\n    });\r\n    return this.stream_instance;\r\n  }\r\n  async init() {\r\n    var _a;\r\n    if ((typeof window === \"undefined\" || !(\"WebSocket\" in window)) && !global.WebSocket) {\r\n      const ws = await import(\"./wrapper-CviSselG.js\");\r\n      global.WebSocket = ws.WebSocket;\r\n    }\r\n    if (this.options.auth) {\r\n      await this.resolve_cookies();\r\n    }\r\n    await this._resolve_config().then(\r\n      ({ config }) => this._resolve_hearbeat(config)\r\n    );\r\n    this.api_info = await this.view_api();\r\n    this.api_map = map_names_to_ids(((_a = this.config) == null ? void 0 : _a.dependencies) || []);\r\n  }\r\n  async _resolve_hearbeat(_config) {\r\n    if (_config) {\r\n      this.config = _config;\r\n      this.api_prefix = _config.api_prefix || \"\";\r\n      if (this.config && this.config.connect_heartbeat) {\r\n        if (this.config.space_id && this.options.hf_token) {\r\n          this.jwt = await get_jwt(\r\n            this.config.space_id,\r\n            this.options.hf_token,\r\n            this.cookies\r\n          );\r\n        }\r\n      }\r\n    }\r\n    if (_config.space_id && this.options.hf_token) {\r\n      this.jwt = await get_jwt(_config.space_id, this.options.hf_token);\r\n    }\r\n    if (this.config && this.config.connect_heartbeat) {\r\n      const heartbeat_url = new URL(\r\n        `${this.config.root}${this.api_prefix}/${HEARTBEAT_URL}/${this.session_hash}`\r\n      );\r\n      if (this.jwt) {\r\n        heartbeat_url.searchParams.set(\"__sign\", this.jwt);\r\n      }\r\n      if (!this.heartbeat_event) {\r\n        this.heartbeat_event = this.stream(heartbeat_url);\r\n      }\r\n    }\r\n  }\r\n  static async connect(app_reference, options = {\r\n    events: [\"data\"]\r\n  }) {\r\n    const client2 = new this(app_reference, options);\r\n    await client2.init();\r\n    return client2;\r\n  }\r\n  close() {\r\n    close_stream(this.stream_status, this.abort_controller);\r\n  }\r\n  set_current_payload(payload) {\r\n    this.current_payload = payload;\r\n  }\r\n  static async duplicate(app_reference, options = {\r\n    events: [\"data\"]\r\n  }) {\r\n    return duplicate(app_reference, options);\r\n  }\r\n  async _resolve_config() {\r\n    const { http_protocol, host, space_id } = await process_endpoint(\r\n      this.app_reference,\r\n      this.options.hf_token\r\n    );\r\n    const { status_callback } = this.options;\r\n    if (space_id && status_callback) {\r\n      await check_and_wake_space(space_id, status_callback);\r\n    }\r\n    let config;\r\n    try {\r\n      config = await this.resolve_config(`${http_protocol}//${host}`);\r\n      if (!config) {\r\n        throw new Error(CONFIG_ERROR_MSG);\r\n      }\r\n      return this.config_success(config);\r\n    } catch (e) {\r\n      if (space_id && status_callback) {\r\n        check_space_status(\r\n          space_id,\r\n          RE_SPACE_NAME.test(space_id) ? \"space_name\" : \"subdomain\",\r\n          this.handle_space_success\r\n        );\r\n      } else {\r\n        if (status_callback)\r\n          status_callback({\r\n            status: \"error\",\r\n            message: \"Could not load this space.\",\r\n            load_status: \"error\",\r\n            detail: \"NOT_FOUND\"\r\n          });\r\n        throw Error(e);\r\n      }\r\n    }\r\n  }\r\n  async config_success(_config) {\r\n    this.config = _config;\r\n    this.api_prefix = _config.api_prefix || \"\";\r\n    if (typeof window !== \"undefined\" && typeof document !== \"undefined\") {\r\n      if (window.location.protocol === \"https:\") {\r\n        this.config.root = this.config.root.replace(\"http://\", \"https://\");\r\n      }\r\n    }\r\n    if (this.config.auth_required) {\r\n      return this.prepare_return_obj();\r\n    }\r\n    try {\r\n      this.api_info = await this.view_api();\r\n    } catch (e) {\r\n      console.error(API_INFO_ERROR_MSG + e.message);\r\n    }\r\n    return this.prepare_return_obj();\r\n  }\r\n  async handle_space_success(status) {\r\n    var _a;\r\n    if (!this) {\r\n      throw new Error(CONFIG_ERROR_MSG);\r\n    }\r\n    const { status_callback } = this.options;\r\n    if (status_callback)\r\n      status_callback(status);\r\n    if (status.status === \"running\") {\r\n      try {\r\n        this.config = await this._resolve_config();\r\n        this.api_prefix = ((_a = this == null ? void 0 : this.config) == null ? void 0 : _a.api_prefix) || \"\";\r\n        if (!this.config) {\r\n          throw new Error(CONFIG_ERROR_MSG);\r\n        }\r\n        const _config = await this.config_success(this.config);\r\n        return _config;\r\n      } catch (e) {\r\n        if (status_callback) {\r\n          status_callback({\r\n            status: \"error\",\r\n            message: \"Could not load this space.\",\r\n            load_status: \"error\",\r\n            detail: \"NOT_FOUND\"\r\n          });\r\n        }\r\n        throw e;\r\n      }\r\n    }\r\n  }\r\n  async component_server(component_id, fn_name, data) {\r\n    var _a;\r\n    if (!this.config) {\r\n      throw new Error(CONFIG_ERROR_MSG);\r\n    }\r\n    const headers = {};\r\n    const { hf_token } = this.options;\r\n    const { session_hash } = this;\r\n    if (hf_token) {\r\n      headers.Authorization = `Bearer ${this.options.hf_token}`;\r\n    }\r\n    let root_url;\r\n    let component = this.config.components.find(\r\n      (comp) => comp.id === component_id\r\n    );\r\n    if ((_a = component == null ? void 0 : component.props) == null ? void 0 : _a.root_url) {\r\n      root_url = component.props.root_url;\r\n    } else {\r\n      root_url = this.config.root;\r\n    }\r\n    let body;\r\n    if (\"binary\" in data) {\r\n      body = new FormData();\r\n      for (const key in data.data) {\r\n        if (key === \"binary\")\r\n          continue;\r\n        body.append(key, data.data[key]);\r\n      }\r\n      body.set(\"component_id\", component_id.toString());\r\n      body.set(\"fn_name\", fn_name);\r\n      body.set(\"session_hash\", session_hash);\r\n    } else {\r\n      body = JSON.stringify({\r\n        data,\r\n        component_id,\r\n        fn_name,\r\n        session_hash\r\n      });\r\n      headers[\"Content-Type\"] = \"application/json\";\r\n    }\r\n    if (hf_token) {\r\n      headers.Authorization = `Bearer ${hf_token}`;\r\n    }\r\n    try {\r\n      const response = await this.fetch(\r\n        `${root_url}${this.api_prefix}/${COMPONENT_SERVER_URL}/`,\r\n        {\r\n          method: \"POST\",\r\n          body,\r\n          headers,\r\n          credentials: \"include\"\r\n        }\r\n      );\r\n      if (!response.ok) {\r\n        throw new Error(\r\n          \"Could not connect to component server: \" + response.statusText\r\n        );\r\n      }\r\n      const output = await response.json();\r\n      return output;\r\n    } catch (e) {\r\n      console.warn(e);\r\n    }\r\n  }\r\n  set_cookies(raw_cookies) {\r\n    this.cookies = parse_and_set_cookies(raw_cookies).join(\"; \");\r\n  }\r\n  prepare_return_obj() {\r\n    return {\r\n      config: this.config,\r\n      predict: this.predict,\r\n      submit: this.submit,\r\n      view_api: this.view_api,\r\n      component_server: this.component_server\r\n    };\r\n  }\r\n}\r\nasync function client(app_reference, options = {\r\n  events: [\"data\"]\r\n}) {\r\n  return await Client.connect(app_reference, options);\r\n}\r\nasync function duplicate_space(app_reference, options) {\r\n  return await Client.duplicate(app_reference, options);\r\n}\r\nexport {\r\n  Client,\r\n  FileData,\r\n  client,\r\n  duplicate_space as duplicate,\r\n  handle_file,\r\n  predict,\r\n  prepare_files,\r\n  submit,\r\n  upload,\r\n  upload_files\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}