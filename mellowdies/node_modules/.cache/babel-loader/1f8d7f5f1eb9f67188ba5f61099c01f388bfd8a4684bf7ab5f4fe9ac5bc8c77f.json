{"ast":null,"code":"/**\r\n * @module  audio-dtype\r\n */\n\n'use strict';\n\nvar AudioBuffer = require('audio-buffer');\nvar isAudioBuffer = require('is-audio-buffer');\nvar isObj = require('is-plain-obj');\nvar getContext = require('audio-context');\nvar convert = require('pcm-convert');\nvar format = require('audio-format');\nvar str2ab = require('string-to-arraybuffer');\nvar pick = require('pick-by-alias');\nmodule.exports = function createBuffer(source, options) {\n  var length, data, channels, sampleRate, format, c, l;\n\n  //src, channels\n  if (typeof options === 'number') {\n    options = {\n      channels: options\n    };\n  } else if (typeof options === 'string') {\n    options = {\n      format: options\n    };\n  }\n  //{}\n  else if (options === undefined) {\n    if (isObj(source)) {\n      options = source;\n      source = undefined;\n    } else {\n      options = {};\n    }\n  }\n  options = pick(options, {\n    format: 'format type dtype dataType',\n    channels: 'channel channels numberOfChannels channelCount',\n    sampleRate: 'sampleRate rate',\n    length: 'length size',\n    duration: 'duration time'\n  });\n\n  //detect options\n  channels = options.channels;\n  sampleRate = options.sampleRate;\n  if (options.format) format = getFormat(options.format);\n  if (format) {\n    if (channels && !format.channels) format.channels = channels;else if (format.channels && !channels) channels = format.channels;\n    if (!sampleRate && format.sampleRate) sampleRate = format.sampleRate;\n  }\n\n  //empty buffer\n  if (source == null) {\n    if (options.duration != null) {\n      if (!sampleRate) sampleRate = 44100;\n      length = sampleRate * options.duration;\n    } else length = options.length;\n  }\n\n  //if audio buffer passed - create fast clone of it\n  else if (isAudioBuffer(source)) {\n    length = source.length;\n    if (channels == null) channels = source.numberOfChannels;\n    if (sampleRate == null) sampleRate = source.sampleRate;\n    if (source._channelData) {\n      data = source._channelData.slice(0, channels);\n    } else {\n      data = [];\n      for (c = 0, l = channels; c < l; c++) {\n        data[c] = source.getChannelData(c);\n      }\n    }\n  }\n\n  //if create(number, channels? rate?) = create new array\n  //this is the default WAA-compatible case\n  else if (typeof source === 'number') {\n    length = source;\n  }\n\n  //if array with channels - parse channeled data\n  else if (Array.isArray(source) && (Array.isArray(source[0]) || ArrayBuffer.isView(source[0]))) {\n    length = source[0].length;\n    data = [];\n    if (!channels) channels = source.length;\n    for (c = 0; c < channels; c++) {\n      data[c] = source[c] instanceof Float32Array ? source[c] : new Float32Array(source[c]);\n    }\n  }\n\n  //if ndarray, ndsamples, or anything with data\n  else if (source.shape && source.data) {\n    if (source.shape) channels = source.shape[1];\n    if (!sampleRate && source.format) sampleRate = source.format.sampleRate;\n    return createBuffer(source.data, {\n      channels: channels,\n      sampleRate: sampleRate\n    });\n  }\n\n  //TypedArray, Buffer, DataView etc, ArrayBuffer, Array etc.\n  //NOTE: node 4.x+ detects Buffer as ArrayBuffer view\n  else {\n    if (typeof source === 'string') {\n      source = str2ab(source);\n    }\n    if (!format) format = getFormat(source);\n    if (!channels) channels = format.channels || 1;\n    source = convert(source, format, 'float32 planar');\n    length = Math.floor(source.length / channels);\n    data = [];\n    for (c = 0; c < channels; c++) {\n      data[c] = source.subarray(c * length, (c + 1) * length);\n    }\n  }\n\n  //create buffer of proper length\n  var audioBuffer = new AudioBuffer(options.context === null || length === 0 ? null : options.context || getContext(), {\n    length: length == null ? 1 : length,\n    numberOfChannels: channels || 1,\n    sampleRate: sampleRate || 44100\n  });\n\n  //fill channels\n  if (data) {\n    for (c = 0, l = data.length; c < l; c++) {\n      audioBuffer.getChannelData(c).set(data[c]);\n    }\n  }\n  return audioBuffer;\n};\nfunction getFormat(arg) {\n  return typeof arg === 'string' ? format.parse(arg) : format.detect(arg);\n}","map":{"version":3,"names":["AudioBuffer","require","isAudioBuffer","isObj","getContext","convert","format","str2ab","pick","module","exports","createBuffer","source","options","length","data","channels","sampleRate","c","l","undefined","duration","getFormat","numberOfChannels","_channelData","slice","getChannelData","Array","isArray","ArrayBuffer","isView","Float32Array","shape","Math","floor","subarray","audioBuffer","context","set","arg","parse","detect"],"sources":["C:/Users/User/Desktop/Mellowdies/mellowdies/node_modules/audio-buffer-from/index.js"],"sourcesContent":["/**\r\n * @module  audio-dtype\r\n */\r\n\r\n'use strict'\r\n\r\nvar AudioBuffer = require('audio-buffer')\r\nvar isAudioBuffer = require('is-audio-buffer')\r\nvar isObj = require('is-plain-obj')\r\nvar getContext = require('audio-context')\r\nvar convert = require('pcm-convert')\r\nvar format = require('audio-format')\r\nvar str2ab = require('string-to-arraybuffer')\r\nvar pick = require('pick-by-alias')\r\n\r\nmodule.exports = function createBuffer (source, options) {\r\n\tvar length, data, channels, sampleRate, format, c, l\r\n\r\n\t//src, channels\r\n\tif (typeof options === 'number') {\r\n\t\toptions = {channels: options}\r\n\t}\r\n\telse if (typeof options === 'string') {\r\n\t\toptions = {format: options}\r\n\t}\r\n\t//{}\r\n\telse if (options === undefined) {\r\n\t\tif (isObj(source)) {\r\n\t\t\toptions = source\r\n\t\t\tsource = undefined\r\n\t\t}\r\n\t\telse {\r\n\t\t\toptions = {}\r\n\t\t}\r\n\t}\r\n\r\n\toptions = pick(options, {\r\n\t\tformat: 'format type dtype dataType',\r\n\t\tchannels: 'channel channels numberOfChannels channelCount',\r\n\t\tsampleRate: 'sampleRate rate',\r\n\t\tlength: 'length size',\r\n\t\tduration: 'duration time'\r\n\t})\r\n\r\n\t//detect options\r\n\tchannels = options.channels\r\n\tsampleRate = options.sampleRate\r\n\tif (options.format) format = getFormat(options.format)\r\n\r\n\tif (format) {\r\n\t\tif (channels && !format.channels) format.channels = channels\r\n\t\telse if (format.channels && !channels) channels = format.channels\r\n\t\tif (!sampleRate && format.sampleRate) sampleRate = format.sampleRate\r\n\t}\r\n\r\n\t//empty buffer\r\n\tif (source == null) {\r\n\t\tif (options.duration != null) {\r\n\t\t\tif (!sampleRate) sampleRate = 44100\r\n\t\t\tlength = sampleRate * options.duration\r\n\t\t}\r\n\t\telse length = options.length\r\n\t}\r\n\r\n\t//if audio buffer passed - create fast clone of it\r\n\telse if (isAudioBuffer(source)) {\r\n\t\tlength = source.length\r\n\t\tif (channels == null) channels = source.numberOfChannels\r\n\t\tif (sampleRate == null) sampleRate = source.sampleRate\r\n\r\n\t\tif (source._channelData) {\r\n\t\t\tdata = source._channelData.slice(0, channels)\r\n\t\t}\r\n\t\telse {\r\n\t\t\tdata = []\r\n\r\n\t\t\tfor (c = 0, l = channels; c < l; c++) {\r\n\t\t\t\tdata[c] = source.getChannelData(c)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t//if create(number, channels? rate?) = create new array\r\n\t//this is the default WAA-compatible case\r\n\telse if (typeof source === 'number') {\r\n\t\tlength = source\r\n\t}\r\n\r\n\t//if array with channels - parse channeled data\r\n\telse if (Array.isArray(source) && (Array.isArray(source[0]) || ArrayBuffer.isView(source[0]))) {\r\n\t\tlength = source[0].length;\r\n\t\tdata = []\r\n\t\tif (!channels) channels = source.length\r\n\t\tfor (c = 0; c < channels; c++) {\r\n\t\t\tdata[c] = source[c] instanceof Float32Array ? source[c] : new Float32Array(source[c])\r\n\t\t}\r\n\t}\r\n\r\n\t//if ndarray, ndsamples, or anything with data\r\n\telse if (source.shape && source.data) {\r\n\t\tif (source.shape) channels = source.shape[1]\r\n\t\tif (!sampleRate && source.format) sampleRate = source.format.sampleRate\r\n\r\n\t\treturn createBuffer(source.data, {\r\n\t\t\tchannels: channels,\r\n\t\t\tsampleRate: sampleRate\r\n\t\t})\r\n\t}\r\n\r\n\t//TypedArray, Buffer, DataView etc, ArrayBuffer, Array etc.\r\n\t//NOTE: node 4.x+ detects Buffer as ArrayBuffer view\r\n\telse {\r\n\t\tif (typeof source === 'string') {\r\n\t\t\tsource = str2ab(source)\r\n\t\t}\r\n\r\n\t\tif (!format) format = getFormat(source)\r\n\t\tif (!channels) channels = format.channels || 1\r\n\t\tsource = convert(source, format, 'float32 planar')\r\n\r\n\t\tlength = Math.floor(source.length / channels);\r\n\t\tdata = []\r\n\t\tfor (c = 0; c < channels; c++) {\r\n\t\t\tdata[c] = source.subarray(c * length, (c + 1) * length);\r\n\t\t}\r\n\t}\r\n\r\n\t//create buffer of proper length\r\n\tvar audioBuffer = new AudioBuffer((options.context === null || length === 0) ? null : options.context || getContext(), {\r\n\t\tlength: length == null ? 1 : length,\r\n\t\tnumberOfChannels: channels || 1,\r\n\t\tsampleRate: sampleRate || 44100\r\n\t})\r\n\r\n\t//fill channels\r\n\tif (data) {\r\n\t\tfor (c = 0, l = data.length; c < l; c++) {\r\n\t\t\taudioBuffer.getChannelData(c).set(data[c]);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\treturn audioBuffer\r\n}\r\n\r\n\r\nfunction getFormat (arg) {\r\n\treturn typeof arg === 'string' ? format.parse(arg) : format.detect(arg)\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}