{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * @typedef {object} CssTokenCallbacks\n * @property {function(string, number): boolean=} isSelector\n * @property {function(string, number, number, number, number): number=} url\n * @property {function(string, number, number): number=} string\n * @property {function(string, number, number): number=} leftParenthesis\n * @property {function(string, number, number): number=} rightParenthesis\n * @property {function(string, number, number): number=} pseudoFunction\n * @property {function(string, number, number): number=} function\n * @property {function(string, number, number): number=} pseudoClass\n * @property {function(string, number, number): number=} atKeyword\n * @property {function(string, number, number): number=} class\n * @property {function(string, number, number): number=} identifier\n * @property {function(string, number, number): number=} id\n * @property {function(string, number, number): number=} leftCurlyBracket\n * @property {function(string, number, number): number=} rightCurlyBracket\n * @property {function(string, number, number): number=} semicolon\n * @property {function(string, number, number): number=} comma\n */\n\n/** @typedef {function(string, number, CssTokenCallbacks): number} CharHandler */\n\n// spec: https://drafts.csswg.org/css-syntax/\nconst CC_LINE_FEED = \"\\n\".charCodeAt(0);\nconst CC_CARRIAGE_RETURN = \"\\r\".charCodeAt(0);\nconst CC_FORM_FEED = \"\\f\".charCodeAt(0);\nconst CC_TAB = \"\\t\".charCodeAt(0);\nconst CC_SPACE = \" \".charCodeAt(0);\nconst CC_SOLIDUS = \"/\".charCodeAt(0);\nconst CC_REVERSE_SOLIDUS = \"\\\\\".charCodeAt(0);\nconst CC_ASTERISK = \"*\".charCodeAt(0);\nconst CC_LEFT_PARENTHESIS = \"(\".charCodeAt(0);\nconst CC_RIGHT_PARENTHESIS = \")\".charCodeAt(0);\nconst CC_LEFT_CURLY = \"{\".charCodeAt(0);\nconst CC_RIGHT_CURLY = \"}\".charCodeAt(0);\nconst CC_LEFT_SQUARE = \"[\".charCodeAt(0);\nconst CC_RIGHT_SQUARE = \"]\".charCodeAt(0);\nconst CC_QUOTATION_MARK = '\"'.charCodeAt(0);\nconst CC_APOSTROPHE = \"'\".charCodeAt(0);\nconst CC_FULL_STOP = \".\".charCodeAt(0);\nconst CC_COLON = \":\".charCodeAt(0);\nconst CC_SEMICOLON = \";\".charCodeAt(0);\nconst CC_COMMA = \",\".charCodeAt(0);\nconst CC_PERCENTAGE = \"%\".charCodeAt(0);\nconst CC_AT_SIGN = \"@\".charCodeAt(0);\nconst CC_LOW_LINE = \"_\".charCodeAt(0);\nconst CC_LOWER_A = \"a\".charCodeAt(0);\nconst CC_LOWER_U = \"u\".charCodeAt(0);\nconst CC_LOWER_E = \"e\".charCodeAt(0);\nconst CC_LOWER_Z = \"z\".charCodeAt(0);\nconst CC_UPPER_A = \"A\".charCodeAt(0);\nconst CC_UPPER_E = \"E\".charCodeAt(0);\nconst CC_UPPER_U = \"U\".charCodeAt(0);\nconst CC_UPPER_Z = \"Z\".charCodeAt(0);\nconst CC_0 = \"0\".charCodeAt(0);\nconst CC_9 = \"9\".charCodeAt(0);\nconst CC_NUMBER_SIGN = \"#\".charCodeAt(0);\nconst CC_PLUS_SIGN = \"+\".charCodeAt(0);\nconst CC_HYPHEN_MINUS = \"-\".charCodeAt(0);\nconst CC_LESS_THAN_SIGN = \"<\".charCodeAt(0);\nconst CC_GREATER_THAN_SIGN = \">\".charCodeAt(0);\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a newline\n */\nconst _isNewLine = cc => cc === CC_LINE_FEED || cc === CC_CARRIAGE_RETURN || cc === CC_FORM_FEED;\n\n/** @type {CharHandler} */\nconst consumeSpace = (input, pos, _callbacks) => {\n  /** @type {number} */\n  let cc;\n  do {\n    pos++;\n    cc = input.charCodeAt(pos);\n  } while (_isWhiteSpace(cc));\n  return pos;\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a newline\n */\nconst _isNewline = cc => cc === CC_LINE_FEED || cc === CC_CARRIAGE_RETURN || cc === CC_FORM_FEED;\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a space (U+0009 CHARACTER TABULATION or U+0020 SPACE)\n */\nconst _isSpace = cc => cc === CC_TAB || cc === CC_SPACE;\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a whitespace\n */\nconst _isWhiteSpace = cc => _isNewline(cc) || _isSpace(cc);\n\n/**\n * ident-start code point\n *\n * A letter, a non-ASCII code point, or U+005F LOW LINE (_).\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a start code point of an identifier\n */\nconst isIdentStartCodePoint = cc => cc >= CC_LOWER_A && cc <= CC_LOWER_Z || cc >= CC_UPPER_A && cc <= CC_UPPER_Z || cc === CC_LOW_LINE || cc >= 0x80;\n\n/** @type {CharHandler} */\nconst consumeDelimToken = (input, pos, _callbacks) => pos + 1;\n\n/** @type {CharHandler} */\nconst consumeComments = (input, pos, _callbacks) => {\n  // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A\n  // ASTERISK (*), consume them and all following code points up to and including\n  // the first U+002A ASTERISK (*) followed by a U+002F SOLIDUS (/), or up to an\n  // EOF code point. Return to the start of this step.\n  //\n  // If the preceding paragraph ended by consuming an EOF code point, this is a parse error.\n  // But we are silent on errors.\n  if (input.charCodeAt(pos) === CC_SOLIDUS && input.charCodeAt(pos + 1) === CC_ASTERISK) {\n    pos += 1;\n    while (pos < input.length) {\n      if (input.charCodeAt(pos) === CC_ASTERISK && input.charCodeAt(pos + 1) === CC_SOLIDUS) {\n        pos += 2;\n        break;\n      }\n      pos++;\n    }\n  }\n  return pos;\n};\n\n/** @type {function(number): CharHandler} */\nconst consumeString = quoteCc => (input, pos, callbacks) => {\n  const start = pos;\n  pos = _consumeString(input, pos, quoteCc);\n  if (callbacks.string !== undefined) {\n    pos = callbacks.string(input, start, pos);\n  }\n  return pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {number} quoteCc quote char code\n * @returns {number} new position\n */\nconst _consumeString = (input, pos, quoteCc) => {\n  pos++;\n  for (;;) {\n    if (pos === input.length) return pos;\n    const cc = input.charCodeAt(pos);\n    if (cc === quoteCc) return pos + 1;\n    if (_isNewLine(cc)) {\n      // bad string\n      return pos;\n    }\n    if (cc === CC_REVERSE_SOLIDUS) {\n      // we don't need to fully parse the escaped code point\n      // just skip over a potential new line\n      pos++;\n      if (pos === input.length) return pos;\n      pos++;\n    } else {\n      pos++;\n    }\n  }\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} is identifier start code\n */\nconst _isIdentifierStartCode = cc => cc === CC_LOW_LINE || cc >= CC_LOWER_A && cc <= CC_LOWER_Z || cc >= CC_UPPER_A && cc <= CC_UPPER_Z || cc > 0x80;\n\n/**\n * @param {number} first first code point\n * @param {number} second second code point\n * @returns {boolean} true if two code points are a valid escape\n */\nconst _isTwoCodePointsAreValidEscape = (first, second) => {\n  if (first !== CC_REVERSE_SOLIDUS) return false;\n  if (_isNewLine(second)) return false;\n  return true;\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} is digit\n */\nconst _isDigit = cc => cc >= CC_0 && cc <= CC_9;\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {boolean} true, if input at pos starts an identifier\n */\nconst _startsIdentifier = (input, pos) => {\n  const cc = input.charCodeAt(pos);\n  if (cc === CC_HYPHEN_MINUS) {\n    if (pos === input.length) return false;\n    const cc = input.charCodeAt(pos + 1);\n    if (cc === CC_HYPHEN_MINUS) return true;\n    if (cc === CC_REVERSE_SOLIDUS) {\n      const cc = input.charCodeAt(pos + 2);\n      return !_isNewLine(cc);\n    }\n    return _isIdentifierStartCode(cc);\n  }\n  if (cc === CC_REVERSE_SOLIDUS) {\n    const cc = input.charCodeAt(pos + 1);\n    return !_isNewLine(cc);\n  }\n  return _isIdentifierStartCode(cc);\n};\n\n/** @type {CharHandler} */\nconst consumeNumberSign = (input, pos, callbacks) => {\n  const start = pos;\n  pos++;\n  if (pos === input.length) return pos;\n  if (callbacks.isSelector && callbacks.isSelector(input, pos) && _startsIdentifier(input, pos)) {\n    pos = _consumeIdentifier(input, pos, callbacks);\n    if (callbacks.id !== undefined) {\n      return callbacks.id(input, start, pos);\n    }\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeMinus = (input, pos, callbacks) => {\n  const start = pos;\n  pos++;\n  if (pos === input.length) return pos;\n  const cc = input.charCodeAt(pos);\n  // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n  if (cc === CC_FULL_STOP || _isDigit(cc)) {\n    return consumeNumericToken(input, pos, callbacks);\n  } else if (cc === CC_HYPHEN_MINUS) {\n    pos++;\n    if (pos === input.length) return pos;\n    const cc = input.charCodeAt(pos);\n    if (cc === CC_GREATER_THAN_SIGN) {\n      return pos + 1;\n    }\n    pos = _consumeIdentifier(input, pos, callbacks);\n    if (callbacks.identifier !== undefined) {\n      return callbacks.identifier(input, start, pos);\n    }\n  } else if (cc === CC_REVERSE_SOLIDUS) {\n    if (pos + 1 === input.length) return pos;\n    const cc = input.charCodeAt(pos + 1);\n    if (_isNewLine(cc)) return pos;\n    pos = _consumeIdentifier(input, pos, callbacks);\n    if (callbacks.identifier !== undefined) {\n      return callbacks.identifier(input, start, pos);\n    }\n  } else if (_isIdentifierStartCode(cc)) {\n    pos = consumeOtherIdentifier(input, pos - 1, callbacks);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeDot = (input, pos, callbacks) => {\n  const start = pos;\n  pos++;\n  if (pos === input.length) return pos;\n  const cc = input.charCodeAt(pos);\n  if (_isDigit(cc)) return consumeNumericToken(input, pos - 2, callbacks);\n  if (callbacks.isSelector && !callbacks.isSelector(input, pos) || !_startsIdentifier(input, pos)) return pos;\n  pos = _consumeIdentifier(input, pos, callbacks);\n  if (callbacks.class !== undefined) return callbacks.class(input, start, pos);\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeNumericToken = (input, pos, callbacks) => {\n  pos = _consumeNumber(input, pos, callbacks);\n  if (pos === input.length) return pos;\n  if (_startsIdentifier(input, pos)) return _consumeIdentifier(input, pos, callbacks);\n  const cc = input.charCodeAt(pos);\n  if (cc === CC_PERCENTAGE) return pos + 1;\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeOtherIdentifier = (input, pos, callbacks) => {\n  const start = pos;\n  pos = _consumeIdentifier(input, pos, callbacks);\n  if (pos !== input.length && input.charCodeAt(pos) === CC_LEFT_PARENTHESIS) {\n    pos++;\n    if (callbacks.function !== undefined) {\n      return callbacks.function(input, start, pos);\n    }\n  } else if (callbacks.identifier !== undefined) {\n    return callbacks.identifier(input, start, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumePotentialUrl = (input, pos, callbacks) => {\n  const start = pos;\n  pos = _consumeIdentifier(input, pos, callbacks);\n  const nextPos = pos + 1;\n  if (pos === start + 3 && input.slice(start, nextPos).toLowerCase() === \"url(\") {\n    pos++;\n    let cc = input.charCodeAt(pos);\n    while (_isWhiteSpace(cc)) {\n      pos++;\n      if (pos === input.length) return pos;\n      cc = input.charCodeAt(pos);\n    }\n    if (cc === CC_QUOTATION_MARK || cc === CC_APOSTROPHE) {\n      if (callbacks.function !== undefined) {\n        return callbacks.function(input, start, nextPos);\n      }\n      return nextPos;\n    }\n    const contentStart = pos;\n    /** @type {number} */\n    let contentEnd;\n    for (;;) {\n      if (cc === CC_REVERSE_SOLIDUS) {\n        pos++;\n        if (pos === input.length) return pos;\n        pos++;\n      } else if (_isWhiteSpace(cc)) {\n        contentEnd = pos;\n        do {\n          pos++;\n          if (pos === input.length) return pos;\n          cc = input.charCodeAt(pos);\n        } while (_isWhiteSpace(cc));\n        if (cc !== CC_RIGHT_PARENTHESIS) return pos;\n        pos++;\n        if (callbacks.url !== undefined) {\n          return callbacks.url(input, start, pos, contentStart, contentEnd);\n        }\n        return pos;\n      } else if (cc === CC_RIGHT_PARENTHESIS) {\n        contentEnd = pos;\n        pos++;\n        if (callbacks.url !== undefined) {\n          return callbacks.url(input, start, pos, contentStart, contentEnd);\n        }\n        return pos;\n      } else if (cc === CC_LEFT_PARENTHESIS) {\n        return pos;\n      } else {\n        pos++;\n      }\n      if (pos === input.length) return pos;\n      cc = input.charCodeAt(pos);\n    }\n  } else {\n    if (callbacks.identifier !== undefined) {\n      return callbacks.identifier(input, start, pos);\n    }\n    return pos;\n  }\n};\n\n/** @type {CharHandler} */\nconst consumePotentialPseudo = (input, pos, callbacks) => {\n  const start = pos;\n  pos++;\n  if (callbacks.isSelector && !callbacks.isSelector(input, pos) || !_startsIdentifier(input, pos)) return pos;\n  pos = _consumeIdentifier(input, pos, callbacks);\n  const cc = input.charCodeAt(pos);\n  if (cc === CC_LEFT_PARENTHESIS) {\n    pos++;\n    if (callbacks.pseudoFunction !== undefined) {\n      return callbacks.pseudoFunction(input, start, pos);\n    }\n    return pos;\n  }\n  if (callbacks.pseudoClass !== undefined) {\n    return callbacks.pseudoClass(input, start, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeLeftParenthesis = (input, pos, callbacks) => {\n  pos++;\n  if (callbacks.leftParenthesis !== undefined) {\n    return callbacks.leftParenthesis(input, pos - 1, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeRightParenthesis = (input, pos, callbacks) => {\n  pos++;\n  if (callbacks.rightParenthesis !== undefined) {\n    return callbacks.rightParenthesis(input, pos - 1, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeLeftCurlyBracket = (input, pos, callbacks) => {\n  pos++;\n  if (callbacks.leftCurlyBracket !== undefined) {\n    return callbacks.leftCurlyBracket(input, pos - 1, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeRightCurlyBracket = (input, pos, callbacks) => {\n  pos++;\n  if (callbacks.rightCurlyBracket !== undefined) {\n    return callbacks.rightCurlyBracket(input, pos - 1, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeSemicolon = (input, pos, callbacks) => {\n  pos++;\n  if (callbacks.semicolon !== undefined) {\n    return callbacks.semicolon(input, pos - 1, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeComma = (input, pos, callbacks) => {\n  pos++;\n  if (callbacks.comma !== undefined) {\n    return callbacks.comma(input, pos - 1, pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst _consumeIdentifier = (input, pos) => {\n  for (;;) {\n    const cc = input.charCodeAt(pos);\n    if (cc === CC_REVERSE_SOLIDUS) {\n      pos++;\n      if (pos === input.length) return pos;\n      pos++;\n    } else if (_isIdentifierStartCode(cc) || _isDigit(cc) || cc === CC_HYPHEN_MINUS) {\n      pos++;\n    } else {\n      return pos;\n    }\n  }\n};\n\n/** @type {CharHandler} */\nconst _consumeNumber = (input, pos) => {\n  pos++;\n  if (pos === input.length) return pos;\n  let cc = input.charCodeAt(pos);\n  while (_isDigit(cc)) {\n    pos++;\n    if (pos === input.length) return pos;\n    cc = input.charCodeAt(pos);\n  }\n  if (cc === CC_FULL_STOP && pos + 1 !== input.length) {\n    const next = input.charCodeAt(pos + 1);\n    if (_isDigit(next)) {\n      pos += 2;\n      cc = input.charCodeAt(pos);\n      while (_isDigit(cc)) {\n        pos++;\n        if (pos === input.length) return pos;\n        cc = input.charCodeAt(pos);\n      }\n    }\n  }\n  if (cc === CC_LOWER_E || cc === CC_UPPER_E) {\n    if (pos + 1 !== input.length) {\n      const next = input.charCodeAt(pos + 2);\n      if (_isDigit(next)) {\n        pos += 2;\n      } else if ((next === CC_HYPHEN_MINUS || next === CC_PLUS_SIGN) && pos + 2 !== input.length) {\n        const next = input.charCodeAt(pos + 2);\n        if (_isDigit(next)) {\n          pos += 3;\n        } else {\n          return pos;\n        }\n      } else {\n        return pos;\n      }\n    }\n  } else {\n    return pos;\n  }\n  cc = input.charCodeAt(pos);\n  while (_isDigit(cc)) {\n    pos++;\n    if (pos === input.length) return pos;\n    cc = input.charCodeAt(pos);\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeLessThan = (input, pos, _callbacks) => {\n  if (input.slice(pos + 1, pos + 4) === \"!--\") return pos + 4;\n  return pos + 1;\n};\n\n/** @type {CharHandler} */\nconst consumeAt = (input, pos, callbacks) => {\n  const start = pos;\n  pos++;\n  if (pos === input.length) return pos;\n  if (_startsIdentifier(input, pos)) {\n    pos = _consumeIdentifier(input, pos, callbacks);\n    if (callbacks.atKeyword !== undefined) {\n      pos = callbacks.atKeyword(input, start, pos);\n    }\n  }\n  return pos;\n};\n\n/** @type {CharHandler} */\nconst consumeReverseSolidus = (input, pos, callbacks) => {\n  const start = pos;\n  pos++;\n  if (pos === input.length) return pos;\n  // If the input stream starts with a valid escape, reconsume the current input code point, consume an ident-like token, and return it.\n  if (_isTwoCodePointsAreValidEscape(input.charCodeAt(start), input.charCodeAt(pos))) {\n    return consumeOtherIdentifier(input, pos - 1, callbacks);\n  }\n  // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.\n  return pos;\n};\nconst CHAR_MAP = Array.from({\n  length: 0x80\n}, (_, cc) => {\n  // https://drafts.csswg.org/css-syntax/#consume-token\n  switch (cc) {\n    // whitespace\n    case CC_LINE_FEED:\n    case CC_CARRIAGE_RETURN:\n    case CC_FORM_FEED:\n    case CC_TAB:\n    case CC_SPACE:\n      return consumeSpace;\n    // U+0022 QUOTATION MARK (\")\n    case CC_QUOTATION_MARK:\n      return consumeString(cc);\n    // U+0023 NUMBER SIGN (#)\n    case CC_NUMBER_SIGN:\n      return consumeNumberSign;\n    // U+0027 APOSTROPHE (')\n    case CC_APOSTROPHE:\n      return consumeString(cc);\n    // U+0028 LEFT PARENTHESIS (()\n    case CC_LEFT_PARENTHESIS:\n      return consumeLeftParenthesis;\n    // U+0029 RIGHT PARENTHESIS ())\n    case CC_RIGHT_PARENTHESIS:\n      return consumeRightParenthesis;\n    // U+002B PLUS SIGN (+)\n    case CC_PLUS_SIGN:\n      return consumeNumericToken;\n    // U+002C COMMA (,)\n    case CC_COMMA:\n      return consumeComma;\n    // U+002D HYPHEN-MINUS (-)\n    case CC_HYPHEN_MINUS:\n      return consumeMinus;\n    // U+002E FULL STOP (.)\n    case CC_FULL_STOP:\n      return consumeDot;\n    // U+003A COLON (:)\n    case CC_COLON:\n      return consumePotentialPseudo;\n    // U+003B SEMICOLON (;)\n    case CC_SEMICOLON:\n      return consumeSemicolon;\n    // U+003C LESS-THAN SIGN (<)\n    case CC_LESS_THAN_SIGN:\n      return consumeLessThan;\n    // U+0040 COMMERCIAL AT (@)\n    case CC_AT_SIGN:\n      return consumeAt;\n    // U+005B LEFT SQUARE BRACKET ([)\n    case CC_LEFT_SQUARE:\n      return consumeDelimToken;\n    // U+005C REVERSE SOLIDUS (\\)\n    case CC_REVERSE_SOLIDUS:\n      return consumeReverseSolidus;\n    // U+005D RIGHT SQUARE BRACKET (])\n    case CC_RIGHT_SQUARE:\n      return consumeDelimToken;\n    // U+007B LEFT CURLY BRACKET ({)\n    case CC_LEFT_CURLY:\n      return consumeLeftCurlyBracket;\n    // U+007D RIGHT CURLY BRACKET (})\n    case CC_RIGHT_CURLY:\n      return consumeRightCurlyBracket;\n    // Optimization\n    case CC_LOWER_U:\n    case CC_UPPER_U:\n      return consumePotentialUrl;\n    default:\n      // digit\n      if (_isDigit(cc)) return consumeNumericToken;\n      // ident-start code point\n      if (isIdentStartCodePoint(cc)) {\n        return consumeOtherIdentifier;\n      }\n      // EOF, but we don't have it\n      // anything else\n      return consumeDelimToken;\n  }\n});\n\n/**\n * @param {string} input input css\n * @param {CssTokenCallbacks} callbacks callbacks\n * @returns {void}\n */\nmodule.exports = (input, callbacks) => {\n  // This section describes how to consume a token from a stream of code points. It will return a single token of any type.\n  let pos = 0;\n  while (pos < input.length) {\n    // Consume comments.\n    pos = consumeComments(input, pos, callbacks);\n    const cc = input.charCodeAt(pos);\n\n    // Consume the next input code point.\n    if (cc < 0x80) {\n      pos = CHAR_MAP[cc](input, pos, callbacks);\n    } else {\n      pos++;\n    }\n  }\n};\nmodule.exports.isIdentStartCodePoint = isIdentStartCodePoint;\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after comments\n */\nmodule.exports.eatComments = (input, pos) => {\n  for (;;) {\n    const originalPos = pos;\n    pos = consumeComments(input, pos, {});\n    if (originalPos === pos) {\n      break;\n    }\n  }\n  return pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace\n */\nmodule.exports.eatWhitespace = (input, pos) => {\n  while (_isWhiteSpace(input.charCodeAt(pos))) {\n    pos++;\n  }\n  return pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace and comments\n */\nmodule.exports.eatWhitespaceAndComments = (input, pos) => {\n  for (;;) {\n    const originalPos = pos;\n    pos = consumeComments(input, pos, {});\n    while (_isWhiteSpace(input.charCodeAt(pos))) {\n      pos++;\n    }\n    if (originalPos === pos) {\n      break;\n    }\n  }\n  return pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace\n */\nmodule.exports.eatWhiteLine = (input, pos) => {\n  for (;;) {\n    const cc = input.charCodeAt(pos);\n    if (_isSpace(cc)) {\n      pos++;\n      continue;\n    }\n    if (_isNewLine(cc)) pos++;\n    // For `\\r\\n`\n    if (cc === CC_CARRIAGE_RETURN && input.charCodeAt(pos + 1) === CC_LINE_FEED) pos++;\n    break;\n  }\n  return pos;\n};","map":{"version":3,"names":["CC_LINE_FEED","charCodeAt","CC_CARRIAGE_RETURN","CC_FORM_FEED","CC_TAB","CC_SPACE","CC_SOLIDUS","CC_REVERSE_SOLIDUS","CC_ASTERISK","CC_LEFT_PARENTHESIS","CC_RIGHT_PARENTHESIS","CC_LEFT_CURLY","CC_RIGHT_CURLY","CC_LEFT_SQUARE","CC_RIGHT_SQUARE","CC_QUOTATION_MARK","CC_APOSTROPHE","CC_FULL_STOP","CC_COLON","CC_SEMICOLON","CC_COMMA","CC_PERCENTAGE","CC_AT_SIGN","CC_LOW_LINE","CC_LOWER_A","CC_LOWER_U","CC_LOWER_E","CC_LOWER_Z","CC_UPPER_A","CC_UPPER_E","CC_UPPER_U","CC_UPPER_Z","CC_0","CC_9","CC_NUMBER_SIGN","CC_PLUS_SIGN","CC_HYPHEN_MINUS","CC_LESS_THAN_SIGN","CC_GREATER_THAN_SIGN","_isNewLine","cc","consumeSpace","input","pos","_callbacks","_isWhiteSpace","_isNewline","_isSpace","isIdentStartCodePoint","consumeDelimToken","consumeComments","length","consumeString","quoteCc","callbacks","start","_consumeString","string","undefined","_isIdentifierStartCode","_isTwoCodePointsAreValidEscape","first","second","_isDigit","_startsIdentifier","consumeNumberSign","isSelector","_consumeIdentifier","id","consumeMinus","consumeNumericToken","identifier","consumeOtherIdentifier","consumeDot","class","_consumeNumber","function","consumePotentialUrl","nextPos","slice","toLowerCase","contentStart","contentEnd","url","consumePotentialPseudo","pseudoFunction","pseudoClass","consumeLeftParenthesis","leftParenthesis","consumeRightParenthesis","rightParenthesis","consumeLeftCurlyBracket","leftCurlyBracket","consumeRightCurlyBracket","rightCurlyBracket","consumeSemicolon","semicolon","consumeComma","comma","next","consumeLessThan","consumeAt","atKeyword","consumeReverseSolidus","CHAR_MAP","Array","from","_","module","exports","eatComments","originalPos","eatWhitespace","eatWhitespaceAndComments","eatWhiteLine"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/webpack/lib/css/walkCssTokens.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\n/**\n * @typedef {object} CssTokenCallbacks\n * @property {function(string, number): boolean=} isSelector\n * @property {function(string, number, number, number, number): number=} url\n * @property {function(string, number, number): number=} string\n * @property {function(string, number, number): number=} leftParenthesis\n * @property {function(string, number, number): number=} rightParenthesis\n * @property {function(string, number, number): number=} pseudoFunction\n * @property {function(string, number, number): number=} function\n * @property {function(string, number, number): number=} pseudoClass\n * @property {function(string, number, number): number=} atKeyword\n * @property {function(string, number, number): number=} class\n * @property {function(string, number, number): number=} identifier\n * @property {function(string, number, number): number=} id\n * @property {function(string, number, number): number=} leftCurlyBracket\n * @property {function(string, number, number): number=} rightCurlyBracket\n * @property {function(string, number, number): number=} semicolon\n * @property {function(string, number, number): number=} comma\n */\n\n/** @typedef {function(string, number, CssTokenCallbacks): number} CharHandler */\n\n// spec: https://drafts.csswg.org/css-syntax/\n\nconst CC_LINE_FEED = \"\\n\".charCodeAt(0);\nconst CC_CARRIAGE_RETURN = \"\\r\".charCodeAt(0);\nconst CC_FORM_FEED = \"\\f\".charCodeAt(0);\n\nconst CC_TAB = \"\\t\".charCodeAt(0);\nconst CC_SPACE = \" \".charCodeAt(0);\n\nconst CC_SOLIDUS = \"/\".charCodeAt(0);\nconst CC_REVERSE_SOLIDUS = \"\\\\\".charCodeAt(0);\nconst CC_ASTERISK = \"*\".charCodeAt(0);\n\nconst CC_LEFT_PARENTHESIS = \"(\".charCodeAt(0);\nconst CC_RIGHT_PARENTHESIS = \")\".charCodeAt(0);\nconst CC_LEFT_CURLY = \"{\".charCodeAt(0);\nconst CC_RIGHT_CURLY = \"}\".charCodeAt(0);\nconst CC_LEFT_SQUARE = \"[\".charCodeAt(0);\nconst CC_RIGHT_SQUARE = \"]\".charCodeAt(0);\n\nconst CC_QUOTATION_MARK = '\"'.charCodeAt(0);\nconst CC_APOSTROPHE = \"'\".charCodeAt(0);\n\nconst CC_FULL_STOP = \".\".charCodeAt(0);\nconst CC_COLON = \":\".charCodeAt(0);\nconst CC_SEMICOLON = \";\".charCodeAt(0);\nconst CC_COMMA = \",\".charCodeAt(0);\nconst CC_PERCENTAGE = \"%\".charCodeAt(0);\nconst CC_AT_SIGN = \"@\".charCodeAt(0);\n\nconst CC_LOW_LINE = \"_\".charCodeAt(0);\nconst CC_LOWER_A = \"a\".charCodeAt(0);\nconst CC_LOWER_U = \"u\".charCodeAt(0);\nconst CC_LOWER_E = \"e\".charCodeAt(0);\nconst CC_LOWER_Z = \"z\".charCodeAt(0);\nconst CC_UPPER_A = \"A\".charCodeAt(0);\nconst CC_UPPER_E = \"E\".charCodeAt(0);\nconst CC_UPPER_U = \"U\".charCodeAt(0);\nconst CC_UPPER_Z = \"Z\".charCodeAt(0);\nconst CC_0 = \"0\".charCodeAt(0);\nconst CC_9 = \"9\".charCodeAt(0);\n\nconst CC_NUMBER_SIGN = \"#\".charCodeAt(0);\nconst CC_PLUS_SIGN = \"+\".charCodeAt(0);\nconst CC_HYPHEN_MINUS = \"-\".charCodeAt(0);\n\nconst CC_LESS_THAN_SIGN = \"<\".charCodeAt(0);\nconst CC_GREATER_THAN_SIGN = \">\".charCodeAt(0);\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a newline\n */\nconst _isNewLine = cc =>\n\tcc === CC_LINE_FEED || cc === CC_CARRIAGE_RETURN || cc === CC_FORM_FEED;\n\n/** @type {CharHandler} */\nconst consumeSpace = (input, pos, _callbacks) => {\n\t/** @type {number} */\n\tlet cc;\n\tdo {\n\t\tpos++;\n\t\tcc = input.charCodeAt(pos);\n\t} while (_isWhiteSpace(cc));\n\treturn pos;\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a newline\n */\nconst _isNewline = cc =>\n\tcc === CC_LINE_FEED || cc === CC_CARRIAGE_RETURN || cc === CC_FORM_FEED;\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a space (U+0009 CHARACTER TABULATION or U+0020 SPACE)\n */\nconst _isSpace = cc => cc === CC_TAB || cc === CC_SPACE;\n\n/**\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a whitespace\n */\nconst _isWhiteSpace = cc => _isNewline(cc) || _isSpace(cc);\n\n/**\n * ident-start code point\n *\n * A letter, a non-ASCII code point, or U+005F LOW LINE (_).\n * @param {number} cc char code\n * @returns {boolean} true, if cc is a start code point of an identifier\n */\nconst isIdentStartCodePoint = cc =>\n\t(cc >= CC_LOWER_A && cc <= CC_LOWER_Z) ||\n\t(cc >= CC_UPPER_A && cc <= CC_UPPER_Z) ||\n\tcc === CC_LOW_LINE ||\n\tcc >= 0x80;\n\n/** @type {CharHandler} */\nconst consumeDelimToken = (input, pos, _callbacks) => pos + 1;\n\n/** @type {CharHandler} */\nconst consumeComments = (input, pos, _callbacks) => {\n\t// If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A\n\t// ASTERISK (*), consume them and all following code points up to and including\n\t// the first U+002A ASTERISK (*) followed by a U+002F SOLIDUS (/), or up to an\n\t// EOF code point. Return to the start of this step.\n\t//\n\t// If the preceding paragraph ended by consuming an EOF code point, this is a parse error.\n\t// But we are silent on errors.\n\tif (\n\t\tinput.charCodeAt(pos) === CC_SOLIDUS &&\n\t\tinput.charCodeAt(pos + 1) === CC_ASTERISK\n\t) {\n\t\tpos += 1;\n\t\twhile (pos < input.length) {\n\t\t\tif (\n\t\t\t\tinput.charCodeAt(pos) === CC_ASTERISK &&\n\t\t\t\tinput.charCodeAt(pos + 1) === CC_SOLIDUS\n\t\t\t) {\n\t\t\t\tpos += 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t}\n\treturn pos;\n};\n\n/** @type {function(number): CharHandler} */\nconst consumeString = quoteCc => (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos = _consumeString(input, pos, quoteCc);\n\tif (callbacks.string !== undefined) {\n\t\tpos = callbacks.string(input, start, pos);\n\t}\n\treturn pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @param {number} quoteCc quote char code\n * @returns {number} new position\n */\nconst _consumeString = (input, pos, quoteCc) => {\n\tpos++;\n\tfor (;;) {\n\t\tif (pos === input.length) return pos;\n\t\tconst cc = input.charCodeAt(pos);\n\t\tif (cc === quoteCc) return pos + 1;\n\t\tif (_isNewLine(cc)) {\n\t\t\t// bad string\n\t\t\treturn pos;\n\t\t}\n\t\tif (cc === CC_REVERSE_SOLIDUS) {\n\t\t\t// we don't need to fully parse the escaped code point\n\t\t\t// just skip over a potential new line\n\t\t\tpos++;\n\t\t\tif (pos === input.length) return pos;\n\t\t\tpos++;\n\t\t} else {\n\t\t\tpos++;\n\t\t}\n\t}\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} is identifier start code\n */\nconst _isIdentifierStartCode = cc =>\n\tcc === CC_LOW_LINE ||\n\t(cc >= CC_LOWER_A && cc <= CC_LOWER_Z) ||\n\t(cc >= CC_UPPER_A && cc <= CC_UPPER_Z) ||\n\tcc > 0x80;\n\n/**\n * @param {number} first first code point\n * @param {number} second second code point\n * @returns {boolean} true if two code points are a valid escape\n */\nconst _isTwoCodePointsAreValidEscape = (first, second) => {\n\tif (first !== CC_REVERSE_SOLIDUS) return false;\n\tif (_isNewLine(second)) return false;\n\treturn true;\n};\n\n/**\n * @param {number} cc char code\n * @returns {boolean} is digit\n */\nconst _isDigit = cc => cc >= CC_0 && cc <= CC_9;\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {boolean} true, if input at pos starts an identifier\n */\nconst _startsIdentifier = (input, pos) => {\n\tconst cc = input.charCodeAt(pos);\n\tif (cc === CC_HYPHEN_MINUS) {\n\t\tif (pos === input.length) return false;\n\t\tconst cc = input.charCodeAt(pos + 1);\n\t\tif (cc === CC_HYPHEN_MINUS) return true;\n\t\tif (cc === CC_REVERSE_SOLIDUS) {\n\t\t\tconst cc = input.charCodeAt(pos + 2);\n\t\t\treturn !_isNewLine(cc);\n\t\t}\n\t\treturn _isIdentifierStartCode(cc);\n\t}\n\tif (cc === CC_REVERSE_SOLIDUS) {\n\t\tconst cc = input.charCodeAt(pos + 1);\n\t\treturn !_isNewLine(cc);\n\t}\n\treturn _isIdentifierStartCode(cc);\n};\n\n/** @type {CharHandler} */\nconst consumeNumberSign = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos++;\n\tif (pos === input.length) return pos;\n\tif (\n\t\tcallbacks.isSelector &&\n\t\tcallbacks.isSelector(input, pos) &&\n\t\t_startsIdentifier(input, pos)\n\t) {\n\t\tpos = _consumeIdentifier(input, pos, callbacks);\n\t\tif (callbacks.id !== undefined) {\n\t\t\treturn callbacks.id(input, start, pos);\n\t\t}\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeMinus = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos++;\n\tif (pos === input.length) return pos;\n\tconst cc = input.charCodeAt(pos);\n\t// If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n\tif (cc === CC_FULL_STOP || _isDigit(cc)) {\n\t\treturn consumeNumericToken(input, pos, callbacks);\n\t} else if (cc === CC_HYPHEN_MINUS) {\n\t\tpos++;\n\t\tif (pos === input.length) return pos;\n\t\tconst cc = input.charCodeAt(pos);\n\t\tif (cc === CC_GREATER_THAN_SIGN) {\n\t\t\treturn pos + 1;\n\t\t}\n\t\tpos = _consumeIdentifier(input, pos, callbacks);\n\t\tif (callbacks.identifier !== undefined) {\n\t\t\treturn callbacks.identifier(input, start, pos);\n\t\t}\n\t} else if (cc === CC_REVERSE_SOLIDUS) {\n\t\tif (pos + 1 === input.length) return pos;\n\t\tconst cc = input.charCodeAt(pos + 1);\n\t\tif (_isNewLine(cc)) return pos;\n\t\tpos = _consumeIdentifier(input, pos, callbacks);\n\t\tif (callbacks.identifier !== undefined) {\n\t\t\treturn callbacks.identifier(input, start, pos);\n\t\t}\n\t} else if (_isIdentifierStartCode(cc)) {\n\t\tpos = consumeOtherIdentifier(input, pos - 1, callbacks);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeDot = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos++;\n\tif (pos === input.length) return pos;\n\tconst cc = input.charCodeAt(pos);\n\tif (_isDigit(cc)) return consumeNumericToken(input, pos - 2, callbacks);\n\tif (\n\t\t(callbacks.isSelector && !callbacks.isSelector(input, pos)) ||\n\t\t!_startsIdentifier(input, pos)\n\t)\n\t\treturn pos;\n\tpos = _consumeIdentifier(input, pos, callbacks);\n\tif (callbacks.class !== undefined) return callbacks.class(input, start, pos);\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeNumericToken = (input, pos, callbacks) => {\n\tpos = _consumeNumber(input, pos, callbacks);\n\tif (pos === input.length) return pos;\n\tif (_startsIdentifier(input, pos))\n\t\treturn _consumeIdentifier(input, pos, callbacks);\n\tconst cc = input.charCodeAt(pos);\n\tif (cc === CC_PERCENTAGE) return pos + 1;\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeOtherIdentifier = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos = _consumeIdentifier(input, pos, callbacks);\n\tif (pos !== input.length && input.charCodeAt(pos) === CC_LEFT_PARENTHESIS) {\n\t\tpos++;\n\t\tif (callbacks.function !== undefined) {\n\t\t\treturn callbacks.function(input, start, pos);\n\t\t}\n\t} else if (callbacks.identifier !== undefined) {\n\t\treturn callbacks.identifier(input, start, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumePotentialUrl = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos = _consumeIdentifier(input, pos, callbacks);\n\tconst nextPos = pos + 1;\n\tif (\n\t\tpos === start + 3 &&\n\t\tinput.slice(start, nextPos).toLowerCase() === \"url(\"\n\t) {\n\t\tpos++;\n\t\tlet cc = input.charCodeAt(pos);\n\t\twhile (_isWhiteSpace(cc)) {\n\t\t\tpos++;\n\t\t\tif (pos === input.length) return pos;\n\t\t\tcc = input.charCodeAt(pos);\n\t\t}\n\t\tif (cc === CC_QUOTATION_MARK || cc === CC_APOSTROPHE) {\n\t\t\tif (callbacks.function !== undefined) {\n\t\t\t\treturn callbacks.function(input, start, nextPos);\n\t\t\t}\n\t\t\treturn nextPos;\n\t\t}\n\t\tconst contentStart = pos;\n\t\t/** @type {number} */\n\t\tlet contentEnd;\n\t\tfor (;;) {\n\t\t\tif (cc === CC_REVERSE_SOLIDUS) {\n\t\t\t\tpos++;\n\t\t\t\tif (pos === input.length) return pos;\n\t\t\t\tpos++;\n\t\t\t} else if (_isWhiteSpace(cc)) {\n\t\t\t\tcontentEnd = pos;\n\t\t\t\tdo {\n\t\t\t\t\tpos++;\n\t\t\t\t\tif (pos === input.length) return pos;\n\t\t\t\t\tcc = input.charCodeAt(pos);\n\t\t\t\t} while (_isWhiteSpace(cc));\n\t\t\t\tif (cc !== CC_RIGHT_PARENTHESIS) return pos;\n\t\t\t\tpos++;\n\t\t\t\tif (callbacks.url !== undefined) {\n\t\t\t\t\treturn callbacks.url(input, start, pos, contentStart, contentEnd);\n\t\t\t\t}\n\t\t\t\treturn pos;\n\t\t\t} else if (cc === CC_RIGHT_PARENTHESIS) {\n\t\t\t\tcontentEnd = pos;\n\t\t\t\tpos++;\n\t\t\t\tif (callbacks.url !== undefined) {\n\t\t\t\t\treturn callbacks.url(input, start, pos, contentStart, contentEnd);\n\t\t\t\t}\n\t\t\t\treturn pos;\n\t\t\t} else if (cc === CC_LEFT_PARENTHESIS) {\n\t\t\t\treturn pos;\n\t\t\t} else {\n\t\t\t\tpos++;\n\t\t\t}\n\t\t\tif (pos === input.length) return pos;\n\t\t\tcc = input.charCodeAt(pos);\n\t\t}\n\t} else {\n\t\tif (callbacks.identifier !== undefined) {\n\t\t\treturn callbacks.identifier(input, start, pos);\n\t\t}\n\t\treturn pos;\n\t}\n};\n\n/** @type {CharHandler} */\nconst consumePotentialPseudo = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos++;\n\tif (\n\t\t(callbacks.isSelector && !callbacks.isSelector(input, pos)) ||\n\t\t!_startsIdentifier(input, pos)\n\t)\n\t\treturn pos;\n\tpos = _consumeIdentifier(input, pos, callbacks);\n\tconst cc = input.charCodeAt(pos);\n\tif (cc === CC_LEFT_PARENTHESIS) {\n\t\tpos++;\n\t\tif (callbacks.pseudoFunction !== undefined) {\n\t\t\treturn callbacks.pseudoFunction(input, start, pos);\n\t\t}\n\t\treturn pos;\n\t}\n\tif (callbacks.pseudoClass !== undefined) {\n\t\treturn callbacks.pseudoClass(input, start, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeLeftParenthesis = (input, pos, callbacks) => {\n\tpos++;\n\tif (callbacks.leftParenthesis !== undefined) {\n\t\treturn callbacks.leftParenthesis(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeRightParenthesis = (input, pos, callbacks) => {\n\tpos++;\n\tif (callbacks.rightParenthesis !== undefined) {\n\t\treturn callbacks.rightParenthesis(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeLeftCurlyBracket = (input, pos, callbacks) => {\n\tpos++;\n\tif (callbacks.leftCurlyBracket !== undefined) {\n\t\treturn callbacks.leftCurlyBracket(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeRightCurlyBracket = (input, pos, callbacks) => {\n\tpos++;\n\tif (callbacks.rightCurlyBracket !== undefined) {\n\t\treturn callbacks.rightCurlyBracket(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeSemicolon = (input, pos, callbacks) => {\n\tpos++;\n\tif (callbacks.semicolon !== undefined) {\n\t\treturn callbacks.semicolon(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeComma = (input, pos, callbacks) => {\n\tpos++;\n\tif (callbacks.comma !== undefined) {\n\t\treturn callbacks.comma(input, pos - 1, pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst _consumeIdentifier = (input, pos) => {\n\tfor (;;) {\n\t\tconst cc = input.charCodeAt(pos);\n\t\tif (cc === CC_REVERSE_SOLIDUS) {\n\t\t\tpos++;\n\t\t\tif (pos === input.length) return pos;\n\t\t\tpos++;\n\t\t} else if (\n\t\t\t_isIdentifierStartCode(cc) ||\n\t\t\t_isDigit(cc) ||\n\t\t\tcc === CC_HYPHEN_MINUS\n\t\t) {\n\t\t\tpos++;\n\t\t} else {\n\t\t\treturn pos;\n\t\t}\n\t}\n};\n\n/** @type {CharHandler} */\nconst _consumeNumber = (input, pos) => {\n\tpos++;\n\tif (pos === input.length) return pos;\n\tlet cc = input.charCodeAt(pos);\n\twhile (_isDigit(cc)) {\n\t\tpos++;\n\t\tif (pos === input.length) return pos;\n\t\tcc = input.charCodeAt(pos);\n\t}\n\tif (cc === CC_FULL_STOP && pos + 1 !== input.length) {\n\t\tconst next = input.charCodeAt(pos + 1);\n\t\tif (_isDigit(next)) {\n\t\t\tpos += 2;\n\t\t\tcc = input.charCodeAt(pos);\n\t\t\twhile (_isDigit(cc)) {\n\t\t\t\tpos++;\n\t\t\t\tif (pos === input.length) return pos;\n\t\t\t\tcc = input.charCodeAt(pos);\n\t\t\t}\n\t\t}\n\t}\n\tif (cc === CC_LOWER_E || cc === CC_UPPER_E) {\n\t\tif (pos + 1 !== input.length) {\n\t\t\tconst next = input.charCodeAt(pos + 2);\n\t\t\tif (_isDigit(next)) {\n\t\t\t\tpos += 2;\n\t\t\t} else if (\n\t\t\t\t(next === CC_HYPHEN_MINUS || next === CC_PLUS_SIGN) &&\n\t\t\t\tpos + 2 !== input.length\n\t\t\t) {\n\t\t\t\tconst next = input.charCodeAt(pos + 2);\n\t\t\t\tif (_isDigit(next)) {\n\t\t\t\t\tpos += 3;\n\t\t\t\t} else {\n\t\t\t\t\treturn pos;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn pos;\n\t\t\t}\n\t\t}\n\t} else {\n\t\treturn pos;\n\t}\n\tcc = input.charCodeAt(pos);\n\twhile (_isDigit(cc)) {\n\t\tpos++;\n\t\tif (pos === input.length) return pos;\n\t\tcc = input.charCodeAt(pos);\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeLessThan = (input, pos, _callbacks) => {\n\tif (input.slice(pos + 1, pos + 4) === \"!--\") return pos + 4;\n\treturn pos + 1;\n};\n\n/** @type {CharHandler} */\nconst consumeAt = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos++;\n\tif (pos === input.length) return pos;\n\tif (_startsIdentifier(input, pos)) {\n\t\tpos = _consumeIdentifier(input, pos, callbacks);\n\t\tif (callbacks.atKeyword !== undefined) {\n\t\t\tpos = callbacks.atKeyword(input, start, pos);\n\t\t}\n\t}\n\treturn pos;\n};\n\n/** @type {CharHandler} */\nconst consumeReverseSolidus = (input, pos, callbacks) => {\n\tconst start = pos;\n\tpos++;\n\tif (pos === input.length) return pos;\n\t// If the input stream starts with a valid escape, reconsume the current input code point, consume an ident-like token, and return it.\n\tif (\n\t\t_isTwoCodePointsAreValidEscape(\n\t\t\tinput.charCodeAt(start),\n\t\t\tinput.charCodeAt(pos)\n\t\t)\n\t) {\n\t\treturn consumeOtherIdentifier(input, pos - 1, callbacks);\n\t}\n\t// Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.\n\treturn pos;\n};\n\nconst CHAR_MAP = Array.from({ length: 0x80 }, (_, cc) => {\n\t// https://drafts.csswg.org/css-syntax/#consume-token\n\tswitch (cc) {\n\t\t// whitespace\n\t\tcase CC_LINE_FEED:\n\t\tcase CC_CARRIAGE_RETURN:\n\t\tcase CC_FORM_FEED:\n\t\tcase CC_TAB:\n\t\tcase CC_SPACE:\n\t\t\treturn consumeSpace;\n\t\t// U+0022 QUOTATION MARK (\")\n\t\tcase CC_QUOTATION_MARK:\n\t\t\treturn consumeString(cc);\n\t\t// U+0023 NUMBER SIGN (#)\n\t\tcase CC_NUMBER_SIGN:\n\t\t\treturn consumeNumberSign;\n\t\t// U+0027 APOSTROPHE (')\n\t\tcase CC_APOSTROPHE:\n\t\t\treturn consumeString(cc);\n\t\t// U+0028 LEFT PARENTHESIS (()\n\t\tcase CC_LEFT_PARENTHESIS:\n\t\t\treturn consumeLeftParenthesis;\n\t\t// U+0029 RIGHT PARENTHESIS ())\n\t\tcase CC_RIGHT_PARENTHESIS:\n\t\t\treturn consumeRightParenthesis;\n\t\t// U+002B PLUS SIGN (+)\n\t\tcase CC_PLUS_SIGN:\n\t\t\treturn consumeNumericToken;\n\t\t// U+002C COMMA (,)\n\t\tcase CC_COMMA:\n\t\t\treturn consumeComma;\n\t\t// U+002D HYPHEN-MINUS (-)\n\t\tcase CC_HYPHEN_MINUS:\n\t\t\treturn consumeMinus;\n\t\t// U+002E FULL STOP (.)\n\t\tcase CC_FULL_STOP:\n\t\t\treturn consumeDot;\n\t\t// U+003A COLON (:)\n\t\tcase CC_COLON:\n\t\t\treturn consumePotentialPseudo;\n\t\t// U+003B SEMICOLON (;)\n\t\tcase CC_SEMICOLON:\n\t\t\treturn consumeSemicolon;\n\t\t// U+003C LESS-THAN SIGN (<)\n\t\tcase CC_LESS_THAN_SIGN:\n\t\t\treturn consumeLessThan;\n\t\t// U+0040 COMMERCIAL AT (@)\n\t\tcase CC_AT_SIGN:\n\t\t\treturn consumeAt;\n\t\t// U+005B LEFT SQUARE BRACKET ([)\n\t\tcase CC_LEFT_SQUARE:\n\t\t\treturn consumeDelimToken;\n\t\t// U+005C REVERSE SOLIDUS (\\)\n\t\tcase CC_REVERSE_SOLIDUS:\n\t\t\treturn consumeReverseSolidus;\n\t\t// U+005D RIGHT SQUARE BRACKET (])\n\t\tcase CC_RIGHT_SQUARE:\n\t\t\treturn consumeDelimToken;\n\t\t// U+007B LEFT CURLY BRACKET ({)\n\t\tcase CC_LEFT_CURLY:\n\t\t\treturn consumeLeftCurlyBracket;\n\t\t// U+007D RIGHT CURLY BRACKET (})\n\t\tcase CC_RIGHT_CURLY:\n\t\t\treturn consumeRightCurlyBracket;\n\t\t// Optimization\n\t\tcase CC_LOWER_U:\n\t\tcase CC_UPPER_U:\n\t\t\treturn consumePotentialUrl;\n\t\tdefault:\n\t\t\t// digit\n\t\t\tif (_isDigit(cc)) return consumeNumericToken;\n\t\t\t// ident-start code point\n\t\t\tif (isIdentStartCodePoint(cc)) {\n\t\t\t\treturn consumeOtherIdentifier;\n\t\t\t}\n\t\t\t// EOF, but we don't have it\n\t\t\t// anything else\n\t\t\treturn consumeDelimToken;\n\t}\n});\n\n/**\n * @param {string} input input css\n * @param {CssTokenCallbacks} callbacks callbacks\n * @returns {void}\n */\nmodule.exports = (input, callbacks) => {\n\t// This section describes how to consume a token from a stream of code points. It will return a single token of any type.\n\tlet pos = 0;\n\twhile (pos < input.length) {\n\t\t// Consume comments.\n\t\tpos = consumeComments(input, pos, callbacks);\n\n\t\tconst cc = input.charCodeAt(pos);\n\n\t\t// Consume the next input code point.\n\t\tif (cc < 0x80) {\n\t\t\tpos = CHAR_MAP[cc](input, pos, callbacks);\n\t\t} else {\n\t\t\tpos++;\n\t\t}\n\t}\n};\n\nmodule.exports.isIdentStartCodePoint = isIdentStartCodePoint;\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after comments\n */\nmodule.exports.eatComments = (input, pos) => {\n\tfor (;;) {\n\t\tconst originalPos = pos;\n\t\tpos = consumeComments(input, pos, {});\n\t\tif (originalPos === pos) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace\n */\nmodule.exports.eatWhitespace = (input, pos) => {\n\twhile (_isWhiteSpace(input.charCodeAt(pos))) {\n\t\tpos++;\n\t}\n\n\treturn pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace and comments\n */\nmodule.exports.eatWhitespaceAndComments = (input, pos) => {\n\tfor (;;) {\n\t\tconst originalPos = pos;\n\t\tpos = consumeComments(input, pos, {});\n\t\twhile (_isWhiteSpace(input.charCodeAt(pos))) {\n\t\t\tpos++;\n\t\t}\n\t\tif (originalPos === pos) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pos;\n};\n\n/**\n * @param {string} input input\n * @param {number} pos position\n * @returns {number} position after whitespace\n */\nmodule.exports.eatWhiteLine = (input, pos) => {\n\tfor (;;) {\n\t\tconst cc = input.charCodeAt(pos);\n\t\tif (_isSpace(cc)) {\n\t\t\tpos++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (_isNewLine(cc)) pos++;\n\t\t// For `\\r\\n`\n\t\tif (cc === CC_CARRIAGE_RETURN && input.charCodeAt(pos + 1) === CC_LINE_FEED)\n\t\t\tpos++;\n\t\tbreak;\n\t}\n\n\treturn pos;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}