{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst Template = require(\"../Template\");\nconst {\n  isSubset\n} = require(\"../util/SetHelpers\");\nconst {\n  getAllChunks\n} = require(\"./ChunkHelpers\");\n\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Chunk\").ChunkId} ChunkId */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../ChunkGraph\").ModuleId} ModuleId */\n/** @typedef {import(\"../Entrypoint\")} Entrypoint */\n/** @typedef {import(\"../ChunkGraph\").EntryModuleWithChunkGroup} EntryModuleWithChunkGroup */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {(string|number)[]} EntryItem */\n\nconst EXPORT_PREFIX = `var ${RuntimeGlobals.exports} = `;\n\n/** @typedef {Set<Chunk>} Chunks */\n/** @typedef {ModuleId[]} ModuleIds */\n\n/**\n * @param {ChunkGraph} chunkGraph chunkGraph\n * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate\n * @param {EntryModuleWithChunkGroup[]} entries entries\n * @param {Chunk} chunk chunk\n * @param {boolean} passive true: passive startup with on chunks loaded\n * @returns {string} runtime code\n */\nmodule.exports.generateEntryStartup = (chunkGraph, runtimeTemplate, entries, chunk, passive) => {\n  /** @type {string[]} */\n  const runtime = [`var __webpack_exec__ = ${runtimeTemplate.returningFunction(`${RuntimeGlobals.require}(${RuntimeGlobals.entryModuleId} = moduleId)`, \"moduleId\")}`];\n\n  /**\n   * @param {ModuleId} id id\n   * @returns {string} fn to execute\n   */\n  const runModule = id => `__webpack_exec__(${JSON.stringify(id)})`;\n  /**\n   * @param {Chunks} chunks chunks\n   * @param {ModuleIds} moduleIds module ids\n   * @param {boolean=} final true when final, otherwise false\n   */\n  const outputCombination = (chunks, moduleIds, final) => {\n    if (chunks.size === 0) {\n      runtime.push(`${final ? EXPORT_PREFIX : \"\"}(${moduleIds.map(runModule).join(\", \")});`);\n    } else {\n      const fn = runtimeTemplate.returningFunction(moduleIds.map(runModule).join(\", \"));\n      runtime.push(`${final && !passive ? EXPORT_PREFIX : \"\"}${passive ? RuntimeGlobals.onChunksLoaded : RuntimeGlobals.startupEntrypoint}(0, ${JSON.stringify(Array.from(chunks, c => c.id))}, ${fn});`);\n      if (final && passive) {\n        runtime.push(`${EXPORT_PREFIX}${RuntimeGlobals.onChunksLoaded}();`);\n      }\n    }\n  };\n\n  /** @type {Chunks | undefined} */\n  let currentChunks;\n  /** @type {ModuleIds | undefined} */\n  let currentModuleIds;\n  for (const [module, entrypoint] of entries) {\n    const runtimeChunk = /** @type {Entrypoint} */\n    entrypoint.getRuntimeChunk();\n    const moduleId = /** @type {ModuleId} */chunkGraph.getModuleId(module);\n    const chunks = getAllChunks(/** @type {Entrypoint} */\n    entrypoint, chunk, runtimeChunk);\n    if (currentChunks && currentChunks.size === chunks.size && isSubset(currentChunks, chunks)) {\n      /** @type {ModuleIds} */\n      currentModuleIds.push(moduleId);\n    } else {\n      if (currentChunks) {\n        outputCombination(currentChunks, /** @type {ModuleIds} */currentModuleIds);\n      }\n      currentChunks = chunks;\n      currentModuleIds = [moduleId];\n    }\n  }\n\n  // output current modules with export prefix\n  if (currentChunks) {\n    outputCombination(currentChunks, /** @type {ModuleIds} */\n    currentModuleIds, true);\n  }\n  runtime.push(\"\");\n  return Template.asString(runtime);\n};\n\n/**\n * @param {Hash} hash the hash to update\n * @param {ChunkGraph} chunkGraph chunkGraph\n * @param {EntryModuleWithChunkGroup[]} entries entries\n * @param {Chunk} chunk chunk\n * @returns {void}\n */\nmodule.exports.updateHashForEntryStartup = (hash, chunkGraph, entries, chunk) => {\n  for (const [module, entrypoint] of entries) {\n    const runtimeChunk = /** @type {Entrypoint} */\n    entrypoint.getRuntimeChunk();\n    const moduleId = chunkGraph.getModuleId(module);\n    hash.update(`${moduleId}`);\n    for (const c of getAllChunks(/** @type {Entrypoint} */entrypoint, chunk, /** @type {Chunk} */runtimeChunk)) {\n      hash.update(`${c.id}`);\n    }\n  }\n};\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {function(Chunk, ChunkGraph): boolean} filterFn filter function\n * @returns {Set<number | string>} initially fulfilled chunk ids\n */\nmodule.exports.getInitialChunkIds = (chunk, chunkGraph, filterFn) => {\n  const initialChunkIds = new Set(chunk.ids);\n  for (const c of chunk.getAllInitialChunks()) {\n    if (c === chunk || filterFn(c, chunkGraph)) continue;\n    for (const id of (/** @type {ChunkId[]} */c.ids)) {\n      initialChunkIds.add(id);\n    }\n  }\n  return initialChunkIds;\n};","map":{"version":3,"names":["RuntimeGlobals","require","Template","isSubset","getAllChunks","EXPORT_PREFIX","exports","module","generateEntryStartup","chunkGraph","runtimeTemplate","entries","chunk","passive","runtime","returningFunction","entryModuleId","runModule","id","JSON","stringify","outputCombination","chunks","moduleIds","final","size","push","map","join","fn","onChunksLoaded","startupEntrypoint","Array","from","c","currentChunks","currentModuleIds","entrypoint","runtimeChunk","getRuntimeChunk","moduleId","getModuleId","asString","updateHashForEntryStartup","hash","update","getInitialChunkIds","filterFn","initialChunkIds","Set","ids","getAllInitialChunks","add"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/webpack/lib/javascript/StartupHelpers.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst RuntimeGlobals = require(\"../RuntimeGlobals\");\nconst Template = require(\"../Template\");\nconst { isSubset } = require(\"../util/SetHelpers\");\nconst { getAllChunks } = require(\"./ChunkHelpers\");\n\n/** @typedef {import(\"../util/Hash\")} Hash */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Chunk\").ChunkId} ChunkId */\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"../ChunkGraph\").ModuleId} ModuleId */\n/** @typedef {import(\"../Entrypoint\")} Entrypoint */\n/** @typedef {import(\"../ChunkGraph\").EntryModuleWithChunkGroup} EntryModuleWithChunkGroup */\n/** @typedef {import(\"../ChunkGroup\")} ChunkGroup */\n/** @typedef {import(\"../RuntimeTemplate\")} RuntimeTemplate */\n/** @typedef {(string|number)[]} EntryItem */\n\nconst EXPORT_PREFIX = `var ${RuntimeGlobals.exports} = `;\n\n/** @typedef {Set<Chunk>} Chunks */\n/** @typedef {ModuleId[]} ModuleIds */\n\n/**\n * @param {ChunkGraph} chunkGraph chunkGraph\n * @param {RuntimeTemplate} runtimeTemplate runtimeTemplate\n * @param {EntryModuleWithChunkGroup[]} entries entries\n * @param {Chunk} chunk chunk\n * @param {boolean} passive true: passive startup with on chunks loaded\n * @returns {string} runtime code\n */\nmodule.exports.generateEntryStartup = (\n\tchunkGraph,\n\truntimeTemplate,\n\tentries,\n\tchunk,\n\tpassive\n) => {\n\t/** @type {string[]} */\n\tconst runtime = [\n\t\t`var __webpack_exec__ = ${runtimeTemplate.returningFunction(\n\t\t\t`${RuntimeGlobals.require}(${RuntimeGlobals.entryModuleId} = moduleId)`,\n\t\t\t\"moduleId\"\n\t\t)}`\n\t];\n\n\t/**\n\t * @param {ModuleId} id id\n\t * @returns {string} fn to execute\n\t */\n\tconst runModule = id => `__webpack_exec__(${JSON.stringify(id)})`;\n\t/**\n\t * @param {Chunks} chunks chunks\n\t * @param {ModuleIds} moduleIds module ids\n\t * @param {boolean=} final true when final, otherwise false\n\t */\n\tconst outputCombination = (chunks, moduleIds, final) => {\n\t\tif (chunks.size === 0) {\n\t\t\truntime.push(\n\t\t\t\t`${final ? EXPORT_PREFIX : \"\"}(${moduleIds.map(runModule).join(\", \")});`\n\t\t\t);\n\t\t} else {\n\t\t\tconst fn = runtimeTemplate.returningFunction(\n\t\t\t\tmoduleIds.map(runModule).join(\", \")\n\t\t\t);\n\t\t\truntime.push(\n\t\t\t\t`${final && !passive ? EXPORT_PREFIX : \"\"}${\n\t\t\t\t\tpassive\n\t\t\t\t\t\t? RuntimeGlobals.onChunksLoaded\n\t\t\t\t\t\t: RuntimeGlobals.startupEntrypoint\n\t\t\t\t}(0, ${JSON.stringify(Array.from(chunks, c => c.id))}, ${fn});`\n\t\t\t);\n\t\t\tif (final && passive) {\n\t\t\t\truntime.push(`${EXPORT_PREFIX}${RuntimeGlobals.onChunksLoaded}();`);\n\t\t\t}\n\t\t}\n\t};\n\n\t/** @type {Chunks | undefined} */\n\tlet currentChunks;\n\t/** @type {ModuleIds | undefined} */\n\tlet currentModuleIds;\n\n\tfor (const [module, entrypoint] of entries) {\n\t\tconst runtimeChunk =\n\t\t\t/** @type {Entrypoint} */\n\t\t\t(entrypoint).getRuntimeChunk();\n\t\tconst moduleId = /** @type {ModuleId} */ (chunkGraph.getModuleId(module));\n\t\tconst chunks = getAllChunks(\n\t\t\t/** @type {Entrypoint} */\n\t\t\t(entrypoint),\n\t\t\tchunk,\n\t\t\truntimeChunk\n\t\t);\n\t\tif (\n\t\t\tcurrentChunks &&\n\t\t\tcurrentChunks.size === chunks.size &&\n\t\t\tisSubset(currentChunks, chunks)\n\t\t) {\n\t\t\t/** @type {ModuleIds} */\n\t\t\t(currentModuleIds).push(moduleId);\n\t\t} else {\n\t\t\tif (currentChunks) {\n\t\t\t\toutputCombination(\n\t\t\t\t\tcurrentChunks,\n\t\t\t\t\t/** @type {ModuleIds} */ (currentModuleIds)\n\t\t\t\t);\n\t\t\t}\n\t\t\tcurrentChunks = chunks;\n\t\t\tcurrentModuleIds = [moduleId];\n\t\t}\n\t}\n\n\t// output current modules with export prefix\n\tif (currentChunks) {\n\t\toutputCombination(\n\t\t\tcurrentChunks,\n\t\t\t/** @type {ModuleIds} */\n\t\t\t(currentModuleIds),\n\t\t\ttrue\n\t\t);\n\t}\n\truntime.push(\"\");\n\treturn Template.asString(runtime);\n};\n\n/**\n * @param {Hash} hash the hash to update\n * @param {ChunkGraph} chunkGraph chunkGraph\n * @param {EntryModuleWithChunkGroup[]} entries entries\n * @param {Chunk} chunk chunk\n * @returns {void}\n */\nmodule.exports.updateHashForEntryStartup = (\n\thash,\n\tchunkGraph,\n\tentries,\n\tchunk\n) => {\n\tfor (const [module, entrypoint] of entries) {\n\t\tconst runtimeChunk =\n\t\t\t/** @type {Entrypoint} */\n\t\t\t(entrypoint).getRuntimeChunk();\n\t\tconst moduleId = chunkGraph.getModuleId(module);\n\t\thash.update(`${moduleId}`);\n\t\tfor (const c of getAllChunks(\n\t\t\t/** @type {Entrypoint} */ (entrypoint),\n\t\t\tchunk,\n\t\t\t/** @type {Chunk} */ (runtimeChunk)\n\t\t)) {\n\t\t\thash.update(`${c.id}`);\n\t\t}\n\t}\n};\n\n/**\n * @param {Chunk} chunk the chunk\n * @param {ChunkGraph} chunkGraph the chunk graph\n * @param {function(Chunk, ChunkGraph): boolean} filterFn filter function\n * @returns {Set<number | string>} initially fulfilled chunk ids\n */\nmodule.exports.getInitialChunkIds = (chunk, chunkGraph, filterFn) => {\n\tconst initialChunkIds = new Set(chunk.ids);\n\tfor (const c of chunk.getAllInitialChunks()) {\n\t\tif (c === chunk || filterFn(c, chunkGraph)) continue;\n\t\tfor (const id of /** @type {ChunkId[]} */ (c.ids)) {\n\t\t\tinitialChunkIds.add(id);\n\t\t}\n\t}\n\treturn initialChunkIds;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}