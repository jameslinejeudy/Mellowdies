{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  SyncBailHook\n} = require(\"tapable\");\nconst {\n  RawSource\n} = require(\"webpack-sources\");\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Compilation = require(\"./Compilation\");\nconst HotUpdateChunk = require(\"./HotUpdateChunk\");\nconst NormalModule = require(\"./NormalModule\");\nconst RuntimeGlobals = require(\"./RuntimeGlobals\");\nconst WebpackError = require(\"./WebpackError\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst ImportMetaHotAcceptDependency = require(\"./dependencies/ImportMetaHotAcceptDependency\");\nconst ImportMetaHotDeclineDependency = require(\"./dependencies/ImportMetaHotDeclineDependency\");\nconst ModuleHotAcceptDependency = require(\"./dependencies/ModuleHotAcceptDependency\");\nconst ModuleHotDeclineDependency = require(\"./dependencies/ModuleHotDeclineDependency\");\nconst HotModuleReplacementRuntimeModule = require(\"./hmr/HotModuleReplacementRuntimeModule\");\nconst JavascriptParser = require(\"./javascript/JavascriptParser\");\nconst {\n  evaluateToIdentifier\n} = require(\"./javascript/JavascriptParserHelpers\");\nconst {\n  find,\n  isSubset\n} = require(\"./util/SetHelpers\");\nconst TupleSet = require(\"./util/TupleSet\");\nconst {\n  compareModulesById\n} = require(\"./util/comparators\");\nconst {\n  getRuntimeKey,\n  keyToRuntime,\n  forEachRuntime,\n  mergeRuntimeOwned,\n  subtractRuntime,\n  intersectRuntime\n} = require(\"./util/runtime\");\nconst {\n  JAVASCRIPT_MODULE_TYPE_AUTO,\n  JAVASCRIPT_MODULE_TYPE_DYNAMIC,\n  JAVASCRIPT_MODULE_TYPE_ESM,\n  WEBPACK_MODULE_TYPE_RUNTIME\n} = require(\"./ModuleTypeConstants\");\n\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"../declarations/WebpackOptions\").OutputNormalized} OutputNormalized */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Chunk\").ChunkId} ChunkId */\n/** @typedef {import(\"./ChunkGraph\").ModuleId} ModuleId */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Module\").BuildInfo} BuildInfo */\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n/** @typedef {import(\"./javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"./javascript/JavascriptParserHelpers\").Range} Range */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {object} HMRJavascriptParserHooks\n * @property {SyncBailHook<[TODO, string[]], void>} hotAcceptCallback\n * @property {SyncBailHook<[TODO, string[]], void>} hotAcceptWithoutCallback\n */\n\n/** @typedef {{ updatedChunkIds: Set<ChunkId>, removedChunkIds: Set<ChunkId>, removedModules: Set<Module>, filename: string, assetInfo: AssetInfo }} HotUpdateMainContentByRuntimeItem */\n/** @typedef {Map<string, HotUpdateMainContentByRuntimeItem>} HotUpdateMainContentByRuntime */\n\n/** @type {WeakMap<JavascriptParser, HMRJavascriptParserHooks>} */\nconst parserHooksMap = new WeakMap();\nconst PLUGIN_NAME = \"HotModuleReplacementPlugin\";\nclass HotModuleReplacementPlugin {\n  /**\n   * @param {JavascriptParser} parser the parser\n   * @returns {HMRJavascriptParserHooks} the attached hooks\n   */\n  static getParserHooks(parser) {\n    if (!(parser instanceof JavascriptParser)) {\n      throw new TypeError(\"The 'parser' argument must be an instance of JavascriptParser\");\n    }\n    let hooks = parserHooksMap.get(parser);\n    if (hooks === undefined) {\n      hooks = {\n        hotAcceptCallback: new SyncBailHook([\"expression\", \"requests\"]),\n        hotAcceptWithoutCallback: new SyncBailHook([\"expression\", \"requests\"])\n      };\n      parserHooksMap.set(parser, hooks);\n    }\n    return hooks;\n  }\n\n  /**\n   * @param {object=} options options\n   */\n  constructor(options) {\n    this.options = options || {};\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const {\n      _backCompat: backCompat\n    } = compiler;\n    if (compiler.options.output.strictModuleErrorHandling === undefined) compiler.options.output.strictModuleErrorHandling = true;\n    const runtimeRequirements = [RuntimeGlobals.module];\n\n    /**\n     * @param {JavascriptParser} parser the parser\n     * @param {typeof ModuleHotAcceptDependency} ParamDependency dependency\n     * @returns {(expr: CallExpression) => boolean | undefined} callback\n     */\n    const createAcceptHandler = (parser, ParamDependency) => {\n      const {\n        hotAcceptCallback,\n        hotAcceptWithoutCallback\n      } = HotModuleReplacementPlugin.getParserHooks(parser);\n      return expr => {\n        const module = parser.state.module;\n        const dep = new ConstDependency(`${module.moduleArgument}.hot.accept`, /** @type {Range} */expr.callee.range, runtimeRequirements);\n        dep.loc = /** @type {DependencyLocation} */expr.loc;\n        module.addPresentationalDependency(dep);\n        /** @type {BuildInfo} */\n        module.buildInfo.moduleConcatenationBailout = \"Hot Module Replacement\";\n        if (expr.arguments.length >= 1) {\n          const arg = parser.evaluateExpression(/** @type {Expression} */expr.arguments[0]);\n          /** @type {BasicEvaluatedExpression[]} */\n          let params = [];\n          if (arg.isString()) {\n            params = [arg];\n          } else if (arg.isArray()) {\n            params = /** @type {BasicEvaluatedExpression[]} */\n            arg.items.filter(param => param.isString());\n          }\n          /** @type {string[]} */\n          const requests = [];\n          if (params.length > 0) {\n            for (const [idx, param] of params.entries()) {\n              const request = /** @type {string} */param.string;\n              const dep = new ParamDependency(request, /** @type {Range} */param.range);\n              dep.optional = true;\n              dep.loc = Object.create(/** @type {DependencyLocation} */expr.loc);\n              dep.loc.index = idx;\n              module.addDependency(dep);\n              requests.push(request);\n            }\n            if (expr.arguments.length > 1) {\n              hotAcceptCallback.call(expr.arguments[1], requests);\n              for (let i = 1; i < expr.arguments.length; i++) {\n                parser.walkExpression(expr.arguments[i]);\n              }\n              return true;\n            }\n            hotAcceptWithoutCallback.call(expr, requests);\n            return true;\n          }\n        }\n        parser.walkExpressions(expr.arguments);\n        return true;\n      };\n    };\n\n    /**\n     * @param {JavascriptParser} parser the parser\n     * @param {typeof ModuleHotDeclineDependency} ParamDependency dependency\n     * @returns {(expr: CallExpression) => boolean | undefined} callback\n     */\n    const createDeclineHandler = (parser, ParamDependency) => expr => {\n      const module = parser.state.module;\n      const dep = new ConstDependency(`${module.moduleArgument}.hot.decline`, /** @type {Range} */expr.callee.range, runtimeRequirements);\n      dep.loc = /** @type {DependencyLocation} */expr.loc;\n      module.addPresentationalDependency(dep);\n      /** @type {BuildInfo} */\n      module.buildInfo.moduleConcatenationBailout = \"Hot Module Replacement\";\n      if (expr.arguments.length === 1) {\n        const arg = parser.evaluateExpression(expr.arguments[0]);\n        /** @type {BasicEvaluatedExpression[]} */\n        let params = [];\n        if (arg.isString()) {\n          params = [arg];\n        } else if (arg.isArray()) {\n          params = /** @type {BasicEvaluatedExpression[]} */\n          arg.items.filter(param => param.isString());\n        }\n        for (const [idx, param] of params.entries()) {\n          const dep = new ParamDependency(/** @type {string} */param.string, /** @type {Range} */param.range);\n          dep.optional = true;\n          dep.loc = Object.create(/** @type {DependencyLocation} */expr.loc);\n          dep.loc.index = idx;\n          module.addDependency(dep);\n        }\n      }\n      return true;\n    };\n\n    /**\n     * @param {JavascriptParser} parser the parser\n     * @returns {(expr: Expression) => boolean | undefined} callback\n     */\n    const createHMRExpressionHandler = parser => expr => {\n      const module = parser.state.module;\n      const dep = new ConstDependency(`${module.moduleArgument}.hot`, /** @type {Range} */expr.range, runtimeRequirements);\n      dep.loc = /** @type {DependencyLocation} */expr.loc;\n      module.addPresentationalDependency(dep);\n      /** @type {BuildInfo} */\n      module.buildInfo.moduleConcatenationBailout = \"Hot Module Replacement\";\n      return true;\n    };\n\n    /**\n     * @param {JavascriptParser} parser the parser\n     * @returns {void}\n     */\n    const applyModuleHot = parser => {\n      parser.hooks.evaluateIdentifier.for(\"module.hot\").tap({\n        name: PLUGIN_NAME,\n        before: \"NodeStuffPlugin\"\n      }, expr => evaluateToIdentifier(\"module.hot\", \"module\", () => [\"hot\"], true)(expr));\n      parser.hooks.call.for(\"module.hot.accept\").tap(PLUGIN_NAME, createAcceptHandler(parser, ModuleHotAcceptDependency));\n      parser.hooks.call.for(\"module.hot.decline\").tap(PLUGIN_NAME, createDeclineHandler(parser, ModuleHotDeclineDependency));\n      parser.hooks.expression.for(\"module.hot\").tap(PLUGIN_NAME, createHMRExpressionHandler(parser));\n    };\n\n    /**\n     * @param {JavascriptParser} parser the parser\n     * @returns {void}\n     */\n    const applyImportMetaHot = parser => {\n      parser.hooks.evaluateIdentifier.for(\"import.meta.webpackHot\").tap(PLUGIN_NAME, expr => evaluateToIdentifier(\"import.meta.webpackHot\", \"import.meta\", () => [\"webpackHot\"], true)(expr));\n      parser.hooks.call.for(\"import.meta.webpackHot.accept\").tap(PLUGIN_NAME, createAcceptHandler(parser, ImportMetaHotAcceptDependency));\n      parser.hooks.call.for(\"import.meta.webpackHot.decline\").tap(PLUGIN_NAME, createDeclineHandler(parser, ImportMetaHotDeclineDependency));\n      parser.hooks.expression.for(\"import.meta.webpackHot\").tap(PLUGIN_NAME, createHMRExpressionHandler(parser));\n    };\n    compiler.hooks.compilation.tap(PLUGIN_NAME, (compilation, {\n      normalModuleFactory\n    }) => {\n      // This applies the HMR plugin only to the targeted compiler\n      // It should not affect child compilations\n      if (compilation.compiler !== compiler) return;\n\n      // #region module.hot.* API\n      compilation.dependencyFactories.set(ModuleHotAcceptDependency, normalModuleFactory);\n      compilation.dependencyTemplates.set(ModuleHotAcceptDependency, new ModuleHotAcceptDependency.Template());\n      compilation.dependencyFactories.set(ModuleHotDeclineDependency, normalModuleFactory);\n      compilation.dependencyTemplates.set(ModuleHotDeclineDependency, new ModuleHotDeclineDependency.Template());\n      // #endregion\n\n      // #region import.meta.webpackHot.* API\n      compilation.dependencyFactories.set(ImportMetaHotAcceptDependency, normalModuleFactory);\n      compilation.dependencyTemplates.set(ImportMetaHotAcceptDependency, new ImportMetaHotAcceptDependency.Template());\n      compilation.dependencyFactories.set(ImportMetaHotDeclineDependency, normalModuleFactory);\n      compilation.dependencyTemplates.set(ImportMetaHotDeclineDependency, new ImportMetaHotDeclineDependency.Template());\n      // #endregion\n\n      let hotIndex = 0;\n      /** @type {Record<string, string>} */\n      const fullHashChunkModuleHashes = {};\n      /** @type {Record<string, string>} */\n      const chunkModuleHashes = {};\n      compilation.hooks.record.tap(PLUGIN_NAME, (compilation, records) => {\n        if (records.hash === compilation.hash) return;\n        const chunkGraph = compilation.chunkGraph;\n        records.hash = compilation.hash;\n        records.hotIndex = hotIndex;\n        records.fullHashChunkModuleHashes = fullHashChunkModuleHashes;\n        records.chunkModuleHashes = chunkModuleHashes;\n        records.chunkHashes = {};\n        records.chunkRuntime = {};\n        for (const chunk of compilation.chunks) {\n          const chunkId = /** @type {ChunkId} */chunk.id;\n          records.chunkHashes[chunkId] = chunk.hash;\n          records.chunkRuntime[chunkId] = getRuntimeKey(chunk.runtime);\n        }\n        records.chunkModuleIds = {};\n        for (const chunk of compilation.chunks) {\n          records.chunkModuleIds[(/** @type {ChunkId} */chunk.id)] = Array.from(chunkGraph.getOrderedChunkModulesIterable(chunk, compareModulesById(chunkGraph)), m => chunkGraph.getModuleId(m));\n        }\n      });\n      /** @type {TupleSet<[Module, Chunk]>} */\n      const updatedModules = new TupleSet();\n      /** @type {TupleSet<[Module, Chunk]>} */\n      const fullHashModules = new TupleSet();\n      /** @type {TupleSet<[Module, RuntimeSpec]>} */\n      const nonCodeGeneratedModules = new TupleSet();\n      compilation.hooks.fullHash.tap(PLUGIN_NAME, hash => {\n        const chunkGraph = compilation.chunkGraph;\n        const records = compilation.records;\n        for (const chunk of compilation.chunks) {\n          /**\n           * @param {Module} module module\n           * @returns {string} module hash\n           */\n          const getModuleHash = module => {\n            if (compilation.codeGenerationResults.has(module, chunk.runtime)) {\n              return compilation.codeGenerationResults.getHash(module, chunk.runtime);\n            }\n            nonCodeGeneratedModules.add(module, chunk.runtime);\n            return chunkGraph.getModuleHash(module, chunk.runtime);\n          };\n          const fullHashModulesInThisChunk = chunkGraph.getChunkFullHashModulesSet(chunk);\n          if (fullHashModulesInThisChunk !== undefined) {\n            for (const module of fullHashModulesInThisChunk) {\n              fullHashModules.add(module, chunk);\n            }\n          }\n          const modules = chunkGraph.getChunkModulesIterable(chunk);\n          if (modules !== undefined) {\n            if (records.chunkModuleHashes) {\n              if (fullHashModulesInThisChunk !== undefined) {\n                for (const module of modules) {\n                  const key = `${chunk.id}|${module.identifier()}`;\n                  const hash = getModuleHash(module);\n                  if (fullHashModulesInThisChunk.has(/** @type {RuntimeModule} */module)) {\n                    if (records.fullHashChunkModuleHashes[key] !== hash) {\n                      updatedModules.add(module, chunk);\n                    }\n                    fullHashChunkModuleHashes[key] = hash;\n                  } else {\n                    if (records.chunkModuleHashes[key] !== hash) {\n                      updatedModules.add(module, chunk);\n                    }\n                    chunkModuleHashes[key] = hash;\n                  }\n                }\n              } else {\n                for (const module of modules) {\n                  const key = `${chunk.id}|${module.identifier()}`;\n                  const hash = getModuleHash(module);\n                  if (records.chunkModuleHashes[key] !== hash) {\n                    updatedModules.add(module, chunk);\n                  }\n                  chunkModuleHashes[key] = hash;\n                }\n              }\n            } else if (fullHashModulesInThisChunk !== undefined) {\n              for (const module of modules) {\n                const key = `${chunk.id}|${module.identifier()}`;\n                const hash = getModuleHash(module);\n                if (fullHashModulesInThisChunk.has(/** @type {RuntimeModule} */module)) {\n                  fullHashChunkModuleHashes[key] = hash;\n                } else {\n                  chunkModuleHashes[key] = hash;\n                }\n              }\n            } else {\n              for (const module of modules) {\n                const key = `${chunk.id}|${module.identifier()}`;\n                const hash = getModuleHash(module);\n                chunkModuleHashes[key] = hash;\n              }\n            }\n          }\n        }\n        hotIndex = records.hotIndex || 0;\n        if (updatedModules.size > 0) hotIndex++;\n        hash.update(`${hotIndex}`);\n      });\n      compilation.hooks.processAssets.tap({\n        name: PLUGIN_NAME,\n        stage: Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL\n      }, () => {\n        const chunkGraph = compilation.chunkGraph;\n        const records = compilation.records;\n        if (records.hash === compilation.hash) return;\n        if (!records.chunkModuleHashes || !records.chunkHashes || !records.chunkModuleIds) {\n          return;\n        }\n        for (const [module, chunk] of fullHashModules) {\n          const key = `${chunk.id}|${module.identifier()}`;\n          const hash = nonCodeGeneratedModules.has(module, chunk.runtime) ? chunkGraph.getModuleHash(module, chunk.runtime) : compilation.codeGenerationResults.getHash(module, chunk.runtime);\n          if (records.chunkModuleHashes[key] !== hash) {\n            updatedModules.add(module, chunk);\n          }\n          chunkModuleHashes[key] = hash;\n        }\n\n        /** @type {HotUpdateMainContentByRuntime} */\n        const hotUpdateMainContentByRuntime = new Map();\n        let allOldRuntime;\n        for (const key of Object.keys(records.chunkRuntime)) {\n          const runtime = keyToRuntime(records.chunkRuntime[key]);\n          allOldRuntime = mergeRuntimeOwned(allOldRuntime, runtime);\n        }\n        forEachRuntime(allOldRuntime, runtime => {\n          const {\n            path: filename,\n            info: assetInfo\n          } = compilation.getPathWithInfo(/** @type {NonNullable<OutputNormalized[\"hotUpdateMainFilename\"]>} */\n          compilation.outputOptions.hotUpdateMainFilename, {\n            hash: records.hash,\n            runtime\n          });\n          hotUpdateMainContentByRuntime.set(/** @type {string} */runtime, {\n            updatedChunkIds: new Set(),\n            removedChunkIds: new Set(),\n            removedModules: new Set(),\n            filename,\n            assetInfo\n          });\n        });\n        if (hotUpdateMainContentByRuntime.size === 0) return;\n\n        // Create a list of all active modules to verify which modules are removed completely\n        /** @type {Map<number|string, Module>} */\n        const allModules = new Map();\n        for (const module of compilation.modules) {\n          const id = /** @type {ModuleId} */\n          chunkGraph.getModuleId(module);\n          allModules.set(id, module);\n        }\n\n        // List of completely removed modules\n        /** @type {Set<string | number>} */\n        const completelyRemovedModules = new Set();\n        for (const key of Object.keys(records.chunkHashes)) {\n          const oldRuntime = keyToRuntime(records.chunkRuntime[key]);\n          /** @type {Module[]} */\n          const remainingModules = [];\n          // Check which modules are removed\n          for (const id of records.chunkModuleIds[key]) {\n            const module = allModules.get(id);\n            if (module === undefined) {\n              completelyRemovedModules.add(id);\n            } else {\n              remainingModules.push(module);\n            }\n          }\n\n          /** @type {ChunkId | null} */\n          let chunkId;\n          let newModules;\n          let newRuntimeModules;\n          let newFullHashModules;\n          let newDependentHashModules;\n          let newRuntime;\n          let removedFromRuntime;\n          const currentChunk = find(compilation.chunks, chunk => `${chunk.id}` === key);\n          if (currentChunk) {\n            chunkId = currentChunk.id;\n            newRuntime = intersectRuntime(currentChunk.runtime, allOldRuntime);\n            if (newRuntime === undefined) continue;\n            newModules = chunkGraph.getChunkModules(currentChunk).filter(module => updatedModules.has(module, currentChunk));\n            newRuntimeModules = Array.from(chunkGraph.getChunkRuntimeModulesIterable(currentChunk)).filter(module => updatedModules.has(module, currentChunk));\n            const fullHashModules = chunkGraph.getChunkFullHashModulesIterable(currentChunk);\n            newFullHashModules = fullHashModules && Array.from(fullHashModules).filter(module => updatedModules.has(module, currentChunk));\n            const dependentHashModules = chunkGraph.getChunkDependentHashModulesIterable(currentChunk);\n            newDependentHashModules = dependentHashModules && Array.from(dependentHashModules).filter(module => updatedModules.has(module, currentChunk));\n            removedFromRuntime = subtractRuntime(oldRuntime, newRuntime);\n          } else {\n            // chunk has completely removed\n            chunkId = `${Number(key)}` === key ? Number(key) : key;\n            removedFromRuntime = oldRuntime;\n            newRuntime = oldRuntime;\n          }\n          if (removedFromRuntime) {\n            // chunk was removed from some runtimes\n            forEachRuntime(removedFromRuntime, runtime => {\n              const item = /** @type {HotUpdateMainContentByRuntimeItem} */\n\n              hotUpdateMainContentByRuntime.get(/** @type {string} */runtime);\n              item.removedChunkIds.add(/** @type {ChunkId} */chunkId);\n            });\n            // dispose modules from the chunk in these runtimes\n            // where they are no longer in this runtime\n            for (const module of remainingModules) {\n              const moduleKey = `${key}|${module.identifier()}`;\n              const oldHash = records.chunkModuleHashes[moduleKey];\n              const runtimes = chunkGraph.getModuleRuntimes(module);\n              if (oldRuntime === newRuntime && runtimes.has(newRuntime)) {\n                // Module is still in the same runtime combination\n                const hash = nonCodeGeneratedModules.has(module, newRuntime) ? chunkGraph.getModuleHash(module, newRuntime) : compilation.codeGenerationResults.getHash(module, newRuntime);\n                if (hash !== oldHash) {\n                  if (module.type === WEBPACK_MODULE_TYPE_RUNTIME) {\n                    newRuntimeModules = newRuntimeModules || [];\n                    newRuntimeModules.push(/** @type {RuntimeModule} */module);\n                  } else {\n                    newModules = newModules || [];\n                    newModules.push(module);\n                  }\n                }\n              } else {\n                // module is no longer in this runtime combination\n                // We (incorrectly) assume that it's not in an overlapping runtime combination\n                // and dispose it from the main runtimes the chunk was removed from\n                forEachRuntime(removedFromRuntime, runtime => {\n                  // If the module is still used in this runtime, do not dispose it\n                  // This could create a bad runtime state where the module is still loaded,\n                  // but no chunk which contains it. This means we don't receive further HMR updates\n                  // to this module and that's bad.\n                  // TODO force load one of the chunks which contains the module\n                  for (const moduleRuntime of runtimes) {\n                    if (typeof moduleRuntime === \"string\") {\n                      if (moduleRuntime === runtime) return;\n                    } else if (moduleRuntime !== undefined && moduleRuntime.has(/** @type {string} */runtime)) return;\n                  }\n                  const item = /** @type {HotUpdateMainContentByRuntimeItem} */\n                  hotUpdateMainContentByRuntime.get(/** @type {string} */runtime);\n                  item.removedModules.add(module);\n                });\n              }\n            }\n          }\n          if (newModules && newModules.length > 0 || newRuntimeModules && newRuntimeModules.length > 0) {\n            const hotUpdateChunk = new HotUpdateChunk();\n            if (backCompat) ChunkGraph.setChunkGraphForChunk(hotUpdateChunk, chunkGraph);\n            hotUpdateChunk.id = chunkId;\n            hotUpdateChunk.runtime = newRuntime;\n            if (currentChunk) {\n              for (const group of currentChunk.groupsIterable) hotUpdateChunk.addGroup(group);\n            }\n            chunkGraph.attachModules(hotUpdateChunk, newModules || []);\n            chunkGraph.attachRuntimeModules(hotUpdateChunk, newRuntimeModules || []);\n            if (newFullHashModules) {\n              chunkGraph.attachFullHashModules(hotUpdateChunk, newFullHashModules);\n            }\n            if (newDependentHashModules) {\n              chunkGraph.attachDependentHashModules(hotUpdateChunk, newDependentHashModules);\n            }\n            const renderManifest = compilation.getRenderManifest({\n              chunk: hotUpdateChunk,\n              hash: records.hash,\n              fullHash: records.hash,\n              outputOptions: compilation.outputOptions,\n              moduleTemplates: compilation.moduleTemplates,\n              dependencyTemplates: compilation.dependencyTemplates,\n              codeGenerationResults: compilation.codeGenerationResults,\n              runtimeTemplate: compilation.runtimeTemplate,\n              moduleGraph: compilation.moduleGraph,\n              chunkGraph\n            });\n            for (const entry of renderManifest) {\n              /** @type {string} */\n              let filename;\n              /** @type {AssetInfo} */\n              let assetInfo;\n              if (\"filename\" in entry) {\n                filename = entry.filename;\n                assetInfo = entry.info;\n              } else {\n                ({\n                  path: filename,\n                  info: assetInfo\n                } = compilation.getPathWithInfo(entry.filenameTemplate, entry.pathOptions));\n              }\n              const source = entry.render();\n              compilation.additionalChunkAssets.push(filename);\n              compilation.emitAsset(filename, source, {\n                hotModuleReplacement: true,\n                ...assetInfo\n              });\n              if (currentChunk) {\n                currentChunk.files.add(filename);\n                compilation.hooks.chunkAsset.call(currentChunk, filename);\n              }\n            }\n            forEachRuntime(newRuntime, runtime => {\n              const item = /** @type {HotUpdateMainContentByRuntimeItem} */\n              hotUpdateMainContentByRuntime.get(/** @type {string} */runtime);\n              item.updatedChunkIds.add(/** @type {ChunkId} */chunkId);\n            });\n          }\n        }\n        const completelyRemovedModulesArray = Array.from(completelyRemovedModules);\n        const hotUpdateMainContentByFilename = new Map();\n        for (const {\n          removedChunkIds,\n          removedModules,\n          updatedChunkIds,\n          filename,\n          assetInfo\n        } of hotUpdateMainContentByRuntime.values()) {\n          const old = hotUpdateMainContentByFilename.get(filename);\n          if (old && (!isSubset(old.removedChunkIds, removedChunkIds) || !isSubset(old.removedModules, removedModules) || !isSubset(old.updatedChunkIds, updatedChunkIds))) {\n            compilation.warnings.push(new WebpackError(`HotModuleReplacementPlugin\nThe configured output.hotUpdateMainFilename doesn't lead to unique filenames per runtime and HMR update differs between runtimes.\nThis might lead to incorrect runtime behavior of the applied update.\nTo fix this, make sure to include [runtime] in the output.hotUpdateMainFilename option, or use the default config.`));\n            for (const chunkId of removedChunkIds) old.removedChunkIds.add(chunkId);\n            for (const chunkId of removedModules) old.removedModules.add(chunkId);\n            for (const chunkId of updatedChunkIds) old.updatedChunkIds.add(chunkId);\n            continue;\n          }\n          hotUpdateMainContentByFilename.set(filename, {\n            removedChunkIds,\n            removedModules,\n            updatedChunkIds,\n            assetInfo\n          });\n        }\n        for (const [filename, {\n          removedChunkIds,\n          removedModules,\n          updatedChunkIds,\n          assetInfo\n        }] of hotUpdateMainContentByFilename) {\n          const hotUpdateMainJson = {\n            c: Array.from(updatedChunkIds),\n            r: Array.from(removedChunkIds),\n            m: removedModules.size === 0 ? completelyRemovedModulesArray : completelyRemovedModulesArray.concat(Array.from(removedModules, m => (/** @type {ModuleId} */chunkGraph.getModuleId(m))))\n          };\n          const source = new RawSource(JSON.stringify(hotUpdateMainJson));\n          compilation.emitAsset(filename, source, {\n            hotModuleReplacement: true,\n            ...assetInfo\n          });\n        }\n      });\n      compilation.hooks.additionalTreeRuntimeRequirements.tap(PLUGIN_NAME, (chunk, runtimeRequirements) => {\n        runtimeRequirements.add(RuntimeGlobals.hmrDownloadManifest);\n        runtimeRequirements.add(RuntimeGlobals.hmrDownloadUpdateHandlers);\n        runtimeRequirements.add(RuntimeGlobals.interceptModuleExecution);\n        runtimeRequirements.add(RuntimeGlobals.moduleCache);\n        compilation.addRuntimeModule(chunk, new HotModuleReplacementRuntimeModule());\n      });\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_AUTO).tap(PLUGIN_NAME, parser => {\n        applyModuleHot(parser);\n        applyImportMetaHot(parser);\n      });\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_DYNAMIC).tap(PLUGIN_NAME, parser => {\n        applyModuleHot(parser);\n      });\n      normalModuleFactory.hooks.parser.for(JAVASCRIPT_MODULE_TYPE_ESM).tap(PLUGIN_NAME, parser => {\n        applyImportMetaHot(parser);\n      });\n      NormalModule.getCompilationHooks(compilation).loader.tap(PLUGIN_NAME, context => {\n        context.hot = true;\n      });\n    });\n  }\n}\nmodule.exports = HotModuleReplacementPlugin;","map":{"version":3,"names":["SyncBailHook","require","RawSource","ChunkGraph","Compilation","HotUpdateChunk","NormalModule","RuntimeGlobals","WebpackError","ConstDependency","ImportMetaHotAcceptDependency","ImportMetaHotDeclineDependency","ModuleHotAcceptDependency","ModuleHotDeclineDependency","HotModuleReplacementRuntimeModule","JavascriptParser","evaluateToIdentifier","find","isSubset","TupleSet","compareModulesById","getRuntimeKey","keyToRuntime","forEachRuntime","mergeRuntimeOwned","subtractRuntime","intersectRuntime","JAVASCRIPT_MODULE_TYPE_AUTO","JAVASCRIPT_MODULE_TYPE_DYNAMIC","JAVASCRIPT_MODULE_TYPE_ESM","WEBPACK_MODULE_TYPE_RUNTIME","parserHooksMap","WeakMap","PLUGIN_NAME","HotModuleReplacementPlugin","getParserHooks","parser","TypeError","hooks","get","undefined","hotAcceptCallback","hotAcceptWithoutCallback","set","constructor","options","apply","compiler","_backCompat","backCompat","output","strictModuleErrorHandling","runtimeRequirements","module","createAcceptHandler","ParamDependency","expr","state","dep","moduleArgument","callee","range","loc","addPresentationalDependency","buildInfo","moduleConcatenationBailout","arguments","length","arg","evaluateExpression","params","isString","isArray","items","filter","param","requests","idx","entries","request","string","optional","Object","create","index","addDependency","push","call","i","walkExpression","walkExpressions","createDeclineHandler","createHMRExpressionHandler","applyModuleHot","evaluateIdentifier","for","tap","name","before","expression","applyImportMetaHot","compilation","normalModuleFactory","dependencyFactories","dependencyTemplates","Template","hotIndex","fullHashChunkModuleHashes","chunkModuleHashes","record","records","hash","chunkGraph","chunkHashes","chunkRuntime","chunk","chunks","chunkId","id","runtime","chunkModuleIds","Array","from","getOrderedChunkModulesIterable","m","getModuleId","updatedModules","fullHashModules","nonCodeGeneratedModules","fullHash","getModuleHash","codeGenerationResults","has","getHash","add","fullHashModulesInThisChunk","getChunkFullHashModulesSet","modules","getChunkModulesIterable","key","identifier","size","update","processAssets","stage","PROCESS_ASSETS_STAGE_ADDITIONAL","hotUpdateMainContentByRuntime","Map","allOldRuntime","keys","path","filename","info","assetInfo","getPathWithInfo","outputOptions","hotUpdateMainFilename","updatedChunkIds","Set","removedChunkIds","removedModules","allModules","completelyRemovedModules","oldRuntime","remainingModules","newModules","newRuntimeModules","newFullHashModules","newDependentHashModules","newRuntime","removedFromRuntime","currentChunk","getChunkModules","getChunkRuntimeModulesIterable","getChunkFullHashModulesIterable","dependentHashModules","getChunkDependentHashModulesIterable","Number","item","moduleKey","oldHash","runtimes","getModuleRuntimes","type","moduleRuntime","hotUpdateChunk","setChunkGraphForChunk","group","groupsIterable","addGroup","attachModules","attachRuntimeModules","attachFullHashModules","attachDependentHashModules","renderManifest","getRenderManifest","moduleTemplates","runtimeTemplate","moduleGraph","entry","filenameTemplate","pathOptions","source","render","additionalChunkAssets","emitAsset","hotModuleReplacement","files","chunkAsset","completelyRemovedModulesArray","hotUpdateMainContentByFilename","values","old","warnings","hotUpdateMainJson","c","r","concat","JSON","stringify","additionalTreeRuntimeRequirements","hmrDownloadManifest","hmrDownloadUpdateHandlers","interceptModuleExecution","moduleCache","addRuntimeModule","getCompilationHooks","loader","context","hot","exports"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/webpack/lib/HotModuleReplacementPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { SyncBailHook } = require(\"tapable\");\nconst { RawSource } = require(\"webpack-sources\");\nconst ChunkGraph = require(\"./ChunkGraph\");\nconst Compilation = require(\"./Compilation\");\nconst HotUpdateChunk = require(\"./HotUpdateChunk\");\nconst NormalModule = require(\"./NormalModule\");\nconst RuntimeGlobals = require(\"./RuntimeGlobals\");\nconst WebpackError = require(\"./WebpackError\");\nconst ConstDependency = require(\"./dependencies/ConstDependency\");\nconst ImportMetaHotAcceptDependency = require(\"./dependencies/ImportMetaHotAcceptDependency\");\nconst ImportMetaHotDeclineDependency = require(\"./dependencies/ImportMetaHotDeclineDependency\");\nconst ModuleHotAcceptDependency = require(\"./dependencies/ModuleHotAcceptDependency\");\nconst ModuleHotDeclineDependency = require(\"./dependencies/ModuleHotDeclineDependency\");\nconst HotModuleReplacementRuntimeModule = require(\"./hmr/HotModuleReplacementRuntimeModule\");\nconst JavascriptParser = require(\"./javascript/JavascriptParser\");\nconst {\n\tevaluateToIdentifier\n} = require(\"./javascript/JavascriptParserHelpers\");\nconst { find, isSubset } = require(\"./util/SetHelpers\");\nconst TupleSet = require(\"./util/TupleSet\");\nconst { compareModulesById } = require(\"./util/comparators\");\nconst {\n\tgetRuntimeKey,\n\tkeyToRuntime,\n\tforEachRuntime,\n\tmergeRuntimeOwned,\n\tsubtractRuntime,\n\tintersectRuntime\n} = require(\"./util/runtime\");\n\nconst {\n\tJAVASCRIPT_MODULE_TYPE_AUTO,\n\tJAVASCRIPT_MODULE_TYPE_DYNAMIC,\n\tJAVASCRIPT_MODULE_TYPE_ESM,\n\tWEBPACK_MODULE_TYPE_RUNTIME\n} = require(\"./ModuleTypeConstants\");\n\n/** @typedef {import(\"estree\").CallExpression} CallExpression */\n/** @typedef {import(\"estree\").Expression} Expression */\n/** @typedef {import(\"../declarations/WebpackOptions\").OutputNormalized} OutputNormalized */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Chunk\").ChunkId} ChunkId */\n/** @typedef {import(\"./ChunkGraph\").ModuleId} ModuleId */\n/** @typedef {import(\"./Compilation\").AssetInfo} AssetInfo */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Dependency\").DependencyLocation} DependencyLocation */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./Module\").BuildInfo} BuildInfo */\n/** @typedef {import(\"./RuntimeModule\")} RuntimeModule */\n/** @typedef {import(\"./javascript/BasicEvaluatedExpression\")} BasicEvaluatedExpression */\n/** @typedef {import(\"./javascript/JavascriptParserHelpers\").Range} Range */\n/** @typedef {import(\"./util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {object} HMRJavascriptParserHooks\n * @property {SyncBailHook<[TODO, string[]], void>} hotAcceptCallback\n * @property {SyncBailHook<[TODO, string[]], void>} hotAcceptWithoutCallback\n */\n\n/** @typedef {{ updatedChunkIds: Set<ChunkId>, removedChunkIds: Set<ChunkId>, removedModules: Set<Module>, filename: string, assetInfo: AssetInfo }} HotUpdateMainContentByRuntimeItem */\n/** @typedef {Map<string, HotUpdateMainContentByRuntimeItem>} HotUpdateMainContentByRuntime */\n\n/** @type {WeakMap<JavascriptParser, HMRJavascriptParserHooks>} */\nconst parserHooksMap = new WeakMap();\n\nconst PLUGIN_NAME = \"HotModuleReplacementPlugin\";\n\nclass HotModuleReplacementPlugin {\n\t/**\n\t * @param {JavascriptParser} parser the parser\n\t * @returns {HMRJavascriptParserHooks} the attached hooks\n\t */\n\tstatic getParserHooks(parser) {\n\t\tif (!(parser instanceof JavascriptParser)) {\n\t\t\tthrow new TypeError(\n\t\t\t\t\"The 'parser' argument must be an instance of JavascriptParser\"\n\t\t\t);\n\t\t}\n\t\tlet hooks = parserHooksMap.get(parser);\n\t\tif (hooks === undefined) {\n\t\t\thooks = {\n\t\t\t\thotAcceptCallback: new SyncBailHook([\"expression\", \"requests\"]),\n\t\t\t\thotAcceptWithoutCallback: new SyncBailHook([\"expression\", \"requests\"])\n\t\t\t};\n\t\t\tparserHooksMap.set(parser, hooks);\n\t\t}\n\t\treturn hooks;\n\t}\n\n\t/**\n\t * @param {object=} options options\n\t */\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst { _backCompat: backCompat } = compiler;\n\t\tif (compiler.options.output.strictModuleErrorHandling === undefined)\n\t\t\tcompiler.options.output.strictModuleErrorHandling = true;\n\t\tconst runtimeRequirements = [RuntimeGlobals.module];\n\n\t\t/**\n\t\t * @param {JavascriptParser} parser the parser\n\t\t * @param {typeof ModuleHotAcceptDependency} ParamDependency dependency\n\t\t * @returns {(expr: CallExpression) => boolean | undefined} callback\n\t\t */\n\t\tconst createAcceptHandler = (parser, ParamDependency) => {\n\t\t\tconst { hotAcceptCallback, hotAcceptWithoutCallback } =\n\t\t\t\tHotModuleReplacementPlugin.getParserHooks(parser);\n\n\t\t\treturn expr => {\n\t\t\t\tconst module = parser.state.module;\n\t\t\t\tconst dep = new ConstDependency(\n\t\t\t\t\t`${module.moduleArgument}.hot.accept`,\n\t\t\t\t\t/** @type {Range} */ (expr.callee.range),\n\t\t\t\t\truntimeRequirements\n\t\t\t\t);\n\t\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\t\tmodule.addPresentationalDependency(dep);\n\t\t\t\t/** @type {BuildInfo} */\n\t\t\t\t(module.buildInfo).moduleConcatenationBailout =\n\t\t\t\t\t\"Hot Module Replacement\";\n\t\t\t\tif (expr.arguments.length >= 1) {\n\t\t\t\t\tconst arg = parser.evaluateExpression(\n\t\t\t\t\t\t/** @type {Expression} */ (expr.arguments[0])\n\t\t\t\t\t);\n\t\t\t\t\t/** @type {BasicEvaluatedExpression[]} */\n\t\t\t\t\tlet params = [];\n\t\t\t\t\tif (arg.isString()) {\n\t\t\t\t\t\tparams = [arg];\n\t\t\t\t\t} else if (arg.isArray()) {\n\t\t\t\t\t\tparams =\n\t\t\t\t\t\t\t/** @type {BasicEvaluatedExpression[]} */\n\t\t\t\t\t\t\t(arg.items).filter(param => param.isString());\n\t\t\t\t\t}\n\t\t\t\t\t/** @type {string[]} */\n\t\t\t\t\tconst requests = [];\n\t\t\t\t\tif (params.length > 0) {\n\t\t\t\t\t\tfor (const [idx, param] of params.entries()) {\n\t\t\t\t\t\t\tconst request = /** @type {string} */ (param.string);\n\t\t\t\t\t\t\tconst dep = new ParamDependency(\n\t\t\t\t\t\t\t\trequest,\n\t\t\t\t\t\t\t\t/** @type {Range} */ (param.range)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdep.optional = true;\n\t\t\t\t\t\t\tdep.loc = Object.create(\n\t\t\t\t\t\t\t\t/** @type {DependencyLocation} */ (expr.loc)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tdep.loc.index = idx;\n\t\t\t\t\t\t\tmodule.addDependency(dep);\n\t\t\t\t\t\t\trequests.push(request);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (expr.arguments.length > 1) {\n\t\t\t\t\t\t\thotAcceptCallback.call(expr.arguments[1], requests);\n\t\t\t\t\t\t\tfor (let i = 1; i < expr.arguments.length; i++) {\n\t\t\t\t\t\t\t\tparser.walkExpression(expr.arguments[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thotAcceptWithoutCallback.call(expr, requests);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tparser.walkExpressions(expr.arguments);\n\t\t\t\treturn true;\n\t\t\t};\n\t\t};\n\n\t\t/**\n\t\t * @param {JavascriptParser} parser the parser\n\t\t * @param {typeof ModuleHotDeclineDependency} ParamDependency dependency\n\t\t * @returns {(expr: CallExpression) => boolean | undefined} callback\n\t\t */\n\t\tconst createDeclineHandler = (parser, ParamDependency) => expr => {\n\t\t\tconst module = parser.state.module;\n\t\t\tconst dep = new ConstDependency(\n\t\t\t\t`${module.moduleArgument}.hot.decline`,\n\t\t\t\t/** @type {Range} */ (expr.callee.range),\n\t\t\t\truntimeRequirements\n\t\t\t);\n\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\tmodule.addPresentationalDependency(dep);\n\t\t\t/** @type {BuildInfo} */\n\t\t\t(module.buildInfo).moduleConcatenationBailout = \"Hot Module Replacement\";\n\t\t\tif (expr.arguments.length === 1) {\n\t\t\t\tconst arg = parser.evaluateExpression(expr.arguments[0]);\n\t\t\t\t/** @type {BasicEvaluatedExpression[]} */\n\t\t\t\tlet params = [];\n\t\t\t\tif (arg.isString()) {\n\t\t\t\t\tparams = [arg];\n\t\t\t\t} else if (arg.isArray()) {\n\t\t\t\t\tparams =\n\t\t\t\t\t\t/** @type {BasicEvaluatedExpression[]} */\n\t\t\t\t\t\t(arg.items).filter(param => param.isString());\n\t\t\t\t}\n\t\t\t\tfor (const [idx, param] of params.entries()) {\n\t\t\t\t\tconst dep = new ParamDependency(\n\t\t\t\t\t\t/** @type {string} */ (param.string),\n\t\t\t\t\t\t/** @type {Range} */ (param.range)\n\t\t\t\t\t);\n\t\t\t\t\tdep.optional = true;\n\t\t\t\t\tdep.loc = Object.create(/** @type {DependencyLocation} */ (expr.loc));\n\t\t\t\t\tdep.loc.index = idx;\n\t\t\t\t\tmodule.addDependency(dep);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * @param {JavascriptParser} parser the parser\n\t\t * @returns {(expr: Expression) => boolean | undefined} callback\n\t\t */\n\t\tconst createHMRExpressionHandler = parser => expr => {\n\t\t\tconst module = parser.state.module;\n\t\t\tconst dep = new ConstDependency(\n\t\t\t\t`${module.moduleArgument}.hot`,\n\t\t\t\t/** @type {Range} */ (expr.range),\n\t\t\t\truntimeRequirements\n\t\t\t);\n\t\t\tdep.loc = /** @type {DependencyLocation} */ (expr.loc);\n\t\t\tmodule.addPresentationalDependency(dep);\n\t\t\t/** @type {BuildInfo} */\n\t\t\t(module.buildInfo).moduleConcatenationBailout = \"Hot Module Replacement\";\n\t\t\treturn true;\n\t\t};\n\n\t\t/**\n\t\t * @param {JavascriptParser} parser the parser\n\t\t * @returns {void}\n\t\t */\n\t\tconst applyModuleHot = parser => {\n\t\t\tparser.hooks.evaluateIdentifier.for(\"module.hot\").tap(\n\t\t\t\t{\n\t\t\t\t\tname: PLUGIN_NAME,\n\t\t\t\t\tbefore: \"NodeStuffPlugin\"\n\t\t\t\t},\n\t\t\t\texpr =>\n\t\t\t\t\tevaluateToIdentifier(\n\t\t\t\t\t\t\"module.hot\",\n\t\t\t\t\t\t\"module\",\n\t\t\t\t\t\t() => [\"hot\"],\n\t\t\t\t\t\ttrue\n\t\t\t\t\t)(expr)\n\t\t\t);\n\t\t\tparser.hooks.call\n\t\t\t\t.for(\"module.hot.accept\")\n\t\t\t\t.tap(\n\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\tcreateAcceptHandler(parser, ModuleHotAcceptDependency)\n\t\t\t\t);\n\t\t\tparser.hooks.call\n\t\t\t\t.for(\"module.hot.decline\")\n\t\t\t\t.tap(\n\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\tcreateDeclineHandler(parser, ModuleHotDeclineDependency)\n\t\t\t\t);\n\t\t\tparser.hooks.expression\n\t\t\t\t.for(\"module.hot\")\n\t\t\t\t.tap(PLUGIN_NAME, createHMRExpressionHandler(parser));\n\t\t};\n\n\t\t/**\n\t\t * @param {JavascriptParser} parser the parser\n\t\t * @returns {void}\n\t\t */\n\t\tconst applyImportMetaHot = parser => {\n\t\t\tparser.hooks.evaluateIdentifier\n\t\t\t\t.for(\"import.meta.webpackHot\")\n\t\t\t\t.tap(PLUGIN_NAME, expr =>\n\t\t\t\t\tevaluateToIdentifier(\n\t\t\t\t\t\t\"import.meta.webpackHot\",\n\t\t\t\t\t\t\"import.meta\",\n\t\t\t\t\t\t() => [\"webpackHot\"],\n\t\t\t\t\t\ttrue\n\t\t\t\t\t)(expr)\n\t\t\t\t);\n\t\t\tparser.hooks.call\n\t\t\t\t.for(\"import.meta.webpackHot.accept\")\n\t\t\t\t.tap(\n\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\tcreateAcceptHandler(parser, ImportMetaHotAcceptDependency)\n\t\t\t\t);\n\t\t\tparser.hooks.call\n\t\t\t\t.for(\"import.meta.webpackHot.decline\")\n\t\t\t\t.tap(\n\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\tcreateDeclineHandler(parser, ImportMetaHotDeclineDependency)\n\t\t\t\t);\n\t\t\tparser.hooks.expression\n\t\t\t\t.for(\"import.meta.webpackHot\")\n\t\t\t\t.tap(PLUGIN_NAME, createHMRExpressionHandler(parser));\n\t\t};\n\n\t\tcompiler.hooks.compilation.tap(\n\t\t\tPLUGIN_NAME,\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\t// This applies the HMR plugin only to the targeted compiler\n\t\t\t\t// It should not affect child compilations\n\t\t\t\tif (compilation.compiler !== compiler) return;\n\n\t\t\t\t// #region module.hot.* API\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tModuleHotAcceptDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tModuleHotAcceptDependency,\n\t\t\t\t\tnew ModuleHotAcceptDependency.Template()\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tModuleHotDeclineDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tModuleHotDeclineDependency,\n\t\t\t\t\tnew ModuleHotDeclineDependency.Template()\n\t\t\t\t);\n\t\t\t\t// #endregion\n\n\t\t\t\t// #region import.meta.webpackHot.* API\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tImportMetaHotAcceptDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tImportMetaHotAcceptDependency,\n\t\t\t\t\tnew ImportMetaHotAcceptDependency.Template()\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyFactories.set(\n\t\t\t\t\tImportMetaHotDeclineDependency,\n\t\t\t\t\tnormalModuleFactory\n\t\t\t\t);\n\t\t\t\tcompilation.dependencyTemplates.set(\n\t\t\t\t\tImportMetaHotDeclineDependency,\n\t\t\t\t\tnew ImportMetaHotDeclineDependency.Template()\n\t\t\t\t);\n\t\t\t\t// #endregion\n\n\t\t\t\tlet hotIndex = 0;\n\t\t\t\t/** @type {Record<string, string>} */\n\t\t\t\tconst fullHashChunkModuleHashes = {};\n\t\t\t\t/** @type {Record<string, string>} */\n\t\t\t\tconst chunkModuleHashes = {};\n\n\t\t\t\tcompilation.hooks.record.tap(PLUGIN_NAME, (compilation, records) => {\n\t\t\t\t\tif (records.hash === compilation.hash) return;\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\trecords.hash = compilation.hash;\n\t\t\t\t\trecords.hotIndex = hotIndex;\n\t\t\t\t\trecords.fullHashChunkModuleHashes = fullHashChunkModuleHashes;\n\t\t\t\t\trecords.chunkModuleHashes = chunkModuleHashes;\n\t\t\t\t\trecords.chunkHashes = {};\n\t\t\t\t\trecords.chunkRuntime = {};\n\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\tconst chunkId = /** @type {ChunkId} */ (chunk.id);\n\t\t\t\t\t\trecords.chunkHashes[chunkId] = chunk.hash;\n\t\t\t\t\t\trecords.chunkRuntime[chunkId] = getRuntimeKey(chunk.runtime);\n\t\t\t\t\t}\n\t\t\t\t\trecords.chunkModuleIds = {};\n\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\trecords.chunkModuleIds[/** @type {ChunkId} */ (chunk.id)] =\n\t\t\t\t\t\t\tArray.from(\n\t\t\t\t\t\t\t\tchunkGraph.getOrderedChunkModulesIterable(\n\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\tcompareModulesById(chunkGraph)\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tm => chunkGraph.getModuleId(m)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t/** @type {TupleSet<[Module, Chunk]>} */\n\t\t\t\tconst updatedModules = new TupleSet();\n\t\t\t\t/** @type {TupleSet<[Module, Chunk]>} */\n\t\t\t\tconst fullHashModules = new TupleSet();\n\t\t\t\t/** @type {TupleSet<[Module, RuntimeSpec]>} */\n\t\t\t\tconst nonCodeGeneratedModules = new TupleSet();\n\t\t\t\tcompilation.hooks.fullHash.tap(PLUGIN_NAME, hash => {\n\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\tconst records = compilation.records;\n\t\t\t\t\tfor (const chunk of compilation.chunks) {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {Module} module module\n\t\t\t\t\t\t * @returns {string} module hash\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst getModuleHash = module => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tcompilation.codeGenerationResults.has(module, chunk.runtime)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\treturn compilation.codeGenerationResults.getHash(\n\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\tchunk.runtime\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnonCodeGeneratedModules.add(module, chunk.runtime);\n\t\t\t\t\t\t\treturn chunkGraph.getModuleHash(module, chunk.runtime);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst fullHashModulesInThisChunk =\n\t\t\t\t\t\t\tchunkGraph.getChunkFullHashModulesSet(chunk);\n\t\t\t\t\t\tif (fullHashModulesInThisChunk !== undefined) {\n\t\t\t\t\t\t\tfor (const module of fullHashModulesInThisChunk) {\n\t\t\t\t\t\t\t\tfullHashModules.add(module, chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst modules = chunkGraph.getChunkModulesIterable(chunk);\n\t\t\t\t\t\tif (modules !== undefined) {\n\t\t\t\t\t\t\tif (records.chunkModuleHashes) {\n\t\t\t\t\t\t\t\tif (fullHashModulesInThisChunk !== undefined) {\n\t\t\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\t\t\tconst key = `${chunk.id}|${module.identifier()}`;\n\t\t\t\t\t\t\t\t\t\tconst hash = getModuleHash(module);\n\t\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t\tfullHashModulesInThisChunk.has(\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {RuntimeModule} */ (module)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\t\tif (records.fullHashChunkModuleHashes[key] !== hash) {\n\t\t\t\t\t\t\t\t\t\t\t\tupdatedModules.add(module, chunk);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tfullHashChunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\tif (records.chunkModuleHashes[key] !== hash) {\n\t\t\t\t\t\t\t\t\t\t\t\tupdatedModules.add(module, chunk);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tchunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\t\t\tconst key = `${chunk.id}|${module.identifier()}`;\n\t\t\t\t\t\t\t\t\t\tconst hash = getModuleHash(module);\n\t\t\t\t\t\t\t\t\t\tif (records.chunkModuleHashes[key] !== hash) {\n\t\t\t\t\t\t\t\t\t\t\tupdatedModules.add(module, chunk);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tchunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (fullHashModulesInThisChunk !== undefined) {\n\t\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\t\tconst key = `${chunk.id}|${module.identifier()}`;\n\t\t\t\t\t\t\t\t\tconst hash = getModuleHash(module);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tfullHashModulesInThisChunk.has(\n\t\t\t\t\t\t\t\t\t\t\t/** @type {RuntimeModule} */ (module)\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tfullHashChunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tchunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\t\tconst key = `${chunk.id}|${module.identifier()}`;\n\t\t\t\t\t\t\t\t\tconst hash = getModuleHash(module);\n\t\t\t\t\t\t\t\t\tchunkModuleHashes[key] = hash;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\thotIndex = records.hotIndex || 0;\n\t\t\t\t\tif (updatedModules.size > 0) hotIndex++;\n\n\t\t\t\t\thash.update(`${hotIndex}`);\n\t\t\t\t});\n\t\t\t\tcompilation.hooks.processAssets.tap(\n\t\t\t\t\t{\n\t\t\t\t\t\tname: PLUGIN_NAME,\n\t\t\t\t\t\tstage: Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\tconst chunkGraph = compilation.chunkGraph;\n\t\t\t\t\t\tconst records = compilation.records;\n\t\t\t\t\t\tif (records.hash === compilation.hash) return;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!records.chunkModuleHashes ||\n\t\t\t\t\t\t\t!records.chunkHashes ||\n\t\t\t\t\t\t\t!records.chunkModuleIds\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const [module, chunk] of fullHashModules) {\n\t\t\t\t\t\t\tconst key = `${chunk.id}|${module.identifier()}`;\n\t\t\t\t\t\t\tconst hash = nonCodeGeneratedModules.has(module, chunk.runtime)\n\t\t\t\t\t\t\t\t? chunkGraph.getModuleHash(module, chunk.runtime)\n\t\t\t\t\t\t\t\t: compilation.codeGenerationResults.getHash(\n\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\tchunk.runtime\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (records.chunkModuleHashes[key] !== hash) {\n\t\t\t\t\t\t\t\tupdatedModules.add(module, chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tchunkModuleHashes[key] = hash;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/** @type {HotUpdateMainContentByRuntime} */\n\t\t\t\t\t\tconst hotUpdateMainContentByRuntime = new Map();\n\t\t\t\t\t\tlet allOldRuntime;\n\t\t\t\t\t\tfor (const key of Object.keys(records.chunkRuntime)) {\n\t\t\t\t\t\t\tconst runtime = keyToRuntime(records.chunkRuntime[key]);\n\t\t\t\t\t\t\tallOldRuntime = mergeRuntimeOwned(allOldRuntime, runtime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tforEachRuntime(allOldRuntime, runtime => {\n\t\t\t\t\t\t\tconst { path: filename, info: assetInfo } =\n\t\t\t\t\t\t\t\tcompilation.getPathWithInfo(\n\t\t\t\t\t\t\t\t\t/** @type {NonNullable<OutputNormalized[\"hotUpdateMainFilename\"]>} */\n\t\t\t\t\t\t\t\t\t(compilation.outputOptions.hotUpdateMainFilename),\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\thash: records.hash,\n\t\t\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\thotUpdateMainContentByRuntime.set(\n\t\t\t\t\t\t\t\t/** @type {string} */ (runtime),\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tupdatedChunkIds: new Set(),\n\t\t\t\t\t\t\t\t\tremovedChunkIds: new Set(),\n\t\t\t\t\t\t\t\t\tremovedModules: new Set(),\n\t\t\t\t\t\t\t\t\tfilename,\n\t\t\t\t\t\t\t\t\tassetInfo\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tif (hotUpdateMainContentByRuntime.size === 0) return;\n\n\t\t\t\t\t\t// Create a list of all active modules to verify which modules are removed completely\n\t\t\t\t\t\t/** @type {Map<number|string, Module>} */\n\t\t\t\t\t\tconst allModules = new Map();\n\t\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t\tconst id =\n\t\t\t\t\t\t\t\t/** @type {ModuleId} */\n\t\t\t\t\t\t\t\t(chunkGraph.getModuleId(module));\n\t\t\t\t\t\t\tallModules.set(id, module);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// List of completely removed modules\n\t\t\t\t\t\t/** @type {Set<string | number>} */\n\t\t\t\t\t\tconst completelyRemovedModules = new Set();\n\n\t\t\t\t\t\tfor (const key of Object.keys(records.chunkHashes)) {\n\t\t\t\t\t\t\tconst oldRuntime = keyToRuntime(records.chunkRuntime[key]);\n\t\t\t\t\t\t\t/** @type {Module[]} */\n\t\t\t\t\t\t\tconst remainingModules = [];\n\t\t\t\t\t\t\t// Check which modules are removed\n\t\t\t\t\t\t\tfor (const id of records.chunkModuleIds[key]) {\n\t\t\t\t\t\t\t\tconst module = allModules.get(id);\n\t\t\t\t\t\t\t\tif (module === undefined) {\n\t\t\t\t\t\t\t\t\tcompletelyRemovedModules.add(id);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tremainingModules.push(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/** @type {ChunkId | null} */\n\t\t\t\t\t\t\tlet chunkId;\n\t\t\t\t\t\t\tlet newModules;\n\t\t\t\t\t\t\tlet newRuntimeModules;\n\t\t\t\t\t\t\tlet newFullHashModules;\n\t\t\t\t\t\t\tlet newDependentHashModules;\n\t\t\t\t\t\t\tlet newRuntime;\n\t\t\t\t\t\t\tlet removedFromRuntime;\n\t\t\t\t\t\t\tconst currentChunk = find(\n\t\t\t\t\t\t\t\tcompilation.chunks,\n\t\t\t\t\t\t\t\tchunk => `${chunk.id}` === key\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (currentChunk) {\n\t\t\t\t\t\t\t\tchunkId = currentChunk.id;\n\t\t\t\t\t\t\t\tnewRuntime = intersectRuntime(\n\t\t\t\t\t\t\t\t\tcurrentChunk.runtime,\n\t\t\t\t\t\t\t\t\tallOldRuntime\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (newRuntime === undefined) continue;\n\t\t\t\t\t\t\t\tnewModules = chunkGraph\n\t\t\t\t\t\t\t\t\t.getChunkModules(currentChunk)\n\t\t\t\t\t\t\t\t\t.filter(module => updatedModules.has(module, currentChunk));\n\t\t\t\t\t\t\t\tnewRuntimeModules = Array.from(\n\t\t\t\t\t\t\t\t\tchunkGraph.getChunkRuntimeModulesIterable(currentChunk)\n\t\t\t\t\t\t\t\t).filter(module => updatedModules.has(module, currentChunk));\n\t\t\t\t\t\t\t\tconst fullHashModules =\n\t\t\t\t\t\t\t\t\tchunkGraph.getChunkFullHashModulesIterable(currentChunk);\n\t\t\t\t\t\t\t\tnewFullHashModules =\n\t\t\t\t\t\t\t\t\tfullHashModules &&\n\t\t\t\t\t\t\t\t\tArray.from(fullHashModules).filter(module =>\n\t\t\t\t\t\t\t\t\t\tupdatedModules.has(module, currentChunk)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst dependentHashModules =\n\t\t\t\t\t\t\t\t\tchunkGraph.getChunkDependentHashModulesIterable(currentChunk);\n\t\t\t\t\t\t\t\tnewDependentHashModules =\n\t\t\t\t\t\t\t\t\tdependentHashModules &&\n\t\t\t\t\t\t\t\t\tArray.from(dependentHashModules).filter(module =>\n\t\t\t\t\t\t\t\t\t\tupdatedModules.has(module, currentChunk)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tremovedFromRuntime = subtractRuntime(oldRuntime, newRuntime);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// chunk has completely removed\n\t\t\t\t\t\t\t\tchunkId = `${Number(key)}` === key ? Number(key) : key;\n\t\t\t\t\t\t\t\tremovedFromRuntime = oldRuntime;\n\t\t\t\t\t\t\t\tnewRuntime = oldRuntime;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (removedFromRuntime) {\n\t\t\t\t\t\t\t\t// chunk was removed from some runtimes\n\t\t\t\t\t\t\t\tforEachRuntime(removedFromRuntime, runtime => {\n\t\t\t\t\t\t\t\t\tconst item =\n\t\t\t\t\t\t\t\t\t\t/** @type {HotUpdateMainContentByRuntimeItem} */\n\t\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\thotUpdateMainContentByRuntime.get(\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (runtime)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\titem.removedChunkIds.add(/** @type {ChunkId} */ (chunkId));\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t// dispose modules from the chunk in these runtimes\n\t\t\t\t\t\t\t\t// where they are no longer in this runtime\n\t\t\t\t\t\t\t\tfor (const module of remainingModules) {\n\t\t\t\t\t\t\t\t\tconst moduleKey = `${key}|${module.identifier()}`;\n\t\t\t\t\t\t\t\t\tconst oldHash = records.chunkModuleHashes[moduleKey];\n\t\t\t\t\t\t\t\t\tconst runtimes = chunkGraph.getModuleRuntimes(module);\n\t\t\t\t\t\t\t\t\tif (oldRuntime === newRuntime && runtimes.has(newRuntime)) {\n\t\t\t\t\t\t\t\t\t\t// Module is still in the same runtime combination\n\t\t\t\t\t\t\t\t\t\tconst hash = nonCodeGeneratedModules.has(module, newRuntime)\n\t\t\t\t\t\t\t\t\t\t\t? chunkGraph.getModuleHash(module, newRuntime)\n\t\t\t\t\t\t\t\t\t\t\t: compilation.codeGenerationResults.getHash(\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnewRuntime\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tif (hash !== oldHash) {\n\t\t\t\t\t\t\t\t\t\t\tif (module.type === WEBPACK_MODULE_TYPE_RUNTIME) {\n\t\t\t\t\t\t\t\t\t\t\t\tnewRuntimeModules = newRuntimeModules || [];\n\t\t\t\t\t\t\t\t\t\t\t\tnewRuntimeModules.push(\n\t\t\t\t\t\t\t\t\t\t\t\t\t/** @type {RuntimeModule} */ (module)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tnewModules = newModules || [];\n\t\t\t\t\t\t\t\t\t\t\t\tnewModules.push(module);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t// module is no longer in this runtime combination\n\t\t\t\t\t\t\t\t\t\t// We (incorrectly) assume that it's not in an overlapping runtime combination\n\t\t\t\t\t\t\t\t\t\t// and dispose it from the main runtimes the chunk was removed from\n\t\t\t\t\t\t\t\t\t\tforEachRuntime(removedFromRuntime, runtime => {\n\t\t\t\t\t\t\t\t\t\t\t// If the module is still used in this runtime, do not dispose it\n\t\t\t\t\t\t\t\t\t\t\t// This could create a bad runtime state where the module is still loaded,\n\t\t\t\t\t\t\t\t\t\t\t// but no chunk which contains it. This means we don't receive further HMR updates\n\t\t\t\t\t\t\t\t\t\t\t// to this module and that's bad.\n\t\t\t\t\t\t\t\t\t\t\t// TODO force load one of the chunks which contains the module\n\t\t\t\t\t\t\t\t\t\t\tfor (const moduleRuntime of runtimes) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (typeof moduleRuntime === \"string\") {\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (moduleRuntime === runtime) return;\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleRuntime !== undefined &&\n\t\t\t\t\t\t\t\t\t\t\t\t\tmoduleRuntime.has(/** @type {string} */ (runtime))\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tconst item =\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {HotUpdateMainContentByRuntimeItem} */ (\n\t\t\t\t\t\t\t\t\t\t\t\t\thotUpdateMainContentByRuntime.get(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (runtime)\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\titem.removedModules.add(module);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t(newModules && newModules.length > 0) ||\n\t\t\t\t\t\t\t\t(newRuntimeModules && newRuntimeModules.length > 0)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst hotUpdateChunk = new HotUpdateChunk();\n\t\t\t\t\t\t\t\tif (backCompat)\n\t\t\t\t\t\t\t\t\tChunkGraph.setChunkGraphForChunk(hotUpdateChunk, chunkGraph);\n\t\t\t\t\t\t\t\thotUpdateChunk.id = chunkId;\n\t\t\t\t\t\t\t\thotUpdateChunk.runtime = newRuntime;\n\t\t\t\t\t\t\t\tif (currentChunk) {\n\t\t\t\t\t\t\t\t\tfor (const group of currentChunk.groupsIterable)\n\t\t\t\t\t\t\t\t\t\thotUpdateChunk.addGroup(group);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchunkGraph.attachModules(hotUpdateChunk, newModules || []);\n\t\t\t\t\t\t\t\tchunkGraph.attachRuntimeModules(\n\t\t\t\t\t\t\t\t\thotUpdateChunk,\n\t\t\t\t\t\t\t\t\tnewRuntimeModules || []\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tif (newFullHashModules) {\n\t\t\t\t\t\t\t\t\tchunkGraph.attachFullHashModules(\n\t\t\t\t\t\t\t\t\t\thotUpdateChunk,\n\t\t\t\t\t\t\t\t\t\tnewFullHashModules\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (newDependentHashModules) {\n\t\t\t\t\t\t\t\t\tchunkGraph.attachDependentHashModules(\n\t\t\t\t\t\t\t\t\t\thotUpdateChunk,\n\t\t\t\t\t\t\t\t\t\tnewDependentHashModules\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst renderManifest = compilation.getRenderManifest({\n\t\t\t\t\t\t\t\t\tchunk: hotUpdateChunk,\n\t\t\t\t\t\t\t\t\thash: records.hash,\n\t\t\t\t\t\t\t\t\tfullHash: records.hash,\n\t\t\t\t\t\t\t\t\toutputOptions: compilation.outputOptions,\n\t\t\t\t\t\t\t\t\tmoduleTemplates: compilation.moduleTemplates,\n\t\t\t\t\t\t\t\t\tdependencyTemplates: compilation.dependencyTemplates,\n\t\t\t\t\t\t\t\t\tcodeGenerationResults: compilation.codeGenerationResults,\n\t\t\t\t\t\t\t\t\truntimeTemplate: compilation.runtimeTemplate,\n\t\t\t\t\t\t\t\t\tmoduleGraph: compilation.moduleGraph,\n\t\t\t\t\t\t\t\t\tchunkGraph\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tfor (const entry of renderManifest) {\n\t\t\t\t\t\t\t\t\t/** @type {string} */\n\t\t\t\t\t\t\t\t\tlet filename;\n\t\t\t\t\t\t\t\t\t/** @type {AssetInfo} */\n\t\t\t\t\t\t\t\t\tlet assetInfo;\n\t\t\t\t\t\t\t\t\tif (\"filename\" in entry) {\n\t\t\t\t\t\t\t\t\t\tfilename = entry.filename;\n\t\t\t\t\t\t\t\t\t\tassetInfo = entry.info;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t({ path: filename, info: assetInfo } =\n\t\t\t\t\t\t\t\t\t\t\tcompilation.getPathWithInfo(\n\t\t\t\t\t\t\t\t\t\t\t\tentry.filenameTemplate,\n\t\t\t\t\t\t\t\t\t\t\t\tentry.pathOptions\n\t\t\t\t\t\t\t\t\t\t\t));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst source = entry.render();\n\t\t\t\t\t\t\t\t\tcompilation.additionalChunkAssets.push(filename);\n\t\t\t\t\t\t\t\t\tcompilation.emitAsset(filename, source, {\n\t\t\t\t\t\t\t\t\t\thotModuleReplacement: true,\n\t\t\t\t\t\t\t\t\t\t...assetInfo\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tif (currentChunk) {\n\t\t\t\t\t\t\t\t\t\tcurrentChunk.files.add(filename);\n\t\t\t\t\t\t\t\t\t\tcompilation.hooks.chunkAsset.call(currentChunk, filename);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tforEachRuntime(newRuntime, runtime => {\n\t\t\t\t\t\t\t\t\tconst item =\n\t\t\t\t\t\t\t\t\t\t/** @type {HotUpdateMainContentByRuntimeItem} */ (\n\t\t\t\t\t\t\t\t\t\t\thotUpdateMainContentByRuntime.get(\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {string} */ (runtime)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\titem.updatedChunkIds.add(/** @type {ChunkId} */ (chunkId));\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst completelyRemovedModulesArray = Array.from(\n\t\t\t\t\t\t\tcompletelyRemovedModules\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst hotUpdateMainContentByFilename = new Map();\n\t\t\t\t\t\tfor (const {\n\t\t\t\t\t\t\tremovedChunkIds,\n\t\t\t\t\t\t\tremovedModules,\n\t\t\t\t\t\t\tupdatedChunkIds,\n\t\t\t\t\t\t\tfilename,\n\t\t\t\t\t\t\tassetInfo\n\t\t\t\t\t\t} of hotUpdateMainContentByRuntime.values()) {\n\t\t\t\t\t\t\tconst old = hotUpdateMainContentByFilename.get(filename);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\told &&\n\t\t\t\t\t\t\t\t(!isSubset(old.removedChunkIds, removedChunkIds) ||\n\t\t\t\t\t\t\t\t\t!isSubset(old.removedModules, removedModules) ||\n\t\t\t\t\t\t\t\t\t!isSubset(old.updatedChunkIds, updatedChunkIds))\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tcompilation.warnings.push(\n\t\t\t\t\t\t\t\t\tnew WebpackError(`HotModuleReplacementPlugin\nThe configured output.hotUpdateMainFilename doesn't lead to unique filenames per runtime and HMR update differs between runtimes.\nThis might lead to incorrect runtime behavior of the applied update.\nTo fix this, make sure to include [runtime] in the output.hotUpdateMainFilename option, or use the default config.`)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tfor (const chunkId of removedChunkIds)\n\t\t\t\t\t\t\t\t\told.removedChunkIds.add(chunkId);\n\t\t\t\t\t\t\t\tfor (const chunkId of removedModules)\n\t\t\t\t\t\t\t\t\told.removedModules.add(chunkId);\n\t\t\t\t\t\t\t\tfor (const chunkId of updatedChunkIds)\n\t\t\t\t\t\t\t\t\told.updatedChunkIds.add(chunkId);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thotUpdateMainContentByFilename.set(filename, {\n\t\t\t\t\t\t\t\tremovedChunkIds,\n\t\t\t\t\t\t\t\tremovedModules,\n\t\t\t\t\t\t\t\tupdatedChunkIds,\n\t\t\t\t\t\t\t\tassetInfo\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (const [\n\t\t\t\t\t\t\tfilename,\n\t\t\t\t\t\t\t{ removedChunkIds, removedModules, updatedChunkIds, assetInfo }\n\t\t\t\t\t\t] of hotUpdateMainContentByFilename) {\n\t\t\t\t\t\t\tconst hotUpdateMainJson = {\n\t\t\t\t\t\t\t\tc: Array.from(updatedChunkIds),\n\t\t\t\t\t\t\t\tr: Array.from(removedChunkIds),\n\t\t\t\t\t\t\t\tm:\n\t\t\t\t\t\t\t\t\tremovedModules.size === 0\n\t\t\t\t\t\t\t\t\t\t? completelyRemovedModulesArray\n\t\t\t\t\t\t\t\t\t\t: completelyRemovedModulesArray.concat(\n\t\t\t\t\t\t\t\t\t\t\t\tArray.from(\n\t\t\t\t\t\t\t\t\t\t\t\t\tremovedModules,\n\t\t\t\t\t\t\t\t\t\t\t\t\tm =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t/** @type {ModuleId} */ (chunkGraph.getModuleId(m))\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst source = new RawSource(JSON.stringify(hotUpdateMainJson));\n\t\t\t\t\t\t\tcompilation.emitAsset(filename, source, {\n\t\t\t\t\t\t\t\thotModuleReplacement: true,\n\t\t\t\t\t\t\t\t...assetInfo\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tcompilation.hooks.additionalTreeRuntimeRequirements.tap(\n\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\t(chunk, runtimeRequirements) => {\n\t\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.hmrDownloadManifest);\n\t\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.hmrDownloadUpdateHandlers);\n\t\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.interceptModuleExecution);\n\t\t\t\t\t\truntimeRequirements.add(RuntimeGlobals.moduleCache);\n\t\t\t\t\t\tcompilation.addRuntimeModule(\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tnew HotModuleReplacementRuntimeModule()\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_AUTO)\n\t\t\t\t\t.tap(PLUGIN_NAME, parser => {\n\t\t\t\t\t\tapplyModuleHot(parser);\n\t\t\t\t\t\tapplyImportMetaHot(parser);\n\t\t\t\t\t});\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_DYNAMIC)\n\t\t\t\t\t.tap(PLUGIN_NAME, parser => {\n\t\t\t\t\t\tapplyModuleHot(parser);\n\t\t\t\t\t});\n\t\t\t\tnormalModuleFactory.hooks.parser\n\t\t\t\t\t.for(JAVASCRIPT_MODULE_TYPE_ESM)\n\t\t\t\t\t.tap(PLUGIN_NAME, parser => {\n\t\t\t\t\t\tapplyImportMetaHot(parser);\n\t\t\t\t\t});\n\n\t\t\t\tNormalModule.getCompilationHooks(compilation).loader.tap(\n\t\t\t\t\tPLUGIN_NAME,\n\t\t\t\t\tcontext => {\n\t\t\t\t\t\tcontext.hot = true;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = HotModuleReplacementPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}