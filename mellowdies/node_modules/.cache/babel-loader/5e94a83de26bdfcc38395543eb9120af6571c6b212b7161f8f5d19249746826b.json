{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst EventEmitter = require(\"events\");\nconst {\n  extname,\n  basename\n} = require(\"path\");\nconst {\n  URL\n} = require(\"url\");\nconst {\n  createGunzip,\n  createBrotliDecompress,\n  createInflate\n} = require(\"zlib\");\nconst NormalModule = require(\"../NormalModule\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst createHash = require(\"../util/createHash\");\nconst {\n  mkdirp,\n  dirname,\n  join\n} = require(\"../util/fs\");\nconst memoize = require(\"../util/memoize\");\n\n/** @typedef {import(\"http\").IncomingMessage} IncomingMessage */\n/** @typedef {import(\"http\").RequestOptions} RequestOptions */\n/** @typedef {import(\"net\").Socket} Socket */\n/** @typedef {import(\"stream\").Readable} Readable */\n/** @typedef {import(\"../../declarations/plugins/schemes/HttpUriPlugin\").HttpUriPluginOptions} HttpUriPluginOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n/** @typedef {import(\"../Module\").BuildInfo} BuildInfo */\n/** @typedef {import(\"../NormalModuleFactory\").ResourceDataWithData} ResourceDataWithData */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\nconst getHttp = memoize(() => require(\"http\"));\nconst getHttps = memoize(() => require(\"https\"));\n\n/**\n * @param {typeof import(\"http\") | typeof import(\"https\")} request request\n * @param {string | { toString: () => string } | undefined} proxy proxy\n * @returns {function(URL, RequestOptions, function(IncomingMessage): void): EventEmitter} fn\n */\nconst proxyFetch = (request, proxy) => (url, options, callback) => {\n  const eventEmitter = new EventEmitter();\n\n  /**\n   * @param {Socket=} socket socket\n   * @returns {void}\n   */\n  const doRequest = socket => {\n    request.get(url, {\n      ...options,\n      ...(socket && {\n        socket\n      })\n    }, callback).on(\"error\", eventEmitter.emit.bind(eventEmitter, \"error\"));\n  };\n  if (proxy) {\n    const {\n      hostname: host,\n      port\n    } = new URL(proxy);\n    getHttp().request({\n      host,\n      // IP address of proxy server\n      port,\n      // port of proxy server\n      method: \"CONNECT\",\n      path: url.host\n    }).on(\"connect\", (res, socket) => {\n      if (res.statusCode === 200) {\n        // connected to proxy server\n        doRequest(socket);\n      }\n    }).on(\"error\", err => {\n      eventEmitter.emit(\"error\", new Error(`Failed to connect to proxy server \"${proxy}\": ${err.message}`));\n    }).end();\n  } else {\n    doRequest();\n  }\n  return eventEmitter;\n};\n\n/** @typedef {() => void} InProgressWriteItem */\n/** @type {InProgressWriteItem[] | undefined} */\nlet inProgressWrite;\nconst validate = createSchemaValidation(require(\"../../schemas/plugins/schemes/HttpUriPlugin.check.js\"), () => require(\"../../schemas/plugins/schemes/HttpUriPlugin.json\"), {\n  name: \"Http Uri Plugin\",\n  baseDataPath: \"options\"\n});\n\n/**\n * @param {string} str path\n * @returns {string} safe path\n */\nconst toSafePath = str => str.replace(/^[^a-zA-Z0-9]+|[^a-zA-Z0-9]+$/g, \"\").replace(/[^a-zA-Z0-9._-]+/g, \"_\");\n\n/**\n * @param {Buffer} content content\n * @returns {string} integrity\n */\nconst computeIntegrity = content => {\n  const hash = createHash(\"sha512\");\n  hash.update(content);\n  const integrity = `sha512-${hash.digest(\"base64\")}`;\n  return integrity;\n};\n\n/**\n * @param {Buffer} content content\n * @param {string} integrity integrity\n * @returns {boolean} true, if integrity matches\n */\nconst verifyIntegrity = (content, integrity) => {\n  if (integrity === \"ignore\") return true;\n  return computeIntegrity(content) === integrity;\n};\n\n/**\n * @param {string} str input\n * @returns {Record<string, string>} parsed\n */\nconst parseKeyValuePairs = str => {\n  /** @type {Record<string, string>} */\n  const result = {};\n  for (const item of str.split(\",\")) {\n    const i = item.indexOf(\"=\");\n    if (i >= 0) {\n      const key = item.slice(0, i).trim();\n      const value = item.slice(i + 1).trim();\n      result[key] = value;\n    } else {\n      const key = item.trim();\n      if (!key) continue;\n      result[key] = key;\n    }\n  }\n  return result;\n};\n\n/**\n * @param {string | undefined} cacheControl Cache-Control header\n * @param {number} requestTime timestamp of request\n * @returns {{storeCache: boolean, storeLock: boolean, validUntil: number}} Logic for storing in cache and lockfile cache\n */\nconst parseCacheControl = (cacheControl, requestTime) => {\n  // When false resource is not stored in cache\n  let storeCache = true;\n  // When false resource is not stored in lockfile cache\n  let storeLock = true;\n  // Resource is only revalidated, after that timestamp and when upgrade is chosen\n  let validUntil = 0;\n  if (cacheControl) {\n    const parsed = parseKeyValuePairs(cacheControl);\n    if (parsed[\"no-cache\"]) storeCache = storeLock = false;\n    if (parsed[\"max-age\"] && !Number.isNaN(Number(parsed[\"max-age\"]))) {\n      validUntil = requestTime + Number(parsed[\"max-age\"]) * 1000;\n    }\n    if (parsed[\"must-revalidate\"]) validUntil = 0;\n  }\n  return {\n    storeLock,\n    storeCache,\n    validUntil\n  };\n};\n\n/**\n * @typedef {object} LockfileEntry\n * @property {string} resolved\n * @property {string} integrity\n * @property {string} contentType\n */\n\n/**\n * @param {LockfileEntry} a first lockfile entry\n * @param {LockfileEntry} b second lockfile entry\n * @returns {boolean} true when equal, otherwise false\n */\nconst areLockfileEntriesEqual = (a, b) => a.resolved === b.resolved && a.integrity === b.integrity && a.contentType === b.contentType;\n\n/**\n * @param {LockfileEntry} entry lockfile entry\n * @returns {`resolved: ${string}, integrity: ${string}, contentType: ${*}`} stringified entry\n */\nconst entryToString = entry => `resolved: ${entry.resolved}, integrity: ${entry.integrity}, contentType: ${entry.contentType}`;\nclass Lockfile {\n  constructor() {\n    this.version = 1;\n    /** @type {Map<string, LockfileEntry | \"ignore\" | \"no-cache\">} */\n    this.entries = new Map();\n  }\n\n  /**\n   * @param {string} content content of the lockfile\n   * @returns {Lockfile} lockfile\n   */\n  static parse(content) {\n    // TODO handle merge conflicts\n    const data = JSON.parse(content);\n    if (data.version !== 1) throw new Error(`Unsupported lockfile version ${data.version}`);\n    const lockfile = new Lockfile();\n    for (const key of Object.keys(data)) {\n      if (key === \"version\") continue;\n      const entry = data[key];\n      lockfile.entries.set(key, typeof entry === \"string\" ? entry : {\n        resolved: key,\n        ...entry\n      });\n    }\n    return lockfile;\n  }\n\n  /**\n   * @returns {string} stringified lockfile\n   */\n  toString() {\n    let str = \"{\\n\";\n    const entries = Array.from(this.entries).sort(([a], [b]) => a < b ? -1 : 1);\n    for (const [key, entry] of entries) {\n      if (typeof entry === \"string\") {\n        str += `  ${JSON.stringify(key)}: ${JSON.stringify(entry)},\\n`;\n      } else {\n        str += `  ${JSON.stringify(key)}: { `;\n        if (entry.resolved !== key) str += `\"resolved\": ${JSON.stringify(entry.resolved)}, `;\n        str += `\"integrity\": ${JSON.stringify(entry.integrity)}, \"contentType\": ${JSON.stringify(entry.contentType)} },\\n`;\n      }\n    }\n    str += `  \"version\": ${this.version}\\n}\\n`;\n    return str;\n  }\n}\n\n/**\n * @template R\n * @param {function(function(Error | null, R=): void): void} fn function\n * @returns {function(function(Error | null, R=): void): void} cached function\n */\nconst cachedWithoutKey = fn => {\n  let inFlight = false;\n  /** @type {Error | undefined} */\n  let cachedError;\n  /** @type {R | undefined} */\n  let cachedResult;\n  /** @type {(function(Error| null, R=): void)[] | undefined} */\n  let cachedCallbacks;\n  return callback => {\n    if (inFlight) {\n      if (cachedResult !== undefined) return callback(null, cachedResult);\n      if (cachedError !== undefined) return callback(cachedError);\n      if (cachedCallbacks === undefined) cachedCallbacks = [callback];else cachedCallbacks.push(callback);\n      return;\n    }\n    inFlight = true;\n    fn((err, result) => {\n      if (err) cachedError = err;else cachedResult = result;\n      const callbacks = cachedCallbacks;\n      cachedCallbacks = undefined;\n      callback(err, result);\n      if (callbacks !== undefined) for (const cb of callbacks) cb(err, result);\n    });\n  };\n};\n\n/**\n * @template T\n * @template R\n * @param {function(T, function(Error | null, R=): void): void} fn function\n * @param {function(T, function(Error | null, R=): void): void=} forceFn function for the second try\n * @returns {(function(T, function(Error | null, R=): void): void) & { force: function(T, function(Error | null, R=): void): void }} cached function\n */\nconst cachedWithKey = (fn, forceFn = fn) => {\n  /**\n   * @template R\n   * @typedef {{ result?: R, error?: Error, callbacks?: (function(Error | null, R=): void)[], force?: true }} CacheEntry\n   */\n  /** @type {Map<T, CacheEntry<R>>} */\n  const cache = new Map();\n  /**\n   * @param {T} arg arg\n   * @param {function(Error | null, R=): void} callback callback\n   * @returns {void}\n   */\n  const resultFn = (arg, callback) => {\n    const cacheEntry = cache.get(arg);\n    if (cacheEntry !== undefined) {\n      if (cacheEntry.result !== undefined) return callback(null, cacheEntry.result);\n      if (cacheEntry.error !== undefined) return callback(cacheEntry.error);\n      if (cacheEntry.callbacks === undefined) cacheEntry.callbacks = [callback];else cacheEntry.callbacks.push(callback);\n      return;\n    }\n    /** @type {CacheEntry<R>} */\n    const newCacheEntry = {\n      result: undefined,\n      error: undefined,\n      callbacks: undefined\n    };\n    cache.set(arg, newCacheEntry);\n    fn(arg, (err, result) => {\n      if (err) newCacheEntry.error = err;else newCacheEntry.result = result;\n      const callbacks = newCacheEntry.callbacks;\n      newCacheEntry.callbacks = undefined;\n      callback(err, result);\n      if (callbacks !== undefined) for (const cb of callbacks) cb(err, result);\n    });\n  };\n  /**\n   * @param {T} arg arg\n   * @param {function(Error | null, R=): void} callback callback\n   * @returns {void}\n   */\n  resultFn.force = (arg, callback) => {\n    const cacheEntry = cache.get(arg);\n    if (cacheEntry !== undefined && cacheEntry.force) {\n      if (cacheEntry.result !== undefined) return callback(null, cacheEntry.result);\n      if (cacheEntry.error !== undefined) return callback(cacheEntry.error);\n      if (cacheEntry.callbacks === undefined) cacheEntry.callbacks = [callback];else cacheEntry.callbacks.push(callback);\n      return;\n    }\n    /** @type {CacheEntry<R>} */\n    const newCacheEntry = {\n      result: undefined,\n      error: undefined,\n      callbacks: undefined,\n      force: true\n    };\n    cache.set(arg, newCacheEntry);\n    forceFn(arg, (err, result) => {\n      if (err) newCacheEntry.error = err;else newCacheEntry.result = result;\n      const callbacks = newCacheEntry.callbacks;\n      newCacheEntry.callbacks = undefined;\n      callback(err, result);\n      if (callbacks !== undefined) for (const cb of callbacks) cb(err, result);\n    });\n  };\n  return resultFn;\n};\n\n/**\n * @typedef {object} LockfileCache\n * @property {Lockfile} lockfile lockfile\n * @property {Snapshot} snapshot snapshot\n */\n\n/**\n * @typedef {object} ResolveContentResult\n * @property {LockfileEntry} entry lockfile entry\n * @property {Buffer} content content\n * @property {boolean} storeLock need store lockfile\n */\n\n/** @typedef {{ storeCache: boolean, storeLock: boolean, validUntil: number, etag: string | undefined, fresh: boolean }} FetchResultMeta */\n/** @typedef {FetchResultMeta & { location: string }} RedirectFetchResult */\n/** @typedef {FetchResultMeta & { entry: LockfileEntry, content: Buffer }} ContentFetchResult */\n/** @typedef {RedirectFetchResult | ContentFetchResult} FetchResult */\n\nclass HttpUriPlugin {\n  /**\n   * @param {HttpUriPluginOptions} options options\n   */\n  constructor(options) {\n    validate(options);\n    this._lockfileLocation = options.lockfileLocation;\n    this._cacheLocation = options.cacheLocation;\n    this._upgrade = options.upgrade;\n    this._frozen = options.frozen;\n    this._allowedUris = options.allowedUris;\n    this._proxy = options.proxy;\n  }\n\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const proxy = this._proxy || process.env.http_proxy || process.env.HTTP_PROXY;\n    const schemes = [{\n      scheme: \"http\",\n      fetch: proxyFetch(getHttp(), proxy)\n    }, {\n      scheme: \"https\",\n      fetch: proxyFetch(getHttps(), proxy)\n    }];\n    /** @type {LockfileCache} */\n    let lockfileCache;\n    compiler.hooks.compilation.tap(\"HttpUriPlugin\", (compilation, {\n      normalModuleFactory\n    }) => {\n      const intermediateFs = /** @type {IntermediateFileSystem} */\n      compiler.intermediateFileSystem;\n      const fs = compilation.inputFileSystem;\n      const cache = compilation.getCache(\"webpack.HttpUriPlugin\");\n      const logger = compilation.getLogger(\"webpack.HttpUriPlugin\");\n      /** @type {string} */\n      const lockfileLocation = this._lockfileLocation || join(intermediateFs, compiler.context, compiler.name ? `${toSafePath(compiler.name)}.webpack.lock` : \"webpack.lock\");\n      /** @type {string | false} */\n      const cacheLocation = this._cacheLocation !== undefined ? this._cacheLocation : `${lockfileLocation}.data`;\n      const upgrade = this._upgrade || false;\n      const frozen = this._frozen || false;\n      const hashFunction = \"sha512\";\n      const hashDigest = \"hex\";\n      const hashDigestLength = 20;\n      const allowedUris = this._allowedUris;\n      let warnedAboutEol = false;\n\n      /** @type {Map<string, string>} */\n      const cacheKeyCache = new Map();\n      /**\n       * @param {string} url the url\n       * @returns {string} the key\n       */\n      const getCacheKey = url => {\n        const cachedResult = cacheKeyCache.get(url);\n        if (cachedResult !== undefined) return cachedResult;\n        const result = _getCacheKey(url);\n        cacheKeyCache.set(url, result);\n        return result;\n      };\n\n      /**\n       * @param {string} url the url\n       * @returns {string} the key\n       */\n      const _getCacheKey = url => {\n        const parsedUrl = new URL(url);\n        const folder = toSafePath(parsedUrl.origin);\n        const name = toSafePath(parsedUrl.pathname);\n        const query = toSafePath(parsedUrl.search);\n        let ext = extname(name);\n        if (ext.length > 20) ext = \"\";\n        const basename = ext ? name.slice(0, -ext.length) : name;\n        const hash = createHash(hashFunction);\n        hash.update(url);\n        const digest = hash.digest(hashDigest).slice(0, hashDigestLength);\n        return `${folder.slice(-50)}/${`${basename}${query ? `_${query}` : \"\"}`.slice(0, 150)}_${digest}${ext}`;\n      };\n      const getLockfile = cachedWithoutKey(\n      /**\n       * @param {function(Error | null, Lockfile=): void} callback callback\n       * @returns {void}\n       */\n      callback => {\n        const readLockfile = () => {\n          intermediateFs.readFile(lockfileLocation, (err, buffer) => {\n            if (err && err.code !== \"ENOENT\") {\n              compilation.missingDependencies.add(lockfileLocation);\n              return callback(err);\n            }\n            compilation.fileDependencies.add(lockfileLocation);\n            compilation.fileSystemInfo.createSnapshot(compiler.fsStartTime, buffer ? [lockfileLocation] : [], [], buffer ? [] : [lockfileLocation], {\n              timestamp: true\n            }, (err, s) => {\n              if (err) return callback(err);\n              const lockfile = buffer ? Lockfile.parse(buffer.toString(\"utf-8\")) : new Lockfile();\n              lockfileCache = {\n                lockfile,\n                snapshot: (/** @type {Snapshot} */s)\n              };\n              callback(null, lockfile);\n            });\n          });\n        };\n        if (lockfileCache) {\n          compilation.fileSystemInfo.checkSnapshotValid(lockfileCache.snapshot, (err, valid) => {\n            if (err) return callback(err);\n            if (!valid) return readLockfile();\n            callback(null, lockfileCache.lockfile);\n          });\n        } else {\n          readLockfile();\n        }\n      });\n\n      /** @typedef {Map<string, LockfileEntry | \"ignore\" | \"no-cache\">} LockfileUpdates */\n\n      /** @type {LockfileUpdates | undefined} */\n      let lockfileUpdates;\n\n      /**\n       * @param {Lockfile} lockfile lockfile instance\n       * @param {string} url url to store\n       * @param {LockfileEntry | \"ignore\" | \"no-cache\"} entry lockfile entry\n       */\n      const storeLockEntry = (lockfile, url, entry) => {\n        const oldEntry = lockfile.entries.get(url);\n        if (lockfileUpdates === undefined) lockfileUpdates = new Map();\n        lockfileUpdates.set(url, entry);\n        lockfile.entries.set(url, entry);\n        if (!oldEntry) {\n          logger.log(`${url} added to lockfile`);\n        } else if (typeof oldEntry === \"string\") {\n          if (typeof entry === \"string\") {\n            logger.log(`${url} updated in lockfile: ${oldEntry} -> ${entry}`);\n          } else {\n            logger.log(`${url} updated in lockfile: ${oldEntry} -> ${entry.resolved}`);\n          }\n        } else if (typeof entry === \"string\") {\n          logger.log(`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry}`);\n        } else if (oldEntry.resolved !== entry.resolved) {\n          logger.log(`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry.resolved}`);\n        } else if (oldEntry.integrity !== entry.integrity) {\n          logger.log(`${url} updated in lockfile: content changed`);\n        } else if (oldEntry.contentType !== entry.contentType) {\n          logger.log(`${url} updated in lockfile: ${oldEntry.contentType} -> ${entry.contentType}`);\n        } else {\n          logger.log(`${url} updated in lockfile`);\n        }\n      };\n\n      /**\n       * @param {Lockfile} lockfile lockfile\n       * @param {string} url url\n       * @param {ResolveContentResult} result result\n       * @param {function(Error | null, ResolveContentResult=): void} callback callback\n       * @returns {void}\n       */\n      const storeResult = (lockfile, url, result, callback) => {\n        if (result.storeLock) {\n          storeLockEntry(lockfile, url, result.entry);\n          if (!cacheLocation || !result.content) return callback(null, result);\n          const key = getCacheKey(result.entry.resolved);\n          const filePath = join(intermediateFs, cacheLocation, key);\n          mkdirp(intermediateFs, dirname(intermediateFs, filePath), err => {\n            if (err) return callback(err);\n            intermediateFs.writeFile(filePath, result.content, err => {\n              if (err) return callback(err);\n              callback(null, result);\n            });\n          });\n        } else {\n          storeLockEntry(lockfile, url, \"no-cache\");\n          callback(null, result);\n        }\n      };\n      for (const {\n        scheme,\n        fetch\n      } of schemes) {\n        /**\n         * @param {string} url URL\n         * @param {string | null} integrity integrity\n         * @param {function(Error | null, ResolveContentResult=): void} callback callback\n         */\n        const resolveContent = (url, integrity, callback) => {\n          /**\n           * @param {Error | null} err error\n           * @param {TODO} result result result\n           * @returns {void}\n           */\n          const handleResult = (err, result) => {\n            if (err) return callback(err);\n            if (\"location\" in result) {\n              return resolveContent(result.location, integrity, (err, innerResult) => {\n                if (err) return callback(err);\n                const {\n                  entry,\n                  content,\n                  storeLock\n                } = /** @type {ResolveContentResult} */innerResult;\n                callback(null, {\n                  entry,\n                  content,\n                  storeLock: storeLock && result.storeLock\n                });\n              });\n            }\n            if (!result.fresh && integrity && result.entry.integrity !== integrity && !verifyIntegrity(result.content, integrity)) {\n              return fetchContent.force(url, handleResult);\n            }\n            return callback(null, {\n              entry: result.entry,\n              content: result.content,\n              storeLock: result.storeLock\n            });\n          };\n          fetchContent(url, handleResult);\n        };\n\n        /**\n         * @param {string} url URL\n         * @param {FetchResult | RedirectFetchResult | undefined} cachedResult result from cache\n         * @param {function(Error | null, FetchResult=): void} callback callback\n         * @returns {void}\n         */\n        const fetchContentRaw = (url, cachedResult, callback) => {\n          const requestTime = Date.now();\n          fetch(new URL(url), {\n            headers: {\n              \"accept-encoding\": \"gzip, deflate, br\",\n              \"user-agent\": \"webpack\",\n              \"if-none-match\": (/** @type {TODO} */\n              cachedResult ? cachedResult.etag || null : null)\n            }\n          }, res => {\n            const etag = res.headers.etag;\n            const location = res.headers.location;\n            const cacheControl = res.headers[\"cache-control\"];\n            const {\n              storeLock,\n              storeCache,\n              validUntil\n            } = parseCacheControl(cacheControl, requestTime);\n            /**\n             * @param {Partial<Pick<FetchResultMeta, \"fresh\">> & (Pick<RedirectFetchResult, \"location\"> | Pick<ContentFetchResult, \"content\" | \"entry\">)} partialResult result\n             * @returns {void}\n             */\n            const finishWith = partialResult => {\n              if (\"location\" in partialResult) {\n                logger.debug(`GET ${url} [${res.statusCode}] -> ${partialResult.location}`);\n              } else {\n                logger.debug(`GET ${url} [${res.statusCode}] ${Math.ceil(partialResult.content.length / 1024)} kB${!storeLock ? \" no-cache\" : \"\"}`);\n              }\n              const result = {\n                ...partialResult,\n                fresh: true,\n                storeLock,\n                storeCache,\n                validUntil,\n                etag\n              };\n              if (!storeCache) {\n                logger.log(`${url} can't be stored in cache, due to Cache-Control header: ${cacheControl}`);\n                return callback(null, result);\n              }\n              cache.store(url, null, {\n                ...result,\n                fresh: false\n              }, err => {\n                if (err) {\n                  logger.warn(`${url} can't be stored in cache: ${err.message}`);\n                  logger.debug(err.stack);\n                }\n                callback(null, result);\n              });\n            };\n            if (res.statusCode === 304) {\n              const result = /** @type {FetchResult} */cachedResult;\n              if (result.validUntil < validUntil || result.storeLock !== storeLock || result.storeCache !== storeCache || result.etag !== etag) {\n                return finishWith(result);\n              }\n              logger.debug(`GET ${url} [${res.statusCode}] (unchanged)`);\n              return callback(null, {\n                ...result,\n                fresh: true\n              });\n            }\n            if (location && res.statusCode && res.statusCode >= 301 && res.statusCode <= 308) {\n              const result = {\n                location: new URL(location, url).href\n              };\n              if (!cachedResult || !(\"location\" in cachedResult) || cachedResult.location !== result.location || cachedResult.validUntil < validUntil || cachedResult.storeLock !== storeLock || cachedResult.storeCache !== storeCache || cachedResult.etag !== etag) {\n                return finishWith(result);\n              }\n              logger.debug(`GET ${url} [${res.statusCode}] (unchanged)`);\n              return callback(null, {\n                ...result,\n                fresh: true,\n                storeLock,\n                storeCache,\n                validUntil,\n                etag\n              });\n            }\n            const contentType = res.headers[\"content-type\"] || \"\";\n            /** @type {Buffer[]} */\n            const bufferArr = [];\n            const contentEncoding = res.headers[\"content-encoding\"];\n            /** @type {Readable} */\n            let stream = res;\n            if (contentEncoding === \"gzip\") {\n              stream = stream.pipe(createGunzip());\n            } else if (contentEncoding === \"br\") {\n              stream = stream.pipe(createBrotliDecompress());\n            } else if (contentEncoding === \"deflate\") {\n              stream = stream.pipe(createInflate());\n            }\n            stream.on(\"data\", chunk => {\n              bufferArr.push(chunk);\n            });\n            stream.on(\"end\", () => {\n              if (!res.complete) {\n                logger.log(`GET ${url} [${res.statusCode}] (terminated)`);\n                return callback(new Error(`${url} request was terminated`));\n              }\n              const content = Buffer.concat(bufferArr);\n              if (res.statusCode !== 200) {\n                logger.log(`GET ${url} [${res.statusCode}]`);\n                return callback(new Error(`${url} request status code = ${res.statusCode}\\n${content.toString(\"utf-8\")}`));\n              }\n              const integrity = computeIntegrity(content);\n              const entry = {\n                resolved: url,\n                integrity,\n                contentType\n              };\n              finishWith({\n                entry,\n                content\n              });\n            });\n          }).on(\"error\", err => {\n            logger.log(`GET ${url} (error)`);\n            err.message += `\\nwhile fetching ${url}`;\n            callback(err);\n          });\n        };\n        const fetchContent = cachedWithKey(\n        /**\n         * @param {string} url URL\n         * @param {function(Error | null, { validUntil: number, etag?: string, entry: LockfileEntry, content: Buffer, fresh: boolean } | { validUntil: number, etag?: string, location: string, fresh: boolean }=): void} callback callback\n         * @returns {void}\n         */\n        (url, callback) => {\n          cache.get(url, null, (err, cachedResult) => {\n            if (err) return callback(err);\n            if (cachedResult) {\n              const isValid = cachedResult.validUntil >= Date.now();\n              if (isValid) return callback(null, cachedResult);\n            }\n            fetchContentRaw(url, cachedResult, callback);\n          });\n        }, (url, callback) => fetchContentRaw(url, undefined, callback));\n\n        /**\n         * @param {string} uri uri\n         * @returns {boolean} true when allowed, otherwise false\n         */\n        const isAllowed = uri => {\n          for (const allowed of allowedUris) {\n            if (typeof allowed === \"string\") {\n              if (uri.startsWith(allowed)) return true;\n            } else if (typeof allowed === \"function\") {\n              if (allowed(uri)) return true;\n            } else if (allowed.test(uri)) {\n              return true;\n            }\n          }\n          return false;\n        };\n\n        /** @typedef {{ entry: LockfileEntry, content: Buffer }} Info */\n\n        const getInfo = cachedWithKey(\n        /**\n         * @param {string} url the url\n         * @param {function(Error | null, Info=): void} callback callback\n         * @returns {void}\n         */\n        // eslint-disable-next-line no-loop-func\n        (url, callback) => {\n          if (!isAllowed(url)) {\n            return callback(new Error(`${url} doesn't match the allowedUris policy. These URIs are allowed:\\n${allowedUris.map(uri => ` - ${uri}`).join(\"\\n\")}`));\n          }\n          getLockfile((err, _lockfile) => {\n            if (err) return callback(err);\n            const lockfile = /** @type {Lockfile} */_lockfile;\n            const entryOrString = lockfile.entries.get(url);\n            if (!entryOrString) {\n              if (frozen) {\n                return callback(new Error(`${url} has no lockfile entry and lockfile is frozen`));\n              }\n              resolveContent(url, null, (err, result) => {\n                if (err) return callback(err);\n                storeResult(/** @type {Lockfile} */\n                lockfile, url, /** @type {ResolveContentResult} */\n                result, callback);\n              });\n              return;\n            }\n            if (typeof entryOrString === \"string\") {\n              const entryTag = entryOrString;\n              resolveContent(url, null, (err, _result) => {\n                if (err) return callback(err);\n                const result = /** @type {ResolveContentResult} */\n                _result;\n                if (!result.storeLock || entryTag === \"ignore\") return callback(null, result);\n                if (frozen) {\n                  return callback(new Error(`${url} used to have ${entryTag} lockfile entry and has content now, but lockfile is frozen`));\n                }\n                if (!upgrade) {\n                  return callback(new Error(`${url} used to have ${entryTag} lockfile entry and has content now.\nThis should be reflected in the lockfile, so this lockfile entry must be upgraded, but upgrading is not enabled.\nRemove this line from the lockfile to force upgrading.`));\n                }\n                storeResult(lockfile, url, result, callback);\n              });\n              return;\n            }\n            let entry = entryOrString;\n            /**\n             * @param {Buffer=} lockedContent locked content\n             */\n            const doFetch = lockedContent => {\n              resolveContent(url, entry.integrity, (err, _result) => {\n                if (err) {\n                  if (lockedContent) {\n                    logger.warn(`Upgrade request to ${url} failed: ${err.message}`);\n                    logger.debug(err.stack);\n                    return callback(null, {\n                      entry,\n                      content: lockedContent\n                    });\n                  }\n                  return callback(err);\n                }\n                const result = /** @type {ResolveContentResult} */\n                _result;\n                if (!result.storeLock) {\n                  // When the lockfile entry should be no-cache\n                  // we need to update the lockfile\n                  if (frozen) {\n                    return callback(new Error(`${url} has a lockfile entry and is no-cache now, but lockfile is frozen\\nLockfile: ${entryToString(entry)}`));\n                  }\n                  storeResult(lockfile, url, result, callback);\n                  return;\n                }\n                if (!areLockfileEntriesEqual(result.entry, entry)) {\n                  // When the lockfile entry is outdated\n                  // we need to update the lockfile\n                  if (frozen) {\n                    return callback(new Error(`${url} has an outdated lockfile entry, but lockfile is frozen\\nLockfile: ${entryToString(entry)}\\nExpected: ${entryToString(result.entry)}`));\n                  }\n                  storeResult(lockfile, url, result, callback);\n                  return;\n                }\n                if (!lockedContent && cacheLocation) {\n                  // When the lockfile cache content is missing\n                  // we need to update the lockfile\n                  if (frozen) {\n                    return callback(new Error(`${url} is missing content in the lockfile cache, but lockfile is frozen\\nLockfile: ${entryToString(entry)}`));\n                  }\n                  storeResult(lockfile, url, result, callback);\n                  return;\n                }\n                return callback(null, result);\n              });\n            };\n            if (cacheLocation) {\n              // When there is a lockfile cache\n              // we read the content from there\n              const key = getCacheKey(entry.resolved);\n              const filePath = join(intermediateFs, cacheLocation, key);\n              fs.readFile(filePath, (err, result) => {\n                if (err) {\n                  if (err.code === \"ENOENT\") return doFetch();\n                  return callback(err);\n                }\n                const content = /** @type {Buffer} */result;\n                /**\n                 * @param {Buffer | undefined} _result result\n                 * @returns {void}\n                 */\n                const continueWithCachedContent = _result => {\n                  if (!upgrade) {\n                    // When not in upgrade mode, we accept the result from the lockfile cache\n                    return callback(null, {\n                      entry,\n                      content\n                    });\n                  }\n                  return doFetch(content);\n                };\n                if (!verifyIntegrity(content, entry.integrity)) {\n                  /** @type {Buffer | undefined} */\n                  let contentWithChangedEol;\n                  let isEolChanged = false;\n                  try {\n                    contentWithChangedEol = Buffer.from(content.toString(\"utf-8\").replace(/\\r\\n/g, \"\\n\"));\n                    isEolChanged = verifyIntegrity(contentWithChangedEol, entry.integrity);\n                  } catch (_err) {\n                    // ignore\n                  }\n                  if (isEolChanged) {\n                    if (!warnedAboutEol) {\n                      const explainer = `Incorrect end of line sequence was detected in the lockfile cache.\nThe lockfile cache is protected by integrity checks, so any external modification will lead to a corrupted lockfile cache.\nWhen using git make sure to configure .gitattributes correctly for the lockfile cache:\n  **/*webpack.lock.data/** -text\nThis will avoid that the end of line sequence is changed by git on Windows.`;\n                      if (frozen) {\n                        logger.error(explainer);\n                      } else {\n                        logger.warn(explainer);\n                        logger.info(\"Lockfile cache will be automatically fixed now, but when lockfile is frozen this would result in an error.\");\n                      }\n                      warnedAboutEol = true;\n                    }\n                    if (!frozen) {\n                      // \"fix\" the end of line sequence of the lockfile content\n                      logger.log(`${filePath} fixed end of line sequence (\\\\r\\\\n instead of \\\\n).`);\n                      intermediateFs.writeFile(filePath, /** @type {Buffer} */\n                      contentWithChangedEol, err => {\n                        if (err) return callback(err);\n                        continueWithCachedContent(/** @type {Buffer} */\n                        contentWithChangedEol);\n                      });\n                      return;\n                    }\n                  }\n                  if (frozen) {\n                    return callback(new Error(`${entry.resolved} integrity mismatch, expected content with integrity ${entry.integrity} but got ${computeIntegrity(content)}.\nLockfile corrupted (${isEolChanged ? \"end of line sequence was unexpectedly changed\" : \"incorrectly merged? changed by other tools?\"}).\nRun build with un-frozen lockfile to automatically fix lockfile.`));\n                  }\n                  // \"fix\" the lockfile entry to the correct integrity\n                  // the content has priority over the integrity value\n                  entry = {\n                    ...entry,\n                    integrity: computeIntegrity(content)\n                  };\n                  storeLockEntry(lockfile, url, entry);\n                }\n                continueWithCachedContent(result);\n              });\n            } else {\n              doFetch();\n            }\n          });\n        });\n\n        /**\n         * @param {URL} url url\n         * @param {ResourceDataWithData} resourceData resource data\n         * @param {function(Error | null, true | void): void} callback callback\n         */\n        const respondWithUrlModule = (url, resourceData, callback) => {\n          getInfo(url.href, (err, _result) => {\n            if (err) return callback(err);\n            const result = /** @type {Info} */_result;\n            resourceData.resource = url.href;\n            resourceData.path = url.origin + url.pathname;\n            resourceData.query = url.search;\n            resourceData.fragment = url.hash;\n            resourceData.context = new URL(\".\", result.entry.resolved).href.slice(0, -1);\n            resourceData.data.mimetype = result.entry.contentType;\n            callback(null, true);\n          });\n        };\n        normalModuleFactory.hooks.resolveForScheme.for(scheme).tapAsync(\"HttpUriPlugin\", (resourceData, resolveData, callback) => {\n          respondWithUrlModule(new URL(resourceData.resource), resourceData, callback);\n        });\n        normalModuleFactory.hooks.resolveInScheme.for(scheme).tapAsync(\"HttpUriPlugin\", (resourceData, data, callback) => {\n          // Only handle relative urls (./xxx, ../xxx, /xxx, //xxx)\n          if (data.dependencyType !== \"url\" && !/^\\.{0,2}\\//.test(resourceData.resource)) {\n            return callback();\n          }\n          respondWithUrlModule(new URL(resourceData.resource, `${data.context}/`), resourceData, callback);\n        });\n        const hooks = NormalModule.getCompilationHooks(compilation);\n        hooks.readResourceForScheme.for(scheme).tapAsync(\"HttpUriPlugin\", (resource, module, callback) => getInfo(resource, (err, _result) => {\n          if (err) return callback(err);\n          const result = /** @type {Info} */_result;\n          /** @type {BuildInfo} */\n          module.buildInfo.resourceIntegrity = result.entry.integrity;\n          callback(null, result.content);\n        }));\n        hooks.needBuild.tapAsync(\"HttpUriPlugin\", (module, context, callback) => {\n          if (module.resource && module.resource.startsWith(`${scheme}://`)) {\n            getInfo(module.resource, (err, _result) => {\n              if (err) return callback(err);\n              const result = /** @type {Info} */_result;\n              if (result.entry.integrity !== /** @type {BuildInfo} */\n              module.buildInfo.resourceIntegrity) {\n                return callback(null, true);\n              }\n              callback();\n            });\n          } else {\n            return callback();\n          }\n        });\n      }\n      compilation.hooks.finishModules.tapAsync(\"HttpUriPlugin\", (modules, callback) => {\n        if (!lockfileUpdates) return callback();\n        const ext = extname(lockfileLocation);\n        const tempFile = join(intermediateFs, dirname(intermediateFs, lockfileLocation), `.${basename(lockfileLocation, ext)}.${Math.random() * 10000 | 0}${ext}`);\n        const writeDone = () => {\n          const nextOperation = /** @type {InProgressWriteItem[]} */\n          inProgressWrite.shift();\n          if (nextOperation) {\n            nextOperation();\n          } else {\n            inProgressWrite = undefined;\n          }\n        };\n        const runWrite = () => {\n          intermediateFs.readFile(lockfileLocation, (err, buffer) => {\n            if (err && err.code !== \"ENOENT\") {\n              writeDone();\n              return callback(err);\n            }\n            const lockfile = buffer ? Lockfile.parse(buffer.toString(\"utf-8\")) : new Lockfile();\n            for (const [key, value] of (/** @type {LockfileUpdates} */\n            lockfileUpdates)) {\n              lockfile.entries.set(key, value);\n            }\n            intermediateFs.writeFile(tempFile, lockfile.toString(), err => {\n              if (err) {\n                writeDone();\n                return /** @type {NonNullable<IntermediateFileSystem[\"unlink\"]>} */(\n                  intermediateFs.unlink(tempFile, () => callback(err))\n                );\n              }\n              intermediateFs.rename(tempFile, lockfileLocation, err => {\n                if (err) {\n                  writeDone();\n                  return /** @type {NonNullable<IntermediateFileSystem[\"unlink\"]>} */(\n                    intermediateFs.unlink(tempFile, () => callback(err))\n                  );\n                }\n                writeDone();\n                callback();\n              });\n            });\n          });\n        };\n        if (inProgressWrite) {\n          inProgressWrite.push(runWrite);\n        } else {\n          inProgressWrite = [];\n          runWrite();\n        }\n      });\n    });\n  }\n}\nmodule.exports = HttpUriPlugin;","map":{"version":3,"names":["EventEmitter","require","extname","basename","URL","createGunzip","createBrotliDecompress","createInflate","NormalModule","createSchemaValidation","createHash","mkdirp","dirname","join","memoize","getHttp","getHttps","proxyFetch","request","proxy","url","options","callback","eventEmitter","doRequest","socket","get","on","emit","bind","hostname","host","port","method","path","res","statusCode","err","Error","message","end","inProgressWrite","validate","name","baseDataPath","toSafePath","str","replace","computeIntegrity","content","hash","update","integrity","digest","verifyIntegrity","parseKeyValuePairs","result","item","split","i","indexOf","key","slice","trim","value","parseCacheControl","cacheControl","requestTime","storeCache","storeLock","validUntil","parsed","Number","isNaN","areLockfileEntriesEqual","a","b","resolved","contentType","entryToString","entry","Lockfile","constructor","version","entries","Map","parse","data","JSON","lockfile","Object","keys","set","toString","Array","from","sort","stringify","cachedWithoutKey","fn","inFlight","cachedError","cachedResult","cachedCallbacks","undefined","push","callbacks","cb","cachedWithKey","forceFn","cache","resultFn","arg","cacheEntry","error","newCacheEntry","force","HttpUriPlugin","_lockfileLocation","lockfileLocation","_cacheLocation","cacheLocation","_upgrade","upgrade","_frozen","frozen","_allowedUris","allowedUris","_proxy","apply","compiler","process","env","http_proxy","HTTP_PROXY","schemes","scheme","fetch","lockfileCache","hooks","compilation","tap","normalModuleFactory","intermediateFs","intermediateFileSystem","fs","inputFileSystem","getCache","logger","getLogger","context","hashFunction","hashDigest","hashDigestLength","warnedAboutEol","cacheKeyCache","getCacheKey","_getCacheKey","parsedUrl","folder","origin","pathname","query","search","ext","length","getLockfile","readLockfile","readFile","buffer","code","missingDependencies","add","fileDependencies","fileSystemInfo","createSnapshot","fsStartTime","timestamp","s","snapshot","checkSnapshotValid","valid","lockfileUpdates","storeLockEntry","oldEntry","log","storeResult","filePath","writeFile","resolveContent","handleResult","location","innerResult","fresh","fetchContent","fetchContentRaw","Date","now","headers","etag","finishWith","partialResult","debug","Math","ceil","store","warn","stack","href","bufferArr","contentEncoding","stream","pipe","chunk","complete","Buffer","concat","isValid","isAllowed","uri","allowed","startsWith","test","getInfo","map","_lockfile","entryOrString","entryTag","_result","doFetch","lockedContent","continueWithCachedContent","contentWithChangedEol","isEolChanged","_err","explainer","info","respondWithUrlModule","resourceData","resource","fragment","mimetype","resolveForScheme","for","tapAsync","resolveData","resolveInScheme","dependencyType","getCompilationHooks","readResourceForScheme","module","buildInfo","resourceIntegrity","needBuild","finishModules","modules","tempFile","random","writeDone","nextOperation","shift","runWrite","unlink","rename","exports"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/webpack/lib/schemes/HttpUriPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst EventEmitter = require(\"events\");\nconst { extname, basename } = require(\"path\");\nconst { URL } = require(\"url\");\nconst { createGunzip, createBrotliDecompress, createInflate } = require(\"zlib\");\nconst NormalModule = require(\"../NormalModule\");\nconst createSchemaValidation = require(\"../util/create-schema-validation\");\nconst createHash = require(\"../util/createHash\");\nconst { mkdirp, dirname, join } = require(\"../util/fs\");\nconst memoize = require(\"../util/memoize\");\n\n/** @typedef {import(\"http\").IncomingMessage} IncomingMessage */\n/** @typedef {import(\"http\").RequestOptions} RequestOptions */\n/** @typedef {import(\"net\").Socket} Socket */\n/** @typedef {import(\"stream\").Readable} Readable */\n/** @typedef {import(\"../../declarations/plugins/schemes/HttpUriPlugin\").HttpUriPluginOptions} HttpUriPluginOptions */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../FileSystemInfo\").Snapshot} Snapshot */\n/** @typedef {import(\"../Module\").BuildInfo} BuildInfo */\n/** @typedef {import(\"../NormalModuleFactory\").ResourceDataWithData} ResourceDataWithData */\n/** @typedef {import(\"../util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n\nconst getHttp = memoize(() => require(\"http\"));\nconst getHttps = memoize(() => require(\"https\"));\n\n/**\n * @param {typeof import(\"http\") | typeof import(\"https\")} request request\n * @param {string | { toString: () => string } | undefined} proxy proxy\n * @returns {function(URL, RequestOptions, function(IncomingMessage): void): EventEmitter} fn\n */\nconst proxyFetch = (request, proxy) => (url, options, callback) => {\n\tconst eventEmitter = new EventEmitter();\n\n\t/**\n\t * @param {Socket=} socket socket\n\t * @returns {void}\n\t */\n\tconst doRequest = socket => {\n\t\trequest\n\t\t\t.get(url, { ...options, ...(socket && { socket }) }, callback)\n\t\t\t.on(\"error\", eventEmitter.emit.bind(eventEmitter, \"error\"));\n\t};\n\n\tif (proxy) {\n\t\tconst { hostname: host, port } = new URL(proxy);\n\n\t\tgetHttp()\n\t\t\t.request({\n\t\t\t\thost, // IP address of proxy server\n\t\t\t\tport, // port of proxy server\n\t\t\t\tmethod: \"CONNECT\",\n\t\t\t\tpath: url.host\n\t\t\t})\n\t\t\t.on(\"connect\", (res, socket) => {\n\t\t\t\tif (res.statusCode === 200) {\n\t\t\t\t\t// connected to proxy server\n\t\t\t\t\tdoRequest(socket);\n\t\t\t\t}\n\t\t\t})\n\t\t\t.on(\"error\", err => {\n\t\t\t\teventEmitter.emit(\n\t\t\t\t\t\"error\",\n\t\t\t\t\tnew Error(\n\t\t\t\t\t\t`Failed to connect to proxy server \"${proxy}\": ${err.message}`\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t})\n\t\t\t.end();\n\t} else {\n\t\tdoRequest();\n\t}\n\n\treturn eventEmitter;\n};\n\n/** @typedef {() => void} InProgressWriteItem */\n/** @type {InProgressWriteItem[] | undefined} */\nlet inProgressWrite;\n\nconst validate = createSchemaValidation(\n\trequire(\"../../schemas/plugins/schemes/HttpUriPlugin.check.js\"),\n\t() => require(\"../../schemas/plugins/schemes/HttpUriPlugin.json\"),\n\t{\n\t\tname: \"Http Uri Plugin\",\n\t\tbaseDataPath: \"options\"\n\t}\n);\n\n/**\n * @param {string} str path\n * @returns {string} safe path\n */\nconst toSafePath = str =>\n\tstr\n\t\t.replace(/^[^a-zA-Z0-9]+|[^a-zA-Z0-9]+$/g, \"\")\n\t\t.replace(/[^a-zA-Z0-9._-]+/g, \"_\");\n\n/**\n * @param {Buffer} content content\n * @returns {string} integrity\n */\nconst computeIntegrity = content => {\n\tconst hash = createHash(\"sha512\");\n\thash.update(content);\n\tconst integrity = `sha512-${hash.digest(\"base64\")}`;\n\treturn integrity;\n};\n\n/**\n * @param {Buffer} content content\n * @param {string} integrity integrity\n * @returns {boolean} true, if integrity matches\n */\nconst verifyIntegrity = (content, integrity) => {\n\tif (integrity === \"ignore\") return true;\n\treturn computeIntegrity(content) === integrity;\n};\n\n/**\n * @param {string} str input\n * @returns {Record<string, string>} parsed\n */\nconst parseKeyValuePairs = str => {\n\t/** @type {Record<string, string>} */\n\tconst result = {};\n\tfor (const item of str.split(\",\")) {\n\t\tconst i = item.indexOf(\"=\");\n\t\tif (i >= 0) {\n\t\t\tconst key = item.slice(0, i).trim();\n\t\t\tconst value = item.slice(i + 1).trim();\n\t\t\tresult[key] = value;\n\t\t} else {\n\t\t\tconst key = item.trim();\n\t\t\tif (!key) continue;\n\t\t\tresult[key] = key;\n\t\t}\n\t}\n\treturn result;\n};\n\n/**\n * @param {string | undefined} cacheControl Cache-Control header\n * @param {number} requestTime timestamp of request\n * @returns {{storeCache: boolean, storeLock: boolean, validUntil: number}} Logic for storing in cache and lockfile cache\n */\nconst parseCacheControl = (cacheControl, requestTime) => {\n\t// When false resource is not stored in cache\n\tlet storeCache = true;\n\t// When false resource is not stored in lockfile cache\n\tlet storeLock = true;\n\t// Resource is only revalidated, after that timestamp and when upgrade is chosen\n\tlet validUntil = 0;\n\tif (cacheControl) {\n\t\tconst parsed = parseKeyValuePairs(cacheControl);\n\t\tif (parsed[\"no-cache\"]) storeCache = storeLock = false;\n\t\tif (parsed[\"max-age\"] && !Number.isNaN(Number(parsed[\"max-age\"]))) {\n\t\t\tvalidUntil = requestTime + Number(parsed[\"max-age\"]) * 1000;\n\t\t}\n\t\tif (parsed[\"must-revalidate\"]) validUntil = 0;\n\t}\n\treturn {\n\t\tstoreLock,\n\t\tstoreCache,\n\t\tvalidUntil\n\t};\n};\n\n/**\n * @typedef {object} LockfileEntry\n * @property {string} resolved\n * @property {string} integrity\n * @property {string} contentType\n */\n\n/**\n * @param {LockfileEntry} a first lockfile entry\n * @param {LockfileEntry} b second lockfile entry\n * @returns {boolean} true when equal, otherwise false\n */\nconst areLockfileEntriesEqual = (a, b) =>\n\ta.resolved === b.resolved &&\n\ta.integrity === b.integrity &&\n\ta.contentType === b.contentType;\n\n/**\n * @param {LockfileEntry} entry lockfile entry\n * @returns {`resolved: ${string}, integrity: ${string}, contentType: ${*}`} stringified entry\n */\nconst entryToString = entry =>\n\t`resolved: ${entry.resolved}, integrity: ${entry.integrity}, contentType: ${entry.contentType}`;\n\nclass Lockfile {\n\tconstructor() {\n\t\tthis.version = 1;\n\t\t/** @type {Map<string, LockfileEntry | \"ignore\" | \"no-cache\">} */\n\t\tthis.entries = new Map();\n\t}\n\n\t/**\n\t * @param {string} content content of the lockfile\n\t * @returns {Lockfile} lockfile\n\t */\n\tstatic parse(content) {\n\t\t// TODO handle merge conflicts\n\t\tconst data = JSON.parse(content);\n\t\tif (data.version !== 1)\n\t\t\tthrow new Error(`Unsupported lockfile version ${data.version}`);\n\t\tconst lockfile = new Lockfile();\n\t\tfor (const key of Object.keys(data)) {\n\t\t\tif (key === \"version\") continue;\n\t\t\tconst entry = data[key];\n\t\t\tlockfile.entries.set(\n\t\t\t\tkey,\n\t\t\t\ttypeof entry === \"string\"\n\t\t\t\t\t? entry\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tresolved: key,\n\t\t\t\t\t\t\t...entry\n\t\t\t\t\t\t}\n\t\t\t);\n\t\t}\n\t\treturn lockfile;\n\t}\n\n\t/**\n\t * @returns {string} stringified lockfile\n\t */\n\ttoString() {\n\t\tlet str = \"{\\n\";\n\t\tconst entries = Array.from(this.entries).sort(([a], [b]) =>\n\t\t\ta < b ? -1 : 1\n\t\t);\n\t\tfor (const [key, entry] of entries) {\n\t\t\tif (typeof entry === \"string\") {\n\t\t\t\tstr += `  ${JSON.stringify(key)}: ${JSON.stringify(entry)},\\n`;\n\t\t\t} else {\n\t\t\t\tstr += `  ${JSON.stringify(key)}: { `;\n\t\t\t\tif (entry.resolved !== key)\n\t\t\t\t\tstr += `\"resolved\": ${JSON.stringify(entry.resolved)}, `;\n\t\t\t\tstr += `\"integrity\": ${JSON.stringify(\n\t\t\t\t\tentry.integrity\n\t\t\t\t)}, \"contentType\": ${JSON.stringify(entry.contentType)} },\\n`;\n\t\t\t}\n\t\t}\n\t\tstr += `  \"version\": ${this.version}\\n}\\n`;\n\t\treturn str;\n\t}\n}\n\n/**\n * @template R\n * @param {function(function(Error | null, R=): void): void} fn function\n * @returns {function(function(Error | null, R=): void): void} cached function\n */\nconst cachedWithoutKey = fn => {\n\tlet inFlight = false;\n\t/** @type {Error | undefined} */\n\tlet cachedError;\n\t/** @type {R | undefined} */\n\tlet cachedResult;\n\t/** @type {(function(Error| null, R=): void)[] | undefined} */\n\tlet cachedCallbacks;\n\treturn callback => {\n\t\tif (inFlight) {\n\t\t\tif (cachedResult !== undefined) return callback(null, cachedResult);\n\t\t\tif (cachedError !== undefined) return callback(cachedError);\n\t\t\tif (cachedCallbacks === undefined) cachedCallbacks = [callback];\n\t\t\telse cachedCallbacks.push(callback);\n\t\t\treturn;\n\t\t}\n\t\tinFlight = true;\n\t\tfn((err, result) => {\n\t\t\tif (err) cachedError = err;\n\t\t\telse cachedResult = result;\n\t\t\tconst callbacks = cachedCallbacks;\n\t\t\tcachedCallbacks = undefined;\n\t\t\tcallback(err, result);\n\t\t\tif (callbacks !== undefined) for (const cb of callbacks) cb(err, result);\n\t\t});\n\t};\n};\n\n/**\n * @template T\n * @template R\n * @param {function(T, function(Error | null, R=): void): void} fn function\n * @param {function(T, function(Error | null, R=): void): void=} forceFn function for the second try\n * @returns {(function(T, function(Error | null, R=): void): void) & { force: function(T, function(Error | null, R=): void): void }} cached function\n */\nconst cachedWithKey = (fn, forceFn = fn) => {\n\t/**\n\t * @template R\n\t * @typedef {{ result?: R, error?: Error, callbacks?: (function(Error | null, R=): void)[], force?: true }} CacheEntry\n\t */\n\t/** @type {Map<T, CacheEntry<R>>} */\n\tconst cache = new Map();\n\t/**\n\t * @param {T} arg arg\n\t * @param {function(Error | null, R=): void} callback callback\n\t * @returns {void}\n\t */\n\tconst resultFn = (arg, callback) => {\n\t\tconst cacheEntry = cache.get(arg);\n\t\tif (cacheEntry !== undefined) {\n\t\t\tif (cacheEntry.result !== undefined)\n\t\t\t\treturn callback(null, cacheEntry.result);\n\t\t\tif (cacheEntry.error !== undefined) return callback(cacheEntry.error);\n\t\t\tif (cacheEntry.callbacks === undefined) cacheEntry.callbacks = [callback];\n\t\t\telse cacheEntry.callbacks.push(callback);\n\t\t\treturn;\n\t\t}\n\t\t/** @type {CacheEntry<R>} */\n\t\tconst newCacheEntry = {\n\t\t\tresult: undefined,\n\t\t\terror: undefined,\n\t\t\tcallbacks: undefined\n\t\t};\n\t\tcache.set(arg, newCacheEntry);\n\t\tfn(arg, (err, result) => {\n\t\t\tif (err) newCacheEntry.error = err;\n\t\t\telse newCacheEntry.result = result;\n\t\t\tconst callbacks = newCacheEntry.callbacks;\n\t\t\tnewCacheEntry.callbacks = undefined;\n\t\t\tcallback(err, result);\n\t\t\tif (callbacks !== undefined) for (const cb of callbacks) cb(err, result);\n\t\t});\n\t};\n\t/**\n\t * @param {T} arg arg\n\t * @param {function(Error | null, R=): void} callback callback\n\t * @returns {void}\n\t */\n\tresultFn.force = (arg, callback) => {\n\t\tconst cacheEntry = cache.get(arg);\n\t\tif (cacheEntry !== undefined && cacheEntry.force) {\n\t\t\tif (cacheEntry.result !== undefined)\n\t\t\t\treturn callback(null, cacheEntry.result);\n\t\t\tif (cacheEntry.error !== undefined) return callback(cacheEntry.error);\n\t\t\tif (cacheEntry.callbacks === undefined) cacheEntry.callbacks = [callback];\n\t\t\telse cacheEntry.callbacks.push(callback);\n\t\t\treturn;\n\t\t}\n\t\t/** @type {CacheEntry<R>} */\n\t\tconst newCacheEntry = {\n\t\t\tresult: undefined,\n\t\t\terror: undefined,\n\t\t\tcallbacks: undefined,\n\t\t\tforce: true\n\t\t};\n\t\tcache.set(arg, newCacheEntry);\n\t\tforceFn(arg, (err, result) => {\n\t\t\tif (err) newCacheEntry.error = err;\n\t\t\telse newCacheEntry.result = result;\n\t\t\tconst callbacks = newCacheEntry.callbacks;\n\t\t\tnewCacheEntry.callbacks = undefined;\n\t\t\tcallback(err, result);\n\t\t\tif (callbacks !== undefined) for (const cb of callbacks) cb(err, result);\n\t\t});\n\t};\n\treturn resultFn;\n};\n\n/**\n * @typedef {object} LockfileCache\n * @property {Lockfile} lockfile lockfile\n * @property {Snapshot} snapshot snapshot\n */\n\n/**\n * @typedef {object} ResolveContentResult\n * @property {LockfileEntry} entry lockfile entry\n * @property {Buffer} content content\n * @property {boolean} storeLock need store lockfile\n */\n\n/** @typedef {{ storeCache: boolean, storeLock: boolean, validUntil: number, etag: string | undefined, fresh: boolean }} FetchResultMeta */\n/** @typedef {FetchResultMeta & { location: string }} RedirectFetchResult */\n/** @typedef {FetchResultMeta & { entry: LockfileEntry, content: Buffer }} ContentFetchResult */\n/** @typedef {RedirectFetchResult | ContentFetchResult} FetchResult */\n\nclass HttpUriPlugin {\n\t/**\n\t * @param {HttpUriPluginOptions} options options\n\t */\n\tconstructor(options) {\n\t\tvalidate(options);\n\t\tthis._lockfileLocation = options.lockfileLocation;\n\t\tthis._cacheLocation = options.cacheLocation;\n\t\tthis._upgrade = options.upgrade;\n\t\tthis._frozen = options.frozen;\n\t\tthis._allowedUris = options.allowedUris;\n\t\tthis._proxy = options.proxy;\n\t}\n\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst proxy =\n\t\t\tthis._proxy || process.env.http_proxy || process.env.HTTP_PROXY;\n\t\tconst schemes = [\n\t\t\t{\n\t\t\t\tscheme: \"http\",\n\t\t\t\tfetch: proxyFetch(getHttp(), proxy)\n\t\t\t},\n\t\t\t{\n\t\t\t\tscheme: \"https\",\n\t\t\t\tfetch: proxyFetch(getHttps(), proxy)\n\t\t\t}\n\t\t];\n\t\t/** @type {LockfileCache} */\n\t\tlet lockfileCache;\n\t\tcompiler.hooks.compilation.tap(\n\t\t\t\"HttpUriPlugin\",\n\t\t\t(compilation, { normalModuleFactory }) => {\n\t\t\t\tconst intermediateFs =\n\t\t\t\t\t/** @type {IntermediateFileSystem} */\n\t\t\t\t\t(compiler.intermediateFileSystem);\n\t\t\t\tconst fs = compilation.inputFileSystem;\n\t\t\t\tconst cache = compilation.getCache(\"webpack.HttpUriPlugin\");\n\t\t\t\tconst logger = compilation.getLogger(\"webpack.HttpUriPlugin\");\n\t\t\t\t/** @type {string} */\n\t\t\t\tconst lockfileLocation =\n\t\t\t\t\tthis._lockfileLocation ||\n\t\t\t\t\tjoin(\n\t\t\t\t\t\tintermediateFs,\n\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\tcompiler.name\n\t\t\t\t\t\t\t? `${toSafePath(compiler.name)}.webpack.lock`\n\t\t\t\t\t\t\t: \"webpack.lock\"\n\t\t\t\t\t);\n\t\t\t\t/** @type {string | false} */\n\t\t\t\tconst cacheLocation =\n\t\t\t\t\tthis._cacheLocation !== undefined\n\t\t\t\t\t\t? this._cacheLocation\n\t\t\t\t\t\t: `${lockfileLocation}.data`;\n\t\t\t\tconst upgrade = this._upgrade || false;\n\t\t\t\tconst frozen = this._frozen || false;\n\t\t\t\tconst hashFunction = \"sha512\";\n\t\t\t\tconst hashDigest = \"hex\";\n\t\t\t\tconst hashDigestLength = 20;\n\t\t\t\tconst allowedUris = this._allowedUris;\n\n\t\t\t\tlet warnedAboutEol = false;\n\n\t\t\t\t/** @type {Map<string, string>} */\n\t\t\t\tconst cacheKeyCache = new Map();\n\t\t\t\t/**\n\t\t\t\t * @param {string} url the url\n\t\t\t\t * @returns {string} the key\n\t\t\t\t */\n\t\t\t\tconst getCacheKey = url => {\n\t\t\t\t\tconst cachedResult = cacheKeyCache.get(url);\n\t\t\t\t\tif (cachedResult !== undefined) return cachedResult;\n\t\t\t\t\tconst result = _getCacheKey(url);\n\t\t\t\t\tcacheKeyCache.set(url, result);\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * @param {string} url the url\n\t\t\t\t * @returns {string} the key\n\t\t\t\t */\n\t\t\t\tconst _getCacheKey = url => {\n\t\t\t\t\tconst parsedUrl = new URL(url);\n\t\t\t\t\tconst folder = toSafePath(parsedUrl.origin);\n\t\t\t\t\tconst name = toSafePath(parsedUrl.pathname);\n\t\t\t\t\tconst query = toSafePath(parsedUrl.search);\n\t\t\t\t\tlet ext = extname(name);\n\t\t\t\t\tif (ext.length > 20) ext = \"\";\n\t\t\t\t\tconst basename = ext ? name.slice(0, -ext.length) : name;\n\t\t\t\t\tconst hash = createHash(hashFunction);\n\t\t\t\t\thash.update(url);\n\t\t\t\t\tconst digest = hash.digest(hashDigest).slice(0, hashDigestLength);\n\t\t\t\t\treturn `${folder.slice(-50)}/${`${basename}${\n\t\t\t\t\t\tquery ? `_${query}` : \"\"\n\t\t\t\t\t}`.slice(0, 150)}_${digest}${ext}`;\n\t\t\t\t};\n\n\t\t\t\tconst getLockfile = cachedWithoutKey(\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {function(Error | null, Lockfile=): void} callback callback\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tcallback => {\n\t\t\t\t\t\tconst readLockfile = () => {\n\t\t\t\t\t\t\tintermediateFs.readFile(lockfileLocation, (err, buffer) => {\n\t\t\t\t\t\t\t\tif (err && err.code !== \"ENOENT\") {\n\t\t\t\t\t\t\t\t\tcompilation.missingDependencies.add(lockfileLocation);\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcompilation.fileDependencies.add(lockfileLocation);\n\t\t\t\t\t\t\t\tcompilation.fileSystemInfo.createSnapshot(\n\t\t\t\t\t\t\t\t\tcompiler.fsStartTime,\n\t\t\t\t\t\t\t\t\tbuffer ? [lockfileLocation] : [],\n\t\t\t\t\t\t\t\t\t[],\n\t\t\t\t\t\t\t\t\tbuffer ? [] : [lockfileLocation],\n\t\t\t\t\t\t\t\t\t{ timestamp: true },\n\t\t\t\t\t\t\t\t\t(err, s) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tconst lockfile = buffer\n\t\t\t\t\t\t\t\t\t\t\t? Lockfile.parse(buffer.toString(\"utf-8\"))\n\t\t\t\t\t\t\t\t\t\t\t: new Lockfile();\n\t\t\t\t\t\t\t\t\t\tlockfileCache = {\n\t\t\t\t\t\t\t\t\t\t\tlockfile,\n\t\t\t\t\t\t\t\t\t\t\tsnapshot: /** @type {Snapshot} */ (s)\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tcallback(null, lockfile);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (lockfileCache) {\n\t\t\t\t\t\t\tcompilation.fileSystemInfo.checkSnapshotValid(\n\t\t\t\t\t\t\t\tlockfileCache.snapshot,\n\t\t\t\t\t\t\t\t(err, valid) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\tif (!valid) return readLockfile();\n\t\t\t\t\t\t\t\t\tcallback(null, lockfileCache.lockfile);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treadLockfile();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\n\t\t\t\t/** @typedef {Map<string, LockfileEntry | \"ignore\" | \"no-cache\">} LockfileUpdates */\n\n\t\t\t\t/** @type {LockfileUpdates | undefined} */\n\t\t\t\tlet lockfileUpdates;\n\n\t\t\t\t/**\n\t\t\t\t * @param {Lockfile} lockfile lockfile instance\n\t\t\t\t * @param {string} url url to store\n\t\t\t\t * @param {LockfileEntry | \"ignore\" | \"no-cache\"} entry lockfile entry\n\t\t\t\t */\n\t\t\t\tconst storeLockEntry = (lockfile, url, entry) => {\n\t\t\t\t\tconst oldEntry = lockfile.entries.get(url);\n\t\t\t\t\tif (lockfileUpdates === undefined) lockfileUpdates = new Map();\n\t\t\t\t\tlockfileUpdates.set(url, entry);\n\t\t\t\t\tlockfile.entries.set(url, entry);\n\t\t\t\t\tif (!oldEntry) {\n\t\t\t\t\t\tlogger.log(`${url} added to lockfile`);\n\t\t\t\t\t} else if (typeof oldEntry === \"string\") {\n\t\t\t\t\t\tif (typeof entry === \"string\") {\n\t\t\t\t\t\t\tlogger.log(`${url} updated in lockfile: ${oldEntry} -> ${entry}`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t`${url} updated in lockfile: ${oldEntry} -> ${entry.resolved}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (typeof entry === \"string\") {\n\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry}`\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (oldEntry.resolved !== entry.resolved) {\n\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t`${url} updated in lockfile: ${oldEntry.resolved} -> ${entry.resolved}`\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (oldEntry.integrity !== entry.integrity) {\n\t\t\t\t\t\tlogger.log(`${url} updated in lockfile: content changed`);\n\t\t\t\t\t} else if (oldEntry.contentType !== entry.contentType) {\n\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t`${url} updated in lockfile: ${oldEntry.contentType} -> ${entry.contentType}`\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlogger.log(`${url} updated in lockfile`);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t/**\n\t\t\t\t * @param {Lockfile} lockfile lockfile\n\t\t\t\t * @param {string} url url\n\t\t\t\t * @param {ResolveContentResult} result result\n\t\t\t\t * @param {function(Error | null, ResolveContentResult=): void} callback callback\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst storeResult = (lockfile, url, result, callback) => {\n\t\t\t\t\tif (result.storeLock) {\n\t\t\t\t\t\tstoreLockEntry(lockfile, url, result.entry);\n\t\t\t\t\t\tif (!cacheLocation || !result.content)\n\t\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t\tconst key = getCacheKey(result.entry.resolved);\n\t\t\t\t\t\tconst filePath = join(intermediateFs, cacheLocation, key);\n\t\t\t\t\t\tmkdirp(intermediateFs, dirname(intermediateFs, filePath), err => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tintermediateFs.writeFile(filePath, result.content, err => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstoreLockEntry(lockfile, url, \"no-cache\");\n\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tfor (const { scheme, fetch } of schemes) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} url URL\n\t\t\t\t\t * @param {string | null} integrity integrity\n\t\t\t\t\t * @param {function(Error | null, ResolveContentResult=): void} callback callback\n\t\t\t\t\t */\n\t\t\t\t\tconst resolveContent = (url, integrity, callback) => {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {Error | null} err error\n\t\t\t\t\t\t * @param {TODO} result result result\n\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst handleResult = (err, result) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tif (\"location\" in result) {\n\t\t\t\t\t\t\t\treturn resolveContent(\n\t\t\t\t\t\t\t\t\tresult.location,\n\t\t\t\t\t\t\t\t\tintegrity,\n\t\t\t\t\t\t\t\t\t(err, innerResult) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tconst { entry, content, storeLock } =\n\t\t\t\t\t\t\t\t\t\t\t/** @type {ResolveContentResult} */ (innerResult);\n\t\t\t\t\t\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\t\t\t\t\t\tentry,\n\t\t\t\t\t\t\t\t\t\t\tcontent,\n\t\t\t\t\t\t\t\t\t\t\tstoreLock: storeLock && result.storeLock\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!result.fresh &&\n\t\t\t\t\t\t\t\tintegrity &&\n\t\t\t\t\t\t\t\tresult.entry.integrity !== integrity &&\n\t\t\t\t\t\t\t\t!verifyIntegrity(result.content, integrity)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\treturn fetchContent.force(url, handleResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\tentry: result.entry,\n\t\t\t\t\t\t\t\tcontent: result.content,\n\t\t\t\t\t\t\t\tstoreLock: result.storeLock\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\t\t\t\t\t\tfetchContent(url, handleResult);\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} url URL\n\t\t\t\t\t * @param {FetchResult | RedirectFetchResult | undefined} cachedResult result from cache\n\t\t\t\t\t * @param {function(Error | null, FetchResult=): void} callback callback\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst fetchContentRaw = (url, cachedResult, callback) => {\n\t\t\t\t\t\tconst requestTime = Date.now();\n\t\t\t\t\t\tfetch(\n\t\t\t\t\t\t\tnew URL(url),\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t\t\t\"accept-encoding\": \"gzip, deflate, br\",\n\t\t\t\t\t\t\t\t\t\"user-agent\": \"webpack\",\n\t\t\t\t\t\t\t\t\t\"if-none-match\": /** @type {TODO} */ (\n\t\t\t\t\t\t\t\t\t\tcachedResult ? cachedResult.etag || null : null\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tres => {\n\t\t\t\t\t\t\t\tconst etag = res.headers.etag;\n\t\t\t\t\t\t\t\tconst location = res.headers.location;\n\t\t\t\t\t\t\t\tconst cacheControl = res.headers[\"cache-control\"];\n\t\t\t\t\t\t\t\tconst { storeLock, storeCache, validUntil } = parseCacheControl(\n\t\t\t\t\t\t\t\t\tcacheControl,\n\t\t\t\t\t\t\t\t\trequestTime\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {Partial<Pick<FetchResultMeta, \"fresh\">> & (Pick<RedirectFetchResult, \"location\"> | Pick<ContentFetchResult, \"content\" | \"entry\">)} partialResult result\n\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst finishWith = partialResult => {\n\t\t\t\t\t\t\t\t\tif (\"location\" in partialResult) {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`GET ${url} [${res.statusCode}] -> ${partialResult.location}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`GET ${url} [${res.statusCode}] ${Math.ceil(\n\t\t\t\t\t\t\t\t\t\t\t\tpartialResult.content.length / 1024\n\t\t\t\t\t\t\t\t\t\t\t)} kB${!storeLock ? \" no-cache\" : \"\"}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst result = {\n\t\t\t\t\t\t\t\t\t\t...partialResult,\n\t\t\t\t\t\t\t\t\t\tfresh: true,\n\t\t\t\t\t\t\t\t\t\tstoreLock,\n\t\t\t\t\t\t\t\t\t\tstoreCache,\n\t\t\t\t\t\t\t\t\t\tvalidUntil,\n\t\t\t\t\t\t\t\t\t\tetag\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tif (!storeCache) {\n\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t`${url} can't be stored in cache, due to Cache-Control header: ${cacheControl}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcache.store(\n\t\t\t\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t...result,\n\t\t\t\t\t\t\t\t\t\t\tfresh: false\n\t\t\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} can't be stored in cache: ${err.message}`\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tcallback(null, result);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tif (res.statusCode === 304) {\n\t\t\t\t\t\t\t\t\tconst result = /** @type {FetchResult} */ (cachedResult);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tresult.validUntil < validUntil ||\n\t\t\t\t\t\t\t\t\t\tresult.storeLock !== storeLock ||\n\t\t\t\t\t\t\t\t\t\tresult.storeCache !== storeCache ||\n\t\t\t\t\t\t\t\t\t\tresult.etag !== etag\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn finishWith(result);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlogger.debug(`GET ${url} [${res.statusCode}] (unchanged)`);\n\t\t\t\t\t\t\t\t\treturn callback(null, { ...result, fresh: true });\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\tlocation &&\n\t\t\t\t\t\t\t\t\tres.statusCode &&\n\t\t\t\t\t\t\t\t\tres.statusCode >= 301 &&\n\t\t\t\t\t\t\t\t\tres.statusCode <= 308\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tconst result = {\n\t\t\t\t\t\t\t\t\t\tlocation: new URL(location, url).href\n\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\t!cachedResult ||\n\t\t\t\t\t\t\t\t\t\t!(\"location\" in cachedResult) ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.location !== result.location ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.validUntil < validUntil ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.storeLock !== storeLock ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.storeCache !== storeCache ||\n\t\t\t\t\t\t\t\t\t\tcachedResult.etag !== etag\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn finishWith(result);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlogger.debug(`GET ${url} [${res.statusCode}] (unchanged)`);\n\t\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\t\t...result,\n\t\t\t\t\t\t\t\t\t\tfresh: true,\n\t\t\t\t\t\t\t\t\t\tstoreLock,\n\t\t\t\t\t\t\t\t\t\tstoreCache,\n\t\t\t\t\t\t\t\t\t\tvalidUntil,\n\t\t\t\t\t\t\t\t\t\tetag\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst contentType = res.headers[\"content-type\"] || \"\";\n\t\t\t\t\t\t\t\t/** @type {Buffer[]} */\n\t\t\t\t\t\t\t\tconst bufferArr = [];\n\n\t\t\t\t\t\t\t\tconst contentEncoding = res.headers[\"content-encoding\"];\n\t\t\t\t\t\t\t\t/** @type {Readable} */\n\t\t\t\t\t\t\t\tlet stream = res;\n\t\t\t\t\t\t\t\tif (contentEncoding === \"gzip\") {\n\t\t\t\t\t\t\t\t\tstream = stream.pipe(createGunzip());\n\t\t\t\t\t\t\t\t} else if (contentEncoding === \"br\") {\n\t\t\t\t\t\t\t\t\tstream = stream.pipe(createBrotliDecompress());\n\t\t\t\t\t\t\t\t} else if (contentEncoding === \"deflate\") {\n\t\t\t\t\t\t\t\t\tstream = stream.pipe(createInflate());\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tstream.on(\"data\", chunk => {\n\t\t\t\t\t\t\t\t\tbufferArr.push(chunk);\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\tstream.on(\"end\", () => {\n\t\t\t\t\t\t\t\t\tif (!res.complete) {\n\t\t\t\t\t\t\t\t\t\tlogger.log(`GET ${url} [${res.statusCode}] (terminated)`);\n\t\t\t\t\t\t\t\t\t\treturn callback(new Error(`${url} request was terminated`));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst content = Buffer.concat(bufferArr);\n\n\t\t\t\t\t\t\t\t\tif (res.statusCode !== 200) {\n\t\t\t\t\t\t\t\t\t\tlogger.log(`GET ${url} [${res.statusCode}]`);\n\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t`${url} request status code = ${\n\t\t\t\t\t\t\t\t\t\t\t\t\tres.statusCode\n\t\t\t\t\t\t\t\t\t\t\t\t}\\n${content.toString(\"utf-8\")}`\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst integrity = computeIntegrity(content);\n\t\t\t\t\t\t\t\t\tconst entry = { resolved: url, integrity, contentType };\n\n\t\t\t\t\t\t\t\t\tfinishWith({\n\t\t\t\t\t\t\t\t\t\tentry,\n\t\t\t\t\t\t\t\t\t\tcontent\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t).on(\"error\", err => {\n\t\t\t\t\t\t\tlogger.log(`GET ${url} (error)`);\n\t\t\t\t\t\t\terr.message += `\\nwhile fetching ${url}`;\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\n\t\t\t\t\tconst fetchContent = cachedWithKey(\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {string} url URL\n\t\t\t\t\t\t * @param {function(Error | null, { validUntil: number, etag?: string, entry: LockfileEntry, content: Buffer, fresh: boolean } | { validUntil: number, etag?: string, location: string, fresh: boolean }=): void} callback callback\n\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t */\n\t\t\t\t\t\t(url, callback) => {\n\t\t\t\t\t\t\tcache.get(url, null, (err, cachedResult) => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tif (cachedResult) {\n\t\t\t\t\t\t\t\t\tconst isValid = cachedResult.validUntil >= Date.now();\n\t\t\t\t\t\t\t\t\tif (isValid) return callback(null, cachedResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tfetchContentRaw(url, cachedResult, callback);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\t(url, callback) => fetchContentRaw(url, undefined, callback)\n\t\t\t\t\t);\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string} uri uri\n\t\t\t\t\t * @returns {boolean} true when allowed, otherwise false\n\t\t\t\t\t */\n\t\t\t\t\tconst isAllowed = uri => {\n\t\t\t\t\t\tfor (const allowed of allowedUris) {\n\t\t\t\t\t\t\tif (typeof allowed === \"string\") {\n\t\t\t\t\t\t\t\tif (uri.startsWith(allowed)) return true;\n\t\t\t\t\t\t\t} else if (typeof allowed === \"function\") {\n\t\t\t\t\t\t\t\tif (allowed(uri)) return true;\n\t\t\t\t\t\t\t} else if (allowed.test(uri)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t};\n\n\t\t\t\t\t/** @typedef {{ entry: LockfileEntry, content: Buffer }} Info */\n\n\t\t\t\t\tconst getInfo = cachedWithKey(\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {string} url the url\n\t\t\t\t\t\t * @param {function(Error | null, Info=): void} callback callback\n\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t */\n\t\t\t\t\t\t// eslint-disable-next-line no-loop-func\n\t\t\t\t\t\t(url, callback) => {\n\t\t\t\t\t\t\tif (!isAllowed(url)) {\n\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t`${url} doesn't match the allowedUris policy. These URIs are allowed:\\n${allowedUris\n\t\t\t\t\t\t\t\t\t\t\t.map(uri => ` - ${uri}`)\n\t\t\t\t\t\t\t\t\t\t\t.join(\"\\n\")}`\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgetLockfile((err, _lockfile) => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tconst lockfile = /** @type {Lockfile} */ (_lockfile);\n\t\t\t\t\t\t\t\tconst entryOrString = lockfile.entries.get(url);\n\t\t\t\t\t\t\t\tif (!entryOrString) {\n\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t`${url} has no lockfile entry and lockfile is frozen`\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tresolveContent(url, null, (err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tstoreResult(\n\t\t\t\t\t\t\t\t\t\t\t/** @type {Lockfile} */\n\t\t\t\t\t\t\t\t\t\t\t(lockfile),\n\t\t\t\t\t\t\t\t\t\t\turl,\n\t\t\t\t\t\t\t\t\t\t\t/** @type {ResolveContentResult} */\n\t\t\t\t\t\t\t\t\t\t\t(result),\n\t\t\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (typeof entryOrString === \"string\") {\n\t\t\t\t\t\t\t\t\tconst entryTag = entryOrString;\n\t\t\t\t\t\t\t\t\tresolveContent(url, null, (err, _result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\tconst result =\n\t\t\t\t\t\t\t\t\t\t\t/** @type {ResolveContentResult} */\n\t\t\t\t\t\t\t\t\t\t\t(_result);\n\t\t\t\t\t\t\t\t\t\tif (!result.storeLock || entryTag === \"ignore\")\n\t\t\t\t\t\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} used to have ${entryTag} lockfile entry and has content now, but lockfile is frozen`\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!upgrade) {\n\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} used to have ${entryTag} lockfile entry and has content now.\nThis should be reflected in the lockfile, so this lockfile entry must be upgraded, but upgrading is not enabled.\nRemove this line from the lockfile to force upgrading.`\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tstoreResult(lockfile, url, result, callback);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet entry = entryOrString;\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * @param {Buffer=} lockedContent locked content\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tconst doFetch = lockedContent => {\n\t\t\t\t\t\t\t\t\tresolveContent(url, entry.integrity, (err, _result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tif (lockedContent) {\n\t\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Upgrade request to ${url} failed: ${err.message}`\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tlogger.debug(err.stack);\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(null, {\n\t\t\t\t\t\t\t\t\t\t\t\t\tentry,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontent: lockedContent\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst result =\n\t\t\t\t\t\t\t\t\t\t\t/** @type {ResolveContentResult} */\n\t\t\t\t\t\t\t\t\t\t\t(_result);\n\t\t\t\t\t\t\t\t\t\tif (!result.storeLock) {\n\t\t\t\t\t\t\t\t\t\t\t// When the lockfile entry should be no-cache\n\t\t\t\t\t\t\t\t\t\t\t// we need to update the lockfile\n\t\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} has a lockfile entry and is no-cache now, but lockfile is frozen\\nLockfile: ${entryToString(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentry\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}`\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tstoreResult(lockfile, url, result, callback);\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!areLockfileEntriesEqual(result.entry, entry)) {\n\t\t\t\t\t\t\t\t\t\t\t// When the lockfile entry is outdated\n\t\t\t\t\t\t\t\t\t\t\t// we need to update the lockfile\n\t\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} has an outdated lockfile entry, but lockfile is frozen\\nLockfile: ${entryToString(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentry\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}\\nExpected: ${entryToString(result.entry)}`\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tstoreResult(lockfile, url, result, callback);\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!lockedContent && cacheLocation) {\n\t\t\t\t\t\t\t\t\t\t\t// When the lockfile cache content is missing\n\t\t\t\t\t\t\t\t\t\t\t// we need to update the lockfile\n\t\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${url} is missing content in the lockfile cache, but lockfile is frozen\\nLockfile: ${entryToString(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentry\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}`\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tstoreResult(lockfile, url, result, callback);\n\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\treturn callback(null, result);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tif (cacheLocation) {\n\t\t\t\t\t\t\t\t\t// When there is a lockfile cache\n\t\t\t\t\t\t\t\t\t// we read the content from there\n\t\t\t\t\t\t\t\t\tconst key = getCacheKey(entry.resolved);\n\t\t\t\t\t\t\t\t\tconst filePath = join(intermediateFs, cacheLocation, key);\n\t\t\t\t\t\t\t\t\tfs.readFile(filePath, (err, result) => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tif (err.code === \"ENOENT\") return doFetch();\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tconst content = /** @type {Buffer} */ (result);\n\t\t\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t\t\t * @param {Buffer | undefined} _result result\n\t\t\t\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\t\t\tconst continueWithCachedContent = _result => {\n\t\t\t\t\t\t\t\t\t\t\tif (!upgrade) {\n\t\t\t\t\t\t\t\t\t\t\t\t// When not in upgrade mode, we accept the result from the lockfile cache\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(null, { entry, content });\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn doFetch(content);\n\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\tif (!verifyIntegrity(content, entry.integrity)) {\n\t\t\t\t\t\t\t\t\t\t\t/** @type {Buffer | undefined} */\n\t\t\t\t\t\t\t\t\t\t\tlet contentWithChangedEol;\n\t\t\t\t\t\t\t\t\t\t\tlet isEolChanged = false;\n\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\tcontentWithChangedEol = Buffer.from(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontent.toString(\"utf-8\").replace(/\\r\\n/g, \"\\n\")\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tisEolChanged = verifyIntegrity(\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontentWithChangedEol,\n\t\t\t\t\t\t\t\t\t\t\t\t\tentry.integrity\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t} catch (_err) {\n\t\t\t\t\t\t\t\t\t\t\t\t// ignore\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (isEolChanged) {\n\t\t\t\t\t\t\t\t\t\t\t\tif (!warnedAboutEol) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst explainer = `Incorrect end of line sequence was detected in the lockfile cache.\nThe lockfile cache is protected by integrity checks, so any external modification will lead to a corrupted lockfile cache.\nWhen using git make sure to configure .gitattributes correctly for the lockfile cache:\n  **/*webpack.lock.data/** -text\nThis will avoid that the end of line sequence is changed by git on Windows.`;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlogger.error(explainer);\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlogger.warn(explainer);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlogger.info(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Lockfile cache will be automatically fixed now, but when lockfile is frozen this would result in an error.\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\twarnedAboutEol = true;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tif (!frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// \"fix\" the end of line sequence of the lockfile content\n\t\t\t\t\t\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${filePath} fixed end of line sequence (\\\\r\\\\n instead of \\\\n).`\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\tintermediateFs.writeFile(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tfilePath,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t/** @type {Buffer} */\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t(contentWithChangedEol),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinueWithCachedContent(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/** @type {Buffer} */\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t(contentWithChangedEol)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tif (frozen) {\n\t\t\t\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t`${\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentry.resolved\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} integrity mismatch, expected content with integrity ${\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tentry.integrity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} but got ${computeIntegrity(content)}.\nLockfile corrupted (${\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tisEolChanged\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? \"end of line sequence was unexpectedly changed\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: \"incorrectly merged? changed by other tools?\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}).\nRun build with un-frozen lockfile to automatically fix lockfile.`\n\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// \"fix\" the lockfile entry to the correct integrity\n\t\t\t\t\t\t\t\t\t\t\t// the content has priority over the integrity value\n\t\t\t\t\t\t\t\t\t\t\tentry = {\n\t\t\t\t\t\t\t\t\t\t\t\t...entry,\n\t\t\t\t\t\t\t\t\t\t\t\tintegrity: computeIntegrity(content)\n\t\t\t\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\t\t\tstoreLockEntry(lockfile, url, entry);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcontinueWithCachedContent(result);\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tdoFetch();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {URL} url url\n\t\t\t\t\t * @param {ResourceDataWithData} resourceData resource data\n\t\t\t\t\t * @param {function(Error | null, true | void): void} callback callback\n\t\t\t\t\t */\n\t\t\t\t\tconst respondWithUrlModule = (url, resourceData, callback) => {\n\t\t\t\t\t\tgetInfo(url.href, (err, _result) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst result = /** @type {Info} */ (_result);\n\t\t\t\t\t\t\tresourceData.resource = url.href;\n\t\t\t\t\t\t\tresourceData.path = url.origin + url.pathname;\n\t\t\t\t\t\t\tresourceData.query = url.search;\n\t\t\t\t\t\t\tresourceData.fragment = url.hash;\n\t\t\t\t\t\t\tresourceData.context = new URL(\n\t\t\t\t\t\t\t\t\".\",\n\t\t\t\t\t\t\t\tresult.entry.resolved\n\t\t\t\t\t\t\t).href.slice(0, -1);\n\t\t\t\t\t\t\tresourceData.data.mimetype = result.entry.contentType;\n\t\t\t\t\t\t\tcallback(null, true);\n\t\t\t\t\t\t});\n\t\t\t\t\t};\n\t\t\t\t\tnormalModuleFactory.hooks.resolveForScheme\n\t\t\t\t\t\t.for(scheme)\n\t\t\t\t\t\t.tapAsync(\n\t\t\t\t\t\t\t\"HttpUriPlugin\",\n\t\t\t\t\t\t\t(resourceData, resolveData, callback) => {\n\t\t\t\t\t\t\t\trespondWithUrlModule(\n\t\t\t\t\t\t\t\t\tnew URL(resourceData.resource),\n\t\t\t\t\t\t\t\t\tresourceData,\n\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\tnormalModuleFactory.hooks.resolveInScheme\n\t\t\t\t\t\t.for(scheme)\n\t\t\t\t\t\t.tapAsync(\"HttpUriPlugin\", (resourceData, data, callback) => {\n\t\t\t\t\t\t\t// Only handle relative urls (./xxx, ../xxx, /xxx, //xxx)\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tdata.dependencyType !== \"url\" &&\n\t\t\t\t\t\t\t\t!/^\\.{0,2}\\//.test(resourceData.resource)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\trespondWithUrlModule(\n\t\t\t\t\t\t\t\tnew URL(resourceData.resource, `${data.context}/`),\n\t\t\t\t\t\t\t\tresourceData,\n\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\tconst hooks = NormalModule.getCompilationHooks(compilation);\n\t\t\t\t\thooks.readResourceForScheme\n\t\t\t\t\t\t.for(scheme)\n\t\t\t\t\t\t.tapAsync(\"HttpUriPlugin\", (resource, module, callback) =>\n\t\t\t\t\t\t\tgetInfo(resource, (err, _result) => {\n\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\tconst result = /** @type {Info} */ (_result);\n\t\t\t\t\t\t\t\t/** @type {BuildInfo} */\n\t\t\t\t\t\t\t\t(module.buildInfo).resourceIntegrity = result.entry.integrity;\n\t\t\t\t\t\t\t\tcallback(null, result.content);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\thooks.needBuild.tapAsync(\n\t\t\t\t\t\t\"HttpUriPlugin\",\n\t\t\t\t\t\t(module, context, callback) => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tmodule.resource &&\n\t\t\t\t\t\t\t\tmodule.resource.startsWith(`${scheme}://`)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tgetInfo(module.resource, (err, _result) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\tconst result = /** @type {Info} */ (_result);\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tresult.entry.integrity !==\n\t\t\t\t\t\t\t\t\t\t/** @type {BuildInfo} */\n\t\t\t\t\t\t\t\t\t\t(module.buildInfo).resourceIntegrity\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\treturn callback(null, true);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcompilation.hooks.finishModules.tapAsync(\n\t\t\t\t\t\"HttpUriPlugin\",\n\t\t\t\t\t(modules, callback) => {\n\t\t\t\t\t\tif (!lockfileUpdates) return callback();\n\t\t\t\t\t\tconst ext = extname(lockfileLocation);\n\t\t\t\t\t\tconst tempFile = join(\n\t\t\t\t\t\t\tintermediateFs,\n\t\t\t\t\t\t\tdirname(intermediateFs, lockfileLocation),\n\t\t\t\t\t\t\t`.${basename(lockfileLocation, ext)}.${\n\t\t\t\t\t\t\t\t(Math.random() * 10000) | 0\n\t\t\t\t\t\t\t}${ext}`\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tconst writeDone = () => {\n\t\t\t\t\t\t\tconst nextOperation =\n\t\t\t\t\t\t\t\t/** @type {InProgressWriteItem[]} */\n\t\t\t\t\t\t\t\t(inProgressWrite).shift();\n\t\t\t\t\t\t\tif (nextOperation) {\n\t\t\t\t\t\t\t\tnextOperation();\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tinProgressWrite = undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\tconst runWrite = () => {\n\t\t\t\t\t\t\tintermediateFs.readFile(lockfileLocation, (err, buffer) => {\n\t\t\t\t\t\t\t\tif (err && err.code !== \"ENOENT\") {\n\t\t\t\t\t\t\t\t\twriteDone();\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst lockfile = buffer\n\t\t\t\t\t\t\t\t\t? Lockfile.parse(buffer.toString(\"utf-8\"))\n\t\t\t\t\t\t\t\t\t: new Lockfile();\n\t\t\t\t\t\t\t\tfor (const [key, value] of /** @type {LockfileUpdates} */ (\n\t\t\t\t\t\t\t\t\tlockfileUpdates\n\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\tlockfile.entries.set(key, value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tintermediateFs.writeFile(tempFile, lockfile.toString(), err => {\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\twriteDone();\n\t\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t\t/** @type {NonNullable<IntermediateFileSystem[\"unlink\"]>} */\n\t\t\t\t\t\t\t\t\t\t\t(intermediateFs.unlink)(tempFile, () => callback(err))\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tintermediateFs.rename(tempFile, lockfileLocation, err => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\twriteDone();\n\t\t\t\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t\t\t\t/** @type {NonNullable<IntermediateFileSystem[\"unlink\"]>} */\n\t\t\t\t\t\t\t\t\t\t\t\t(intermediateFs.unlink)(tempFile, () => callback(err))\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\twriteDone();\n\t\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (inProgressWrite) {\n\t\t\t\t\t\t\tinProgressWrite.push(runWrite);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tinProgressWrite = [];\n\t\t\t\t\t\t\trunWrite();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n}\n\nmodule.exports = HttpUriPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}