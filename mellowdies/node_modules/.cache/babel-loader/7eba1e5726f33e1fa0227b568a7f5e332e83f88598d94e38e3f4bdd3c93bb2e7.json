{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst {\n  create: createResolver\n} = require(\"enhanced-resolve\");\nconst nodeModule = require(\"module\");\nconst asyncLib = require(\"neo-async\");\nconst {\n  isAbsolute\n} = require(\"path\");\nconst AsyncQueue = require(\"./util/AsyncQueue\");\nconst StackedCacheMap = require(\"./util/StackedCacheMap\");\nconst createHash = require(\"./util/createHash\");\nconst {\n  join,\n  dirname,\n  relative,\n  lstatReadlinkAbsolute\n} = require(\"./util/fs\");\nconst makeSerializable = require(\"./util/makeSerializable\");\nconst processAsyncTree = require(\"./util/processAsyncTree\");\n\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n/** @typedef {import(\"enhanced-resolve\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"enhanced-resolve\").ResolveFunctionAsync} ResolveFunctionAsync */\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./serialization/ObjectMiddleware\").ObjectDeserializerContext} ObjectDeserializerContext */\n/** @typedef {import(\"./serialization/ObjectMiddleware\").ObjectSerializerContext} ObjectSerializerContext */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/fs\").IStats} IStats */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").PathLike} PathLike */\n/** @typedef {import(\"./util/fs\").StringCallback} StringCallback */\n/**\n * @template T\n * @typedef {import(\"./util/AsyncQueue\").Callback<T>} ProcessorCallback\n */\n/**\n * @template T, R\n * @typedef {import(\"./util/AsyncQueue\").Processor<T, R>} Processor\n */\n\nconst supportsEsm = Number(process.versions.modules) >= 83;\n\n/** @type {Set<string>} */\nconst builtinModules = new Set(nodeModule.builtinModules);\nlet FS_ACCURACY = 2000;\nconst EMPTY_SET = new Set();\nconst RBDT_RESOLVE_CJS = 0;\nconst RBDT_RESOLVE_ESM = 1;\nconst RBDT_RESOLVE_DIRECTORY = 2;\nconst RBDT_RESOLVE_CJS_FILE = 3;\nconst RBDT_RESOLVE_CJS_FILE_AS_CHILD = 4;\nconst RBDT_RESOLVE_ESM_FILE = 5;\nconst RBDT_DIRECTORY = 6;\nconst RBDT_FILE = 7;\nconst RBDT_DIRECTORY_DEPENDENCIES = 8;\nconst RBDT_FILE_DEPENDENCIES = 9;\n\n/** @typedef {RBDT_RESOLVE_CJS | RBDT_RESOLVE_ESM | RBDT_RESOLVE_DIRECTORY | RBDT_RESOLVE_CJS_FILE | RBDT_RESOLVE_CJS_FILE_AS_CHILD | RBDT_RESOLVE_ESM_FILE | RBDT_DIRECTORY | RBDT_FILE | RBDT_DIRECTORY_DEPENDENCIES | RBDT_FILE_DEPENDENCIES} JobType */\n\nconst INVALID = Symbol(\"invalid\");\n\n/**\n * @typedef {object} FileSystemInfoEntry\n * @property {number} safeTime\n * @property {number=} timestamp\n */\n\n/**\n * @typedef {object} ResolvedContextFileSystemInfoEntry\n * @property {number} safeTime\n * @property {string=} timestampHash\n */\n\n/**\n * @typedef {object} ContextFileSystemInfoEntry\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {ResolvedContextFileSystemInfoEntry=} resolved\n * @property {Set<string>=} symlinks\n */\n\n/**\n * @typedef {object} TimestampAndHash\n * @property {number} safeTime\n * @property {number=} timestamp\n * @property {string} hash\n */\n\n/**\n * @typedef {object} ResolvedContextTimestampAndHash\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {string} hash\n */\n\n/** @typedef {Set<string>} Symlinks */\n\n/**\n * @typedef {object} ContextTimestampAndHash\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {string} hash\n * @property {ResolvedContextTimestampAndHash=} resolved\n * @property {Symlinks=} symlinks\n */\n\n/**\n * @typedef {object} ContextHash\n * @property {string} hash\n * @property {string=} resolved\n * @property {Symlinks=} symlinks\n */\n\n/** @typedef {Set<string>} SnapshotContent */\n\n/**\n * @typedef {object} SnapshotOptimizationEntry\n * @property {Snapshot} snapshot\n * @property {number} shared\n * @property {SnapshotContent | undefined} snapshotContent\n * @property {Set<SnapshotOptimizationEntry> | undefined} children\n */\n\n/**\n * @typedef {object} ResolveBuildDependenciesResult\n * @property {Set<string>} files list of files\n * @property {Set<string>} directories list of directories\n * @property {Set<string>} missing list of missing entries\n * @property {Map<string, string | false | undefined>} resolveResults stored resolve results\n * @property {object} resolveDependencies dependencies of the resolving\n * @property {Set<string>} resolveDependencies.files list of files\n * @property {Set<string>} resolveDependencies.directories list of directories\n * @property {Set<string>} resolveDependencies.missing list of missing entries\n */\n\n/**\n * @typedef {object} SnapshotOptions\n * @property {boolean=} hash should use hash to snapshot\n * @property {boolean=} timestamp should use timestamp to snapshot\n */\n\nconst DONE_ITERATOR_RESULT = new Set().keys().next();\n\n// cspell:word tshs\n// Tsh = Timestamp + Hash\n// Tshs = Timestamp + Hash combinations\n\nclass SnapshotIterator {\n  /**\n   * @param {() => IteratorResult<string>} next next\n   */\n  constructor(next) {\n    this.next = next;\n  }\n}\n\n/**\n * @typedef {(snapshot: Snapshot) => (Map<string, any> | Set<string> | undefined)[]} GetMapsFunction\n */\n\nclass SnapshotIterable {\n  /**\n   * @param {Snapshot} snapshot snapshot\n   * @param {GetMapsFunction} getMaps get maps function\n   */\n  constructor(snapshot, getMaps) {\n    this.snapshot = snapshot;\n    this.getMaps = getMaps;\n  }\n  [Symbol.iterator]() {\n    let state = 0;\n    /** @type {IterableIterator<string>} */\n    let it;\n    /** @type {(snapshot: Snapshot) => (Map<string, any> | Set<string> | undefined)[]} */\n    let getMaps;\n    /** @type {(Map<string, any> | Set<string> | undefined)[]} */\n    let maps;\n    /** @type {Snapshot} */\n    let snapshot;\n    /** @type {Snapshot[] | undefined} */\n    let queue;\n    return new SnapshotIterator(() => {\n      for (;;) {\n        switch (state) {\n          case 0:\n            snapshot = this.snapshot;\n            getMaps = this.getMaps;\n            maps = getMaps(snapshot);\n            state = 1;\n          /* falls through */\n          case 1:\n            if (maps.length > 0) {\n              const map = maps.pop();\n              if (map !== undefined) {\n                it = map.keys();\n                state = 2;\n              } else {\n                break;\n              }\n            } else {\n              state = 3;\n              break;\n            }\n          /* falls through */\n          case 2:\n            {\n              const result = it.next();\n              if (!result.done) return result;\n              state = 1;\n              break;\n            }\n          case 3:\n            {\n              const children = snapshot.children;\n              if (children !== undefined) {\n                if (children.size === 1) {\n                  // shortcut for a single child\n                  // avoids allocation of queue\n                  for (const child of children) snapshot = child;\n                  maps = getMaps(snapshot);\n                  state = 1;\n                  break;\n                }\n                if (queue === undefined) queue = [];\n                for (const child of children) {\n                  queue.push(child);\n                }\n              }\n              if (queue !== undefined && queue.length > 0) {\n                snapshot = /** @type {Snapshot} */queue.pop();\n                maps = getMaps(snapshot);\n                state = 1;\n                break;\n              } else {\n                state = 4;\n              }\n            }\n          /* falls through */\n          case 4:\n            return DONE_ITERATOR_RESULT;\n        }\n      }\n    });\n  }\n}\n\n/** @typedef {Map<string, FileSystemInfoEntry | null>} FileTimestamps */\n/** @typedef {Map<string, string | null>} FileHashes */\n/** @typedef {Map<string, TimestampAndHash | string | null>} FileTshs */\n/** @typedef {Map<string, ResolvedContextFileSystemInfoEntry | null>} ContextTimestamps */\n/** @typedef {Map<string, string | null>} ContextHashes */\n/** @typedef {Map<string, ResolvedContextTimestampAndHash | null>} ContextTshs */\n/** @typedef {Map<string, boolean>} MissingExistence */\n/** @typedef {Map<string, string>} ManagedItemInfo */\n/** @typedef {Set<string>} ManagedFiles */\n/** @typedef {Set<string>} ManagedContexts */\n/** @typedef {Set<string>} ManagedMissing */\n/** @typedef {Set<Snapshot>} Children */\n\nclass Snapshot {\n  constructor() {\n    this._flags = 0;\n    /** @type {Iterable<string> | undefined} */\n    this._cachedFileIterable = undefined;\n    /** @type {Iterable<string> | undefined} */\n    this._cachedContextIterable = undefined;\n    /** @type {Iterable<string> | undefined} */\n    this._cachedMissingIterable = undefined;\n    /** @type {number | undefined} */\n    this.startTime = undefined;\n    /** @type {FileTimestamps | undefined} */\n    this.fileTimestamps = undefined;\n    /** @type {FileHashes | undefined} */\n    this.fileHashes = undefined;\n    /** @type {FileTshs | undefined} */\n    this.fileTshs = undefined;\n    /** @type {ContextTimestamps | undefined} */\n    this.contextTimestamps = undefined;\n    /** @type {ContextHashes | undefined} */\n    this.contextHashes = undefined;\n    /** @type {ContextTshs | undefined} */\n    this.contextTshs = undefined;\n    /** @type {MissingExistence | undefined} */\n    this.missingExistence = undefined;\n    /** @type {ManagedItemInfo | undefined} */\n    this.managedItemInfo = undefined;\n    /** @type {ManagedFiles | undefined} */\n    this.managedFiles = undefined;\n    /** @type {ManagedContexts | undefined} */\n    this.managedContexts = undefined;\n    /** @type {ManagedMissing | undefined} */\n    this.managedMissing = undefined;\n    /** @type {Children | undefined} */\n    this.children = undefined;\n  }\n  hasStartTime() {\n    return (this._flags & 1) !== 0;\n  }\n\n  /**\n   * @param {number} value start value\n   */\n  setStartTime(value) {\n    this._flags = this._flags | 1;\n    this.startTime = value;\n  }\n\n  /**\n   * @param {number | undefined} value value\n   * @param {Snapshot} snapshot snapshot\n   */\n  setMergedStartTime(value, snapshot) {\n    if (value) {\n      if (snapshot.hasStartTime()) {\n        this.setStartTime(Math.min(value, /** @type {NonNullable<Snapshot[\"startTime\"]>} */\n        snapshot.startTime));\n      } else {\n        this.setStartTime(value);\n      }\n    } else if (snapshot.hasStartTime()) {\n      this.setStartTime(/** @type {NonNullable<Snapshot[\"startTime\"]>} */\n      snapshot.startTime);\n    }\n  }\n  hasFileTimestamps() {\n    return (this._flags & 2) !== 0;\n  }\n\n  /**\n   * @param {FileTimestamps} value file timestamps\n   */\n  setFileTimestamps(value) {\n    this._flags = this._flags | 2;\n    this.fileTimestamps = value;\n  }\n  hasFileHashes() {\n    return (this._flags & 4) !== 0;\n  }\n\n  /**\n   * @param {FileHashes} value file hashes\n   */\n  setFileHashes(value) {\n    this._flags = this._flags | 4;\n    this.fileHashes = value;\n  }\n  hasFileTshs() {\n    return (this._flags & 8) !== 0;\n  }\n\n  /**\n   * @param {FileTshs} value file tshs\n   */\n  setFileTshs(value) {\n    this._flags = this._flags | 8;\n    this.fileTshs = value;\n  }\n  hasContextTimestamps() {\n    return (this._flags & 0x10) !== 0;\n  }\n\n  /**\n   * @param {ContextTimestamps} value context timestamps\n   */\n  setContextTimestamps(value) {\n    this._flags = this._flags | 0x10;\n    this.contextTimestamps = value;\n  }\n  hasContextHashes() {\n    return (this._flags & 0x20) !== 0;\n  }\n\n  /**\n   * @param {ContextHashes} value context hashes\n   */\n  setContextHashes(value) {\n    this._flags = this._flags | 0x20;\n    this.contextHashes = value;\n  }\n  hasContextTshs() {\n    return (this._flags & 0x40) !== 0;\n  }\n\n  /**\n   * @param {ContextTshs} value context tshs\n   */\n  setContextTshs(value) {\n    this._flags = this._flags | 0x40;\n    this.contextTshs = value;\n  }\n  hasMissingExistence() {\n    return (this._flags & 0x80) !== 0;\n  }\n\n  /**\n   * @param {MissingExistence} value context tshs\n   */\n  setMissingExistence(value) {\n    this._flags = this._flags | 0x80;\n    this.missingExistence = value;\n  }\n  hasManagedItemInfo() {\n    return (this._flags & 0x100) !== 0;\n  }\n\n  /**\n   * @param {ManagedItemInfo} value managed item info\n   */\n  setManagedItemInfo(value) {\n    this._flags = this._flags | 0x100;\n    this.managedItemInfo = value;\n  }\n  hasManagedFiles() {\n    return (this._flags & 0x200) !== 0;\n  }\n\n  /**\n   * @param {ManagedFiles} value managed files\n   */\n  setManagedFiles(value) {\n    this._flags = this._flags | 0x200;\n    this.managedFiles = value;\n  }\n  hasManagedContexts() {\n    return (this._flags & 0x400) !== 0;\n  }\n\n  /**\n   * @param {ManagedContexts} value managed contexts\n   */\n  setManagedContexts(value) {\n    this._flags = this._flags | 0x400;\n    this.managedContexts = value;\n  }\n  hasManagedMissing() {\n    return (this._flags & 0x800) !== 0;\n  }\n\n  /**\n   * @param {ManagedMissing} value managed missing\n   */\n  setManagedMissing(value) {\n    this._flags = this._flags | 0x800;\n    this.managedMissing = value;\n  }\n  hasChildren() {\n    return (this._flags & 0x1000) !== 0;\n  }\n\n  /**\n   * @param {Children} value children\n   */\n  setChildren(value) {\n    this._flags = this._flags | 0x1000;\n    this.children = value;\n  }\n\n  /**\n   * @param {Snapshot} child children\n   */\n  addChild(child) {\n    if (!this.hasChildren()) {\n      this.setChildren(new Set());\n    }\n    /** @type {Children} */\n    this.children.add(child);\n  }\n\n  /**\n   * @param {ObjectSerializerContext} context context\n   */\n  serialize({\n    write\n  }) {\n    write(this._flags);\n    if (this.hasStartTime()) write(this.startTime);\n    if (this.hasFileTimestamps()) write(this.fileTimestamps);\n    if (this.hasFileHashes()) write(this.fileHashes);\n    if (this.hasFileTshs()) write(this.fileTshs);\n    if (this.hasContextTimestamps()) write(this.contextTimestamps);\n    if (this.hasContextHashes()) write(this.contextHashes);\n    if (this.hasContextTshs()) write(this.contextTshs);\n    if (this.hasMissingExistence()) write(this.missingExistence);\n    if (this.hasManagedItemInfo()) write(this.managedItemInfo);\n    if (this.hasManagedFiles()) write(this.managedFiles);\n    if (this.hasManagedContexts()) write(this.managedContexts);\n    if (this.hasManagedMissing()) write(this.managedMissing);\n    if (this.hasChildren()) write(this.children);\n  }\n\n  /**\n   * @param {ObjectDeserializerContext} context context\n   */\n  deserialize({\n    read\n  }) {\n    this._flags = read();\n    if (this.hasStartTime()) this.startTime = read();\n    if (this.hasFileTimestamps()) this.fileTimestamps = read();\n    if (this.hasFileHashes()) this.fileHashes = read();\n    if (this.hasFileTshs()) this.fileTshs = read();\n    if (this.hasContextTimestamps()) this.contextTimestamps = read();\n    if (this.hasContextHashes()) this.contextHashes = read();\n    if (this.hasContextTshs()) this.contextTshs = read();\n    if (this.hasMissingExistence()) this.missingExistence = read();\n    if (this.hasManagedItemInfo()) this.managedItemInfo = read();\n    if (this.hasManagedFiles()) this.managedFiles = read();\n    if (this.hasManagedContexts()) this.managedContexts = read();\n    if (this.hasManagedMissing()) this.managedMissing = read();\n    if (this.hasChildren()) this.children = read();\n  }\n\n  /**\n   * @param {GetMapsFunction} getMaps first\n   * @returns {Iterable<string>} iterable\n   */\n  _createIterable(getMaps) {\n    return new SnapshotIterable(this, getMaps);\n  }\n\n  /**\n   * @returns {Iterable<string>} iterable\n   */\n  getFileIterable() {\n    if (this._cachedFileIterable === undefined) {\n      this._cachedFileIterable = this._createIterable(s => [s.fileTimestamps, s.fileHashes, s.fileTshs, s.managedFiles]);\n    }\n    return this._cachedFileIterable;\n  }\n\n  /**\n   * @returns {Iterable<string>} iterable\n   */\n  getContextIterable() {\n    if (this._cachedContextIterable === undefined) {\n      this._cachedContextIterable = this._createIterable(s => [s.contextTimestamps, s.contextHashes, s.contextTshs, s.managedContexts]);\n    }\n    return this._cachedContextIterable;\n  }\n\n  /**\n   * @returns {Iterable<string>} iterable\n   */\n  getMissingIterable() {\n    if (this._cachedMissingIterable === undefined) {\n      this._cachedMissingIterable = this._createIterable(s => [s.missingExistence, s.managedMissing]);\n    }\n    return this._cachedMissingIterable;\n  }\n}\nmakeSerializable(Snapshot, \"webpack/lib/FileSystemInfo\", \"Snapshot\");\nconst MIN_COMMON_SNAPSHOT_SIZE = 3;\n\n/**\n * @template U, T\n * @typedef {U extends true ? Set<string> : Map<string, T>} SnapshotOptimizationValue\n */\n\n/**\n * @template T\n * @template {boolean} [U=false]\n */\nclass SnapshotOptimization {\n  /**\n   * @param {function(Snapshot): boolean} has has value\n   * @param {function(Snapshot): SnapshotOptimizationValue<U, T> | undefined} get get value\n   * @param {function(Snapshot, SnapshotOptimizationValue<U, T>): void} set set value\n   * @param {boolean=} useStartTime use the start time of snapshots\n   * @param {U=} isSet value is an Set instead of a Map\n   */\n  constructor(has, get, set, useStartTime = true, isSet = (/** @type {U} */false)) {\n    this._has = has;\n    this._get = get;\n    this._set = set;\n    this._useStartTime = useStartTime;\n    /** @type {U} */\n    this._isSet = isSet;\n    /** @type {Map<string, SnapshotOptimizationEntry>} */\n    this._map = new Map();\n    this._statItemsShared = 0;\n    this._statItemsUnshared = 0;\n    this._statSharedSnapshots = 0;\n    this._statReusedSharedSnapshots = 0;\n  }\n  getStatisticMessage() {\n    const total = this._statItemsShared + this._statItemsUnshared;\n    if (total === 0) return;\n    return `${this._statItemsShared && Math.round(this._statItemsShared * 100 / total)}% (${this._statItemsShared}/${total}) entries shared via ${this._statSharedSnapshots} shared snapshots (${this._statReusedSharedSnapshots + this._statSharedSnapshots} times referenced)`;\n  }\n  clear() {\n    this._map.clear();\n    this._statItemsShared = 0;\n    this._statItemsUnshared = 0;\n    this._statSharedSnapshots = 0;\n    this._statReusedSharedSnapshots = 0;\n  }\n\n  /**\n   * @param {Snapshot} newSnapshot snapshot\n   * @param {Set<string>} capturedFiles files to snapshot/share\n   * @returns {void}\n   */\n  optimize(newSnapshot, capturedFiles) {\n    /**\n     * @param {SnapshotOptimizationEntry} entry optimization entry\n     * @returns {void}\n     */\n    const increaseSharedAndStoreOptimizationEntry = entry => {\n      if (entry.children !== undefined) {\n        for (const child of entry.children) {\n          increaseSharedAndStoreOptimizationEntry(child);\n        }\n      }\n      entry.shared++;\n      storeOptimizationEntry(entry);\n    };\n    /**\n     * @param {SnapshotOptimizationEntry} entry optimization entry\n     * @returns {void}\n     */\n    const storeOptimizationEntry = entry => {\n      for (const path of (/** @type {SnapshotContent} */\n      entry.snapshotContent)) {\n        const old = /** @type {SnapshotOptimizationEntry} */\n        this._map.get(path);\n        if (old.shared < entry.shared) {\n          this._map.set(path, entry);\n        }\n        capturedFiles.delete(path);\n      }\n    };\n\n    /** @type {SnapshotOptimizationEntry | undefined} */\n    let newOptimizationEntry;\n    const capturedFilesSize = capturedFiles.size;\n\n    /** @type {Set<SnapshotOptimizationEntry> | undefined} */\n    const optimizationEntries = new Set();\n    for (const path of capturedFiles) {\n      const optimizationEntry = this._map.get(path);\n      if (optimizationEntry === undefined) {\n        if (newOptimizationEntry === undefined) {\n          newOptimizationEntry = {\n            snapshot: newSnapshot,\n            shared: 0,\n            snapshotContent: undefined,\n            children: undefined\n          };\n        }\n        this._map.set(path, newOptimizationEntry);\n        continue;\n      } else {\n        optimizationEntries.add(optimizationEntry);\n      }\n    }\n    optimizationEntriesLabel: for (const optimizationEntry of optimizationEntries) {\n      const snapshot = optimizationEntry.snapshot;\n      if (optimizationEntry.shared > 0) {\n        // It's a shared snapshot\n        // We can't change it, so we can only use it when all files match\n        // and startTime is compatible\n        if (this._useStartTime && newSnapshot.startTime && (!snapshot.startTime || snapshot.startTime > newSnapshot.startTime)) {\n          continue;\n        }\n        const nonSharedFiles = new Set();\n        const snapshotContent = /** @type {NonNullable<SnapshotOptimizationEntry[\"snapshotContent\"]>} */\n        optimizationEntry.snapshotContent;\n        const snapshotEntries = /** @type {SnapshotOptimizationValue<U, T>} */\n        this._get(snapshot);\n        for (const path of snapshotContent) {\n          if (!capturedFiles.has(path)) {\n            if (!snapshotEntries.has(path)) {\n              // File is not shared and can't be removed from the snapshot\n              // because it's in a child of the snapshot\n              continue optimizationEntriesLabel;\n            }\n            nonSharedFiles.add(path);\n            continue;\n          }\n        }\n        if (nonSharedFiles.size === 0) {\n          // The complete snapshot is shared\n          // add it as child\n          newSnapshot.addChild(snapshot);\n          increaseSharedAndStoreOptimizationEntry(optimizationEntry);\n          this._statReusedSharedSnapshots++;\n        } else {\n          // Only a part of the snapshot is shared\n          const sharedCount = snapshotContent.size - nonSharedFiles.size;\n          if (sharedCount < MIN_COMMON_SNAPSHOT_SIZE) {\n            // Common part it too small\n            continue;\n          }\n          // Extract common timestamps from both snapshots\n          let commonMap;\n          if (this._isSet) {\n            commonMap = new Set();\n            for (const path of (/** @type {Set<string>} */snapshotEntries)) {\n              if (nonSharedFiles.has(path)) continue;\n              commonMap.add(path);\n              snapshotEntries.delete(path);\n            }\n          } else {\n            commonMap = new Map();\n            const map = /** @type {Map<string, T>} */snapshotEntries;\n            for (const [path, value] of map) {\n              if (nonSharedFiles.has(path)) continue;\n              commonMap.set(path, value);\n              snapshotEntries.delete(path);\n            }\n          }\n          // Create and attach snapshot\n          const commonSnapshot = new Snapshot();\n          if (this._useStartTime) {\n            commonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot);\n          }\n          this._set(commonSnapshot, /** @type {SnapshotOptimizationValue<U, T>} */commonMap);\n          newSnapshot.addChild(commonSnapshot);\n          snapshot.addChild(commonSnapshot);\n          // Create optimization entry\n          const newEntry = {\n            snapshot: commonSnapshot,\n            shared: optimizationEntry.shared + 1,\n            snapshotContent: new Set(commonMap.keys()),\n            children: undefined\n          };\n          if (optimizationEntry.children === undefined) optimizationEntry.children = new Set();\n          optimizationEntry.children.add(newEntry);\n          storeOptimizationEntry(newEntry);\n          this._statSharedSnapshots++;\n        }\n      } else {\n        // It's a unshared snapshot\n        // We can extract a common shared snapshot\n        // with all common files\n        const snapshotEntries = this._get(snapshot);\n        if (snapshotEntries === undefined) {\n          // Incomplete snapshot, that can't be used\n          continue;\n        }\n        let commonMap;\n        if (this._isSet) {\n          commonMap = new Set();\n          const set = /** @type {Set<string>} */snapshotEntries;\n          if (capturedFiles.size < set.size) {\n            for (const path of capturedFiles) {\n              if (set.has(path)) commonMap.add(path);\n            }\n          } else {\n            for (const path of set) {\n              if (capturedFiles.has(path)) commonMap.add(path);\n            }\n          }\n        } else {\n          commonMap = new Map();\n          const map = /** @type {Map<string, T>} */snapshotEntries;\n          for (const path of capturedFiles) {\n            const ts = map.get(path);\n            if (ts === undefined) continue;\n            commonMap.set(path, ts);\n          }\n        }\n        if (commonMap.size < MIN_COMMON_SNAPSHOT_SIZE) {\n          // Common part it too small\n          continue;\n        }\n        // Create and attach snapshot\n        const commonSnapshot = new Snapshot();\n        if (this._useStartTime) {\n          commonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot);\n        }\n        this._set(commonSnapshot, /** @type {SnapshotOptimizationValue<U, T>} */\n        commonMap);\n        newSnapshot.addChild(commonSnapshot);\n        snapshot.addChild(commonSnapshot);\n        // Remove files from snapshot\n        for (const path of commonMap.keys()) snapshotEntries.delete(path);\n        const sharedCount = commonMap.size;\n        this._statItemsUnshared -= sharedCount;\n        this._statItemsShared += sharedCount;\n        // Create optimization entry\n        storeOptimizationEntry({\n          snapshot: commonSnapshot,\n          shared: 2,\n          snapshotContent: new Set(commonMap.keys()),\n          children: undefined\n        });\n        this._statSharedSnapshots++;\n      }\n    }\n    const unshared = capturedFiles.size;\n    this._statItemsUnshared += unshared;\n    this._statItemsShared += capturedFilesSize - unshared;\n  }\n}\n\n/**\n * @param {string} str input\n * @returns {string} result\n */\nconst parseString = str => {\n  if (str[0] === \"'\" || str[0] === \"`\") str = `\"${str.slice(1, -1).replace(/\"/g, '\\\\\"')}\"`;\n  return JSON.parse(str);\n};\n\n/* istanbul ignore next */\n/**\n * @param {number} mtime mtime\n */\nconst applyMtime = mtime => {\n  if (FS_ACCURACY > 1 && mtime % 2 !== 0) FS_ACCURACY = 1;else if (FS_ACCURACY > 10 && mtime % 20 !== 0) FS_ACCURACY = 10;else if (FS_ACCURACY > 100 && mtime % 200 !== 0) FS_ACCURACY = 100;else if (FS_ACCURACY > 1000 && mtime % 2000 !== 0) FS_ACCURACY = 1000;\n};\n\n/**\n * @template T\n * @template K\n * @param {Map<T, K> | undefined} a source map\n * @param {Map<T, K> | undefined} b joining map\n * @returns {Map<T, K>} joined map\n */\nconst mergeMaps = (a, b) => {\n  if (!b || b.size === 0) return /** @type {Map<T, K>} */a;\n  if (!a || a.size === 0) return /** @type {Map<T, K>} */b;\n  /** @type {Map<T, K>} */\n  const map = new Map(a);\n  for (const [key, value] of b) {\n    map.set(key, value);\n  }\n  return map;\n};\n\n/**\n * @template T\n * @param {Set<T> | undefined} a source map\n * @param {Set<T> | undefined} b joining map\n * @returns {Set<T>} joined map\n */\nconst mergeSets = (a, b) => {\n  if (!b || b.size === 0) return /** @type {Set<T>} */a;\n  if (!a || a.size === 0) return /** @type {Set<T>} */b;\n  /** @type {Set<T>} */\n  const map = new Set(a);\n  for (const item of b) {\n    map.add(item);\n  }\n  return map;\n};\n\n/**\n * Finding file or directory to manage\n * @param {string} managedPath path that is managing by {@link FileSystemInfo}\n * @param {string} path path to file or directory\n * @returns {string|null} managed item\n * @example\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package/index.js'\n * ) === '/Users/user/my-project/node_modules/package'\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package1/node_modules/package2'\n * ) === '/Users/user/my-project/node_modules/package1/node_modules/package2'\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/.bin/script.js'\n * ) === null // hidden files are disallowed as managed items\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package'\n * ) === '/Users/user/my-project/node_modules/package'\n */\nconst getManagedItem = (managedPath, path) => {\n  let i = managedPath.length;\n  let slashes = 1;\n  let startingPosition = true;\n  loop: while (i < path.length) {\n    switch (path.charCodeAt(i)) {\n      case 47: // slash\n      case 92:\n        // backslash\n        if (--slashes === 0) break loop;\n        startingPosition = true;\n        break;\n      case 46:\n        // .\n        // hidden files are disallowed as managed items\n        // it's probably .yarn-integrity or .cache\n        if (startingPosition) return null;\n        break;\n      case 64:\n        // @\n        if (!startingPosition) return null;\n        slashes++;\n        break;\n      default:\n        startingPosition = false;\n        break;\n    }\n    i++;\n  }\n  if (i === path.length) slashes--;\n  // return null when path is incomplete\n  if (slashes !== 0) return null;\n  // if (path.slice(i + 1, i + 13) === \"node_modules\")\n  if (path.length >= i + 13 && path.charCodeAt(i + 1) === 110 && path.charCodeAt(i + 2) === 111 && path.charCodeAt(i + 3) === 100 && path.charCodeAt(i + 4) === 101 && path.charCodeAt(i + 5) === 95 && path.charCodeAt(i + 6) === 109 && path.charCodeAt(i + 7) === 111 && path.charCodeAt(i + 8) === 100 && path.charCodeAt(i + 9) === 117 && path.charCodeAt(i + 10) === 108 && path.charCodeAt(i + 11) === 101 && path.charCodeAt(i + 12) === 115) {\n    // if this is the end of the path\n    if (path.length === i + 13) {\n      // return the node_modules directory\n      // it's special\n      return path;\n    }\n    const c = path.charCodeAt(i + 13);\n    // if next symbol is slash or backslash\n    if (c === 47 || c === 92) {\n      // Managed subpath\n      return getManagedItem(path.slice(0, i + 14), path);\n    }\n  }\n  return path.slice(0, i);\n};\n\n/**\n * @template {ContextFileSystemInfoEntry | ContextTimestampAndHash} T\n * @param {T | null} entry entry\n * @returns {T[\"resolved\"] | null | undefined} the resolved entry\n */\nconst getResolvedTimestamp = entry => {\n  if (entry === null) return null;\n  if (entry.resolved !== undefined) return entry.resolved;\n  return entry.symlinks === undefined ? entry : undefined;\n};\n\n/**\n * @param {ContextHash | null} entry entry\n * @returns {string | null | undefined} the resolved entry\n */\nconst getResolvedHash = entry => {\n  if (entry === null) return null;\n  if (entry.resolved !== undefined) return entry.resolved;\n  return entry.symlinks === undefined ? entry.hash : undefined;\n};\n\n/**\n * @template T\n * @param {Set<T>} source source\n * @param {Set<T>} target target\n */\nconst addAll = (source, target) => {\n  for (const key of source) target.add(key);\n};\n\n/** @typedef {Set<string>} LoggedPaths */\n\n/**\n * Used to access information about the filesystem in a cached way\n */\nclass FileSystemInfo {\n  /**\n   * @param {InputFileSystem} fs file system\n   * @param {object} options options\n   * @param {Iterable<string | RegExp>=} options.unmanagedPaths paths that are not managed by a package manager and the contents are subject to change\n   * @param {Iterable<string | RegExp>=} options.managedPaths paths that are only managed by a package manager\n   * @param {Iterable<string | RegExp>=} options.immutablePaths paths that are immutable\n   * @param {Logger=} options.logger logger used to log invalid snapshots\n   * @param {string | Hash=} options.hashFunction the hash function to use\n   */\n  constructor(fs, {\n    unmanagedPaths = [],\n    managedPaths = [],\n    immutablePaths = [],\n    logger,\n    hashFunction = \"md4\"\n  } = {}) {\n    this.fs = fs;\n    this.logger = logger;\n    this._remainingLogs = logger ? 40 : 0;\n    /** @type {LoggedPaths | undefined} */\n    this._loggedPaths = logger ? new Set() : undefined;\n    this._hashFunction = hashFunction;\n    /** @type {WeakMap<Snapshot, boolean | (function((WebpackError | null)=, boolean=): void)[]>} */\n    this._snapshotCache = new WeakMap();\n    this._fileTimestampsOptimization = new SnapshotOptimization(s => s.hasFileTimestamps(), s => s.fileTimestamps, (s, v) => s.setFileTimestamps(v));\n    this._fileHashesOptimization = new SnapshotOptimization(s => s.hasFileHashes(), s => s.fileHashes, (s, v) => s.setFileHashes(v), false);\n    this._fileTshsOptimization = new SnapshotOptimization(s => s.hasFileTshs(), s => s.fileTshs, (s, v) => s.setFileTshs(v));\n    this._contextTimestampsOptimization = new SnapshotOptimization(s => s.hasContextTimestamps(), s => s.contextTimestamps, (s, v) => s.setContextTimestamps(v));\n    this._contextHashesOptimization = new SnapshotOptimization(s => s.hasContextHashes(), s => s.contextHashes, (s, v) => s.setContextHashes(v), false);\n    this._contextTshsOptimization = new SnapshotOptimization(s => s.hasContextTshs(), s => s.contextTshs, (s, v) => s.setContextTshs(v));\n    this._missingExistenceOptimization = new SnapshotOptimization(s => s.hasMissingExistence(), s => s.missingExistence, (s, v) => s.setMissingExistence(v), false);\n    this._managedItemInfoOptimization = new SnapshotOptimization(s => s.hasManagedItemInfo(), s => s.managedItemInfo, (s, v) => s.setManagedItemInfo(v), false);\n    this._managedFilesOptimization = new SnapshotOptimization(s => s.hasManagedFiles(), s => s.managedFiles, (s, v) => s.setManagedFiles(v), false, true);\n    this._managedContextsOptimization = new SnapshotOptimization(s => s.hasManagedContexts(), s => s.managedContexts, (s, v) => s.setManagedContexts(v), false, true);\n    this._managedMissingOptimization = new SnapshotOptimization(s => s.hasManagedMissing(), s => s.managedMissing, (s, v) => s.setManagedMissing(v), false, true);\n    /** @type {StackedCacheMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n    this._fileTimestamps = new StackedCacheMap();\n    /** @type {Map<string, string | null>} */\n    this._fileHashes = new Map();\n    /** @type {Map<string, TimestampAndHash | string>} */\n    this._fileTshs = new Map();\n    /** @type {StackedCacheMap<string, ContextFileSystemInfoEntry | \"ignore\" | null>} */\n    this._contextTimestamps = new StackedCacheMap();\n    /** @type {Map<string, ContextHash>} */\n    this._contextHashes = new Map();\n    /** @type {Map<string, ContextTimestampAndHash>} */\n    this._contextTshs = new Map();\n    /** @type {Map<string, string>} */\n    this._managedItems = new Map();\n    /** @type {AsyncQueue<string, string, FileSystemInfoEntry>} */\n    this.fileTimestampQueue = new AsyncQueue({\n      name: \"file timestamp\",\n      parallelism: 30,\n      processor: this._readFileTimestamp.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, string>} */\n    this.fileHashQueue = new AsyncQueue({\n      name: \"file hash\",\n      parallelism: 10,\n      processor: this._readFileHash.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, ContextFileSystemInfoEntry>} */\n    this.contextTimestampQueue = new AsyncQueue({\n      name: \"context timestamp\",\n      parallelism: 2,\n      processor: this._readContextTimestamp.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, ContextHash>} */\n    this.contextHashQueue = new AsyncQueue({\n      name: \"context hash\",\n      parallelism: 2,\n      processor: this._readContextHash.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, ContextTimestampAndHash>} */\n    this.contextTshQueue = new AsyncQueue({\n      name: \"context hash and timestamp\",\n      parallelism: 2,\n      processor: this._readContextTimestampAndHash.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, string>} */\n    this.managedItemQueue = new AsyncQueue({\n      name: \"managed item info\",\n      parallelism: 10,\n      processor: this._getManagedItemInfo.bind(this)\n    });\n    /** @type {AsyncQueue<string, string, Set<string>>} */\n    this.managedItemDirectoryQueue = new AsyncQueue({\n      name: \"managed item directory info\",\n      parallelism: 10,\n      processor: this._getManagedItemDirectoryInfo.bind(this)\n    });\n    const _unmanagedPaths = Array.from(unmanagedPaths);\n    this.unmanagedPathsWithSlash = /** @type {string[]} */_unmanagedPaths.filter(p => typeof p === \"string\").map(p => join(fs, p, \"_\").slice(0, -1));\n    this.unmanagedPathsRegExps = /** @type {RegExp[]} */\n    _unmanagedPaths.filter(p => typeof p !== \"string\");\n    this.managedPaths = Array.from(managedPaths);\n    this.managedPathsWithSlash = /** @type {string[]} */this.managedPaths.filter(p => typeof p === \"string\").map(p => join(fs, p, \"_\").slice(0, -1));\n    this.managedPathsRegExps = /** @type {RegExp[]} */\n    this.managedPaths.filter(p => typeof p !== \"string\");\n    this.immutablePaths = Array.from(immutablePaths);\n    this.immutablePathsWithSlash = /** @type {string[]} */this.immutablePaths.filter(p => typeof p === \"string\").map(p => join(fs, p, \"_\").slice(0, -1));\n    this.immutablePathsRegExps = /** @type {RegExp[]} */\n    this.immutablePaths.filter(p => typeof p !== \"string\");\n    this._cachedDeprecatedFileTimestamps = undefined;\n    this._cachedDeprecatedContextTimestamps = undefined;\n    this._warnAboutExperimentalEsmTracking = false;\n    this._statCreatedSnapshots = 0;\n    this._statTestedSnapshotsCached = 0;\n    this._statTestedSnapshotsNotCached = 0;\n    this._statTestedChildrenCached = 0;\n    this._statTestedChildrenNotCached = 0;\n    this._statTestedEntries = 0;\n  }\n  logStatistics() {\n    const logger = /** @type {Logger} */this.logger;\n    /**\n     * @param {string} header header\n     * @param {string | undefined} message message\n     */\n    const logWhenMessage = (header, message) => {\n      if (message) {\n        logger.log(`${header}: ${message}`);\n      }\n    };\n    logger.log(`${this._statCreatedSnapshots} new snapshots created`);\n    logger.log(`${this._statTestedSnapshotsNotCached && Math.round(this._statTestedSnapshotsNotCached * 100 / (this._statTestedSnapshotsCached + this._statTestedSnapshotsNotCached))}% root snapshot uncached (${this._statTestedSnapshotsNotCached} / ${this._statTestedSnapshotsCached + this._statTestedSnapshotsNotCached})`);\n    logger.log(`${this._statTestedChildrenNotCached && Math.round(this._statTestedChildrenNotCached * 100 / (this._statTestedChildrenCached + this._statTestedChildrenNotCached))}% children snapshot uncached (${this._statTestedChildrenNotCached} / ${this._statTestedChildrenCached + this._statTestedChildrenNotCached})`);\n    logger.log(`${this._statTestedEntries} entries tested`);\n    logger.log(`File info in cache: ${this._fileTimestamps.size} timestamps ${this._fileHashes.size} hashes ${this._fileTshs.size} timestamp hash combinations`);\n    logWhenMessage(\"File timestamp snapshot optimization\", this._fileTimestampsOptimization.getStatisticMessage());\n    logWhenMessage(\"File hash snapshot optimization\", this._fileHashesOptimization.getStatisticMessage());\n    logWhenMessage(\"File timestamp hash combination snapshot optimization\", this._fileTshsOptimization.getStatisticMessage());\n    logger.log(`Directory info in cache: ${this._contextTimestamps.size} timestamps ${this._contextHashes.size} hashes ${this._contextTshs.size} timestamp hash combinations`);\n    logWhenMessage(\"Directory timestamp snapshot optimization\", this._contextTimestampsOptimization.getStatisticMessage());\n    logWhenMessage(\"Directory hash snapshot optimization\", this._contextHashesOptimization.getStatisticMessage());\n    logWhenMessage(\"Directory timestamp hash combination snapshot optimization\", this._contextTshsOptimization.getStatisticMessage());\n    logWhenMessage(\"Missing items snapshot optimization\", this._missingExistenceOptimization.getStatisticMessage());\n    logger.log(`Managed items info in cache: ${this._managedItems.size} items`);\n    logWhenMessage(\"Managed items snapshot optimization\", this._managedItemInfoOptimization.getStatisticMessage());\n    logWhenMessage(\"Managed files snapshot optimization\", this._managedFilesOptimization.getStatisticMessage());\n    logWhenMessage(\"Managed contexts snapshot optimization\", this._managedContextsOptimization.getStatisticMessage());\n    logWhenMessage(\"Managed missing snapshot optimization\", this._managedMissingOptimization.getStatisticMessage());\n  }\n\n  /**\n   * @param {string} path path\n   * @param {string} reason reason\n   * @param {any[]} args arguments\n   */\n  _log(path, reason, ...args) {\n    const key = path + reason;\n    const loggedPaths = /** @type {LoggedPaths} */this._loggedPaths;\n    if (loggedPaths.has(key)) return;\n    loggedPaths.add(key);\n    /** @type {Logger} */\n    this.logger.debug(`${path} invalidated because ${reason}`, ...args);\n    if (--this._remainingLogs === 0) {\n      /** @type {Logger} */\n      this.logger.debug(\"Logging limit has been reached and no further logging will be emitted by FileSystemInfo\");\n    }\n  }\n  clear() {\n    this._remainingLogs = this.logger ? 40 : 0;\n    if (this._loggedPaths !== undefined) this._loggedPaths.clear();\n    this._snapshotCache = new WeakMap();\n    this._fileTimestampsOptimization.clear();\n    this._fileHashesOptimization.clear();\n    this._fileTshsOptimization.clear();\n    this._contextTimestampsOptimization.clear();\n    this._contextHashesOptimization.clear();\n    this._contextTshsOptimization.clear();\n    this._missingExistenceOptimization.clear();\n    this._managedItemInfoOptimization.clear();\n    this._managedFilesOptimization.clear();\n    this._managedContextsOptimization.clear();\n    this._managedMissingOptimization.clear();\n    this._fileTimestamps.clear();\n    this._fileHashes.clear();\n    this._fileTshs.clear();\n    this._contextTimestamps.clear();\n    this._contextHashes.clear();\n    this._contextTshs.clear();\n    this._managedItems.clear();\n    this._managedItems.clear();\n    this._cachedDeprecatedFileTimestamps = undefined;\n    this._cachedDeprecatedContextTimestamps = undefined;\n    this._statCreatedSnapshots = 0;\n    this._statTestedSnapshotsCached = 0;\n    this._statTestedSnapshotsNotCached = 0;\n    this._statTestedChildrenCached = 0;\n    this._statTestedChildrenNotCached = 0;\n    this._statTestedEntries = 0;\n  }\n\n  /**\n   * @param {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} map timestamps\n   * @param {boolean=} immutable if 'map' is immutable and FileSystemInfo can keep referencing it\n   * @returns {void}\n   */\n  addFileTimestamps(map, immutable) {\n    this._fileTimestamps.addAll(map, immutable);\n    this._cachedDeprecatedFileTimestamps = undefined;\n  }\n\n  /**\n   * @param {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} map timestamps\n   * @param {boolean=} immutable if 'map' is immutable and FileSystemInfo can keep referencing it\n   * @returns {void}\n   */\n  addContextTimestamps(map, immutable) {\n    this._contextTimestamps.addAll(map, immutable);\n    this._cachedDeprecatedContextTimestamps = undefined;\n  }\n\n  /**\n   * @param {string} path file path\n   * @param {function((WebpackError | null)=, (FileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n   * @returns {void}\n   */\n  getFileTimestamp(path, callback) {\n    const cache = this._fileTimestamps.get(path);\n    if (cache !== undefined) return callback(null, cache);\n    this.fileTimestampQueue.add(path, callback);\n  }\n\n  /**\n   * @param {string} path context path\n   * @param {function((WebpackError | null)=, (ResolvedContextFileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n   * @returns {void}\n   */\n  getContextTimestamp(path, callback) {\n    const cache = this._contextTimestamps.get(path);\n    if (cache !== undefined) {\n      if (cache === \"ignore\") return callback(null, \"ignore\");\n      const resolved = getResolvedTimestamp(cache);\n      if (resolved !== undefined) return callback(null, resolved);\n      return this._resolveContextTimestamp(/** @type {ResolvedContextFileSystemInfoEntry} */\n      cache, callback);\n    }\n    this.contextTimestampQueue.add(path, (err, _entry) => {\n      if (err) return callback(err);\n      const entry = /** @type {ContextFileSystemInfoEntry} */_entry;\n      const resolved = getResolvedTimestamp(entry);\n      if (resolved !== undefined) return callback(null, resolved);\n      this._resolveContextTimestamp(entry, callback);\n    });\n  }\n\n  /**\n   * @param {string} path context path\n   * @param {function((WebpackError | null)=, (ContextFileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n   * @returns {void}\n   */\n  _getUnresolvedContextTimestamp(path, callback) {\n    const cache = this._contextTimestamps.get(path);\n    if (cache !== undefined) return callback(null, cache);\n    this.contextTimestampQueue.add(path, callback);\n  }\n\n  /**\n   * @param {string} path file path\n   * @param {function((WebpackError | null)=, (string | null)=): void} callback callback function\n   * @returns {void}\n   */\n  getFileHash(path, callback) {\n    const cache = this._fileHashes.get(path);\n    if (cache !== undefined) return callback(null, cache);\n    this.fileHashQueue.add(path, callback);\n  }\n\n  /**\n   * @param {string} path context path\n   * @param {function((WebpackError | null)=, string=): void} callback callback function\n   * @returns {void}\n   */\n  getContextHash(path, callback) {\n    const cache = this._contextHashes.get(path);\n    if (cache !== undefined) {\n      const resolved = getResolvedHash(cache);\n      if (resolved !== undefined) return callback(null, /** @type {string} */resolved);\n      return this._resolveContextHash(cache, callback);\n    }\n    this.contextHashQueue.add(path, (err, _entry) => {\n      if (err) return callback(err);\n      const entry = /** @type {ContextHash} */_entry;\n      const resolved = getResolvedHash(entry);\n      if (resolved !== undefined) return callback(null, /** @type {string} */resolved);\n      this._resolveContextHash(entry, callback);\n    });\n  }\n\n  /**\n   * @param {string} path context path\n   * @param {function((WebpackError | null)=, (ContextHash | null)=): void} callback callback function\n   * @returns {void}\n   */\n  _getUnresolvedContextHash(path, callback) {\n    const cache = this._contextHashes.get(path);\n    if (cache !== undefined) return callback(null, cache);\n    this.contextHashQueue.add(path, callback);\n  }\n\n  /**\n   * @param {string} path context path\n   * @param {function((WebpackError | null)=, (ResolvedContextTimestampAndHash | null)=): void} callback callback function\n   * @returns {void}\n   */\n  getContextTsh(path, callback) {\n    const cache = this._contextTshs.get(path);\n    if (cache !== undefined) {\n      const resolved = getResolvedTimestamp(cache);\n      if (resolved !== undefined) return callback(null, resolved);\n      return this._resolveContextTsh(cache, callback);\n    }\n    this.contextTshQueue.add(path, (err, _entry) => {\n      if (err) return callback(err);\n      const entry = /** @type {ContextTimestampAndHash} */_entry;\n      const resolved = getResolvedTimestamp(entry);\n      if (resolved !== undefined) return callback(null, resolved);\n      this._resolveContextTsh(entry, callback);\n    });\n  }\n\n  /**\n   * @param {string} path context path\n   * @param {function((WebpackError | null)=, (ContextTimestampAndHash | null)=): void} callback callback function\n   * @returns {void}\n   */\n  _getUnresolvedContextTsh(path, callback) {\n    const cache = this._contextTshs.get(path);\n    if (cache !== undefined) return callback(null, cache);\n    this.contextTshQueue.add(path, callback);\n  }\n  _createBuildDependenciesResolvers() {\n    const resolveContext = createResolver({\n      resolveToContext: true,\n      exportsFields: [],\n      fileSystem: this.fs\n    });\n    const resolveCjs = createResolver({\n      extensions: [\".js\", \".json\", \".node\"],\n      conditionNames: [\"require\", \"node\"],\n      exportsFields: [\"exports\"],\n      fileSystem: this.fs\n    });\n    const resolveCjsAsChild = createResolver({\n      extensions: [\".js\", \".json\", \".node\"],\n      conditionNames: [\"require\", \"node\"],\n      exportsFields: [],\n      fileSystem: this.fs\n    });\n    const resolveEsm = createResolver({\n      extensions: [\".js\", \".json\", \".node\"],\n      fullySpecified: true,\n      conditionNames: [\"import\", \"node\"],\n      exportsFields: [\"exports\"],\n      fileSystem: this.fs\n    });\n    return {\n      resolveContext,\n      resolveEsm,\n      resolveCjs,\n      resolveCjsAsChild\n    };\n  }\n\n  /**\n   * @param {string} context context directory\n   * @param {Iterable<string>} deps dependencies\n   * @param {function((Error | null)=, ResolveBuildDependenciesResult=): void} callback callback function\n   * @returns {void}\n   */\n  resolveBuildDependencies(context, deps, callback) {\n    const {\n      resolveContext,\n      resolveEsm,\n      resolveCjs,\n      resolveCjsAsChild\n    } = this._createBuildDependenciesResolvers();\n\n    /** @type {Set<string>} */\n    const files = new Set();\n    /** @type {Set<string>} */\n    const fileSymlinks = new Set();\n    /** @type {Set<string>} */\n    const directories = new Set();\n    /** @type {Set<string>} */\n    const directorySymlinks = new Set();\n    /** @type {Set<string>} */\n    const missing = new Set();\n    /** @type {Set<string>} */\n    const resolveFiles = new Set();\n    /** @type {Set<string>} */\n    const resolveDirectories = new Set();\n    /** @type {Set<string>} */\n    const resolveMissing = new Set();\n    /** @type {Map<string, string | false | undefined>} */\n    const resolveResults = new Map();\n    const invalidResolveResults = new Set();\n    const resolverContext = {\n      fileDependencies: resolveFiles,\n      contextDependencies: resolveDirectories,\n      missingDependencies: resolveMissing\n    };\n    /**\n     * @param {undefined | boolean | string} expected expected result\n     * @returns {string} expected result\n     */\n    const expectedToString = expected => expected ? ` (expected ${expected})` : \"\";\n    /** @typedef {{ type: JobType, context: string | undefined, path: string, issuer: Job | undefined, expected: undefined | boolean | string }} Job */\n\n    /**\n     * @param {Job} job job\n     * @returns {`resolve commonjs file ${string}${string}`|`resolve esm file ${string}${string}`|`resolve esm ${string}${string}`|`resolve directory ${string}`|`file ${string}`|`unknown ${string} ${string}`|`resolve commonjs ${string}${string}`|`directory ${string}`|`file dependencies ${string}`|`directory dependencies ${string}`} result\n     */\n    const jobToString = job => {\n      switch (job.type) {\n        case RBDT_RESOLVE_CJS:\n          return `resolve commonjs ${job.path}${expectedToString(job.expected)}`;\n        case RBDT_RESOLVE_ESM:\n          return `resolve esm ${job.path}${expectedToString(job.expected)}`;\n        case RBDT_RESOLVE_DIRECTORY:\n          return `resolve directory ${job.path}`;\n        case RBDT_RESOLVE_CJS_FILE:\n          return `resolve commonjs file ${job.path}${expectedToString(job.expected)}`;\n        case RBDT_RESOLVE_ESM_FILE:\n          return `resolve esm file ${job.path}${expectedToString(job.expected)}`;\n        case RBDT_DIRECTORY:\n          return `directory ${job.path}`;\n        case RBDT_FILE:\n          return `file ${job.path}`;\n        case RBDT_DIRECTORY_DEPENDENCIES:\n          return `directory dependencies ${job.path}`;\n        case RBDT_FILE_DEPENDENCIES:\n          return `file dependencies ${job.path}`;\n      }\n      return `unknown ${job.type} ${job.path}`;\n    };\n    /**\n     * @param {Job} job job\n     * @returns {string} string value\n     */\n    const pathToString = job => {\n      let result = ` at ${jobToString(job)}`;\n      /** @type {Job | undefined} */\n      job = job.issuer;\n      while (job !== undefined) {\n        result += `\\n at ${jobToString(job)}`;\n        job = /** @type {Job} */job.issuer;\n      }\n      return result;\n    };\n    const logger = /** @type {Logger} */this.logger;\n    processAsyncTree(Array.from(deps, dep => (/** @type {Job} */{\n      type: RBDT_RESOLVE_CJS,\n      context,\n      path: dep,\n      expected: undefined,\n      issuer: undefined\n    })), 20, (job, push, callback) => {\n      const {\n        type,\n        context,\n        path,\n        expected\n      } = job;\n      /**\n       * @param {string} path path\n       * @returns {void}\n       */\n      const resolveDirectory = path => {\n        const key = `d\\n${context}\\n${path}`;\n        if (resolveResults.has(key)) {\n          return callback();\n        }\n        resolveResults.set(key, undefined);\n        resolveContext(/** @type {string} */context, path, resolverContext, (err, _, result) => {\n          if (err) {\n            if (expected === false) {\n              resolveResults.set(key, false);\n              return callback();\n            }\n            invalidResolveResults.add(key);\n            err.message += `\\nwhile resolving '${path}' in ${context} to a directory`;\n            return callback(err);\n          }\n          const resultPath = /** @type {ResolveRequest} */result.path;\n          resolveResults.set(key, resultPath);\n          push({\n            type: RBDT_DIRECTORY,\n            context: undefined,\n            path: (/** @type {string} */resultPath),\n            expected: undefined,\n            issuer: job\n          });\n          callback();\n        });\n      };\n      /**\n       * @param {string} path path\n       * @param {(\"f\" | \"c\" | \"e\")=} symbol symbol\n       * @param {(ResolveFunctionAsync)=} resolve resolve fn\n       * @returns {void}\n       */\n      const resolveFile = (path, symbol, resolve) => {\n        const key = `${symbol}\\n${context}\\n${path}`;\n        if (resolveResults.has(key)) {\n          return callback();\n        }\n        resolveResults.set(key, undefined);\n        /** @type {ResolveFunctionAsync} */\n        resolve(/** @type {string} */context, path, resolverContext, (err, _, result) => {\n          if (typeof expected === \"string\") {\n            if (!err && result && result.path === expected) {\n              resolveResults.set(key, result.path);\n            } else {\n              invalidResolveResults.add(key);\n              logger.warn(`Resolving '${path}' in ${context} for build dependencies doesn't lead to expected result '${expected}', but to '${err || result && result.path}' instead. Resolving dependencies are ignored for this path.\\n${pathToString(job)}`);\n            }\n          } else {\n            if (err) {\n              if (expected === false) {\n                resolveResults.set(key, false);\n                return callback();\n              }\n              invalidResolveResults.add(key);\n              err.message += `\\nwhile resolving '${path}' in ${context} as file\\n${pathToString(job)}`;\n              return callback(err);\n            }\n            const resultPath = /** @type {ResolveRequest} */result.path;\n            resolveResults.set(key, resultPath);\n            push({\n              type: RBDT_FILE,\n              context: undefined,\n              path: (/** @type {string} */resultPath),\n              expected: undefined,\n              issuer: job\n            });\n          }\n          callback();\n        });\n      };\n      switch (type) {\n        case RBDT_RESOLVE_CJS:\n          {\n            const isDirectory = /[\\\\/]$/.test(path);\n            if (isDirectory) {\n              resolveDirectory(path.slice(0, -1));\n            } else {\n              resolveFile(path, \"f\", resolveCjs);\n            }\n            break;\n          }\n        case RBDT_RESOLVE_ESM:\n          {\n            const isDirectory = /[\\\\/]$/.test(path);\n            if (isDirectory) {\n              resolveDirectory(path.slice(0, -1));\n            } else {\n              resolveFile(path);\n            }\n            break;\n          }\n        case RBDT_RESOLVE_DIRECTORY:\n          {\n            resolveDirectory(path);\n            break;\n          }\n        case RBDT_RESOLVE_CJS_FILE:\n          {\n            resolveFile(path, \"f\", resolveCjs);\n            break;\n          }\n        case RBDT_RESOLVE_CJS_FILE_AS_CHILD:\n          {\n            resolveFile(path, \"c\", resolveCjsAsChild);\n            break;\n          }\n        case RBDT_RESOLVE_ESM_FILE:\n          {\n            resolveFile(path, \"e\", resolveEsm);\n            break;\n          }\n        case RBDT_FILE:\n          {\n            if (files.has(path)) {\n              callback();\n              break;\n            }\n            files.add(path);\n            /** @type {NonNullable<InputFileSystem[\"realpath\"]>} */\n            this.fs.realpath(path, (err, _realPath) => {\n              if (err) return callback(err);\n              const realPath = /** @type {string} */_realPath;\n              if (realPath !== path) {\n                fileSymlinks.add(path);\n                resolveFiles.add(path);\n                if (files.has(realPath)) return callback();\n                files.add(realPath);\n              }\n              push({\n                type: RBDT_FILE_DEPENDENCIES,\n                context: undefined,\n                path: realPath,\n                expected: undefined,\n                issuer: job\n              });\n              callback();\n            });\n            break;\n          }\n        case RBDT_DIRECTORY:\n          {\n            if (directories.has(path)) {\n              callback();\n              break;\n            }\n            directories.add(path);\n            /** @type {NonNullable<InputFileSystem[\"realpath\"]>} */\n            this.fs.realpath(path, (err, _realPath) => {\n              if (err) return callback(err);\n              const realPath = /** @type {string} */_realPath;\n              if (realPath !== path) {\n                directorySymlinks.add(path);\n                resolveFiles.add(path);\n                if (directories.has(realPath)) return callback();\n                directories.add(realPath);\n              }\n              push({\n                type: RBDT_DIRECTORY_DEPENDENCIES,\n                context: undefined,\n                path: realPath,\n                expected: undefined,\n                issuer: job\n              });\n              callback();\n            });\n            break;\n          }\n        case RBDT_FILE_DEPENDENCIES:\n          {\n            // Check for known files without dependencies\n            if (/\\.json5?$|\\.yarn-integrity$|yarn\\.lock$|\\.ya?ml/.test(path)) {\n              process.nextTick(callback);\n              break;\n            }\n            // Check commonjs cache for the module\n            /** @type {NodeModule | undefined} */\n            const module = require.cache[path];\n            if (module && Array.isArray(module.children)) {\n              children: for (const child of module.children) {\n                const childPath = child.filename;\n                if (childPath) {\n                  push({\n                    type: RBDT_FILE,\n                    context: undefined,\n                    path: childPath,\n                    expected: undefined,\n                    issuer: job\n                  });\n                  const context = dirname(this.fs, path);\n                  for (const modulePath of module.paths) {\n                    if (childPath.startsWith(modulePath)) {\n                      const subPath = childPath.slice(modulePath.length + 1);\n                      const packageMatch = /^(@[^\\\\/]+[\\\\/])[^\\\\/]+/.exec(subPath);\n                      if (packageMatch) {\n                        push({\n                          type: RBDT_FILE,\n                          context: undefined,\n                          path: `${modulePath + childPath[modulePath.length] + packageMatch[0] + childPath[modulePath.length]}package.json`,\n                          expected: false,\n                          issuer: job\n                        });\n                      }\n                      let request = subPath.replace(/\\\\/g, \"/\");\n                      if (request.endsWith(\".js\")) request = request.slice(0, -3);\n                      push({\n                        type: RBDT_RESOLVE_CJS_FILE_AS_CHILD,\n                        context,\n                        path: request,\n                        expected: child.filename,\n                        issuer: job\n                      });\n                      continue children;\n                    }\n                  }\n                  let request = relative(this.fs, context, childPath);\n                  if (request.endsWith(\".js\")) request = request.slice(0, -3);\n                  request = request.replace(/\\\\/g, \"/\");\n                  if (!request.startsWith(\"../\") && !isAbsolute(request)) {\n                    request = `./${request}`;\n                  }\n                  push({\n                    type: RBDT_RESOLVE_CJS_FILE,\n                    context,\n                    path: request,\n                    expected: child.filename,\n                    issuer: job\n                  });\n                }\n              }\n            } else if (supportsEsm && /\\.m?js$/.test(path)) {\n              if (!this._warnAboutExperimentalEsmTracking) {\n                logger.log(\"Node.js doesn't offer a (nice) way to introspect the ESM dependency graph yet.\\n\" + \"Until a full solution is available webpack uses an experimental ESM tracking based on parsing.\\n\" + \"As best effort webpack parses the ESM files to guess dependencies. But this can lead to expensive and incorrect tracking.\");\n                this._warnAboutExperimentalEsmTracking = true;\n              }\n              const lexer = require(\"es-module-lexer\");\n              lexer.init.then(() => {\n                this.fs.readFile(path, (err, content) => {\n                  if (err) return callback(err);\n                  try {\n                    const context = dirname(this.fs, path);\n                    const source = /** @type {Buffer} */content.toString();\n                    const [imports] = lexer.parse(source);\n                    for (const imp of imports) {\n                      try {\n                        let dependency;\n                        if (imp.d === -1) {\n                          // import ... from \"...\"\n                          dependency = parseString(source.substring(imp.s - 1, imp.e + 1));\n                        } else if (imp.d > -1) {\n                          // import()\n                          const expr = source.substring(imp.s, imp.e).trim();\n                          dependency = parseString(expr);\n                        } else {\n                          // e.g. import.meta\n                          continue;\n                        }\n\n                        // we should not track Node.js build dependencies\n                        if (dependency.startsWith(\"node:\")) continue;\n                        if (builtinModules.has(dependency)) continue;\n                        push({\n                          type: RBDT_RESOLVE_ESM_FILE,\n                          context,\n                          path: dependency,\n                          expected: imp.d > -1 ? false : undefined,\n                          issuer: job\n                        });\n                      } catch (err1) {\n                        logger.warn(`Parsing of ${path} for build dependencies failed at 'import(${source.substring(imp.s, imp.e)})'.\\n` + \"Build dependencies behind this expression are ignored and might cause incorrect cache invalidation.\");\n                        logger.debug(pathToString(job));\n                        logger.debug(/** @type {Error} */err1.stack);\n                      }\n                    }\n                  } catch (err2) {\n                    logger.warn(`Parsing of ${path} for build dependencies failed and all dependencies of this file are ignored, which might cause incorrect cache invalidation..`);\n                    logger.debug(pathToString(job));\n                    logger.debug(/** @type {Error} */err2.stack);\n                  }\n                  process.nextTick(callback);\n                });\n              }, callback);\n              break;\n            } else {\n              logger.log(`Assuming ${path} has no dependencies as we were unable to assign it to any module system.`);\n              logger.debug(pathToString(job));\n            }\n            process.nextTick(callback);\n            break;\n          }\n        case RBDT_DIRECTORY_DEPENDENCIES:\n          {\n            const match = /(^.+[\\\\/]node_modules[\\\\/](?:@[^\\\\/]+[\\\\/])?[^\\\\/]+)/.exec(path);\n            const packagePath = match ? match[1] : path;\n            const packageJson = join(this.fs, packagePath, \"package.json\");\n            this.fs.readFile(packageJson, (err, content) => {\n              if (err) {\n                if (err.code === \"ENOENT\") {\n                  resolveMissing.add(packageJson);\n                  const parent = dirname(this.fs, packagePath);\n                  if (parent !== packagePath) {\n                    push({\n                      type: RBDT_DIRECTORY_DEPENDENCIES,\n                      context: undefined,\n                      path: parent,\n                      expected: undefined,\n                      issuer: job\n                    });\n                  }\n                  callback();\n                  return;\n                }\n                return callback(err);\n              }\n              resolveFiles.add(packageJson);\n              let packageData;\n              try {\n                packageData = JSON.parse(/** @type {Buffer} */content.toString(\"utf-8\"));\n              } catch (parseErr) {\n                return callback(/** @type {Error} */parseErr);\n              }\n              const depsObject = packageData.dependencies;\n              const optionalDepsObject = packageData.optionalDependencies;\n              const allDeps = new Set();\n              const optionalDeps = new Set();\n              if (typeof depsObject === \"object\" && depsObject) {\n                for (const dep of Object.keys(depsObject)) {\n                  allDeps.add(dep);\n                }\n              }\n              if (typeof optionalDepsObject === \"object\" && optionalDepsObject) {\n                for (const dep of Object.keys(optionalDepsObject)) {\n                  allDeps.add(dep);\n                  optionalDeps.add(dep);\n                }\n              }\n              for (const dep of allDeps) {\n                push({\n                  type: RBDT_RESOLVE_DIRECTORY,\n                  context: packagePath,\n                  path: dep,\n                  expected: !optionalDeps.has(dep),\n                  issuer: job\n                });\n              }\n              callback();\n            });\n            break;\n          }\n      }\n    }, err => {\n      if (err) return callback(err);\n      for (const l of fileSymlinks) files.delete(l);\n      for (const l of directorySymlinks) directories.delete(l);\n      for (const k of invalidResolveResults) resolveResults.delete(k);\n      callback(null, {\n        files,\n        directories,\n        missing,\n        resolveResults,\n        resolveDependencies: {\n          files: resolveFiles,\n          directories: resolveDirectories,\n          missing: resolveMissing\n        }\n      });\n    });\n  }\n\n  /**\n   * @param {Map<string, string | false>} resolveResults results from resolving\n   * @param {function((Error | null)=, boolean=): void} callback callback with true when resolveResults resolve the same way\n   * @returns {void}\n   */\n  checkResolveResultsValid(resolveResults, callback) {\n    const {\n      resolveCjs,\n      resolveCjsAsChild,\n      resolveEsm,\n      resolveContext\n    } = this._createBuildDependenciesResolvers();\n    asyncLib.eachLimit(resolveResults, 20, ([key, expectedResult], callback) => {\n      const [type, context, path] = key.split(\"\\n\");\n      switch (type) {\n        case \"d\":\n          resolveContext(context, path, {}, (err, _, result) => {\n            if (expectedResult === false) return callback(err ? undefined : INVALID);\n            if (err) return callback(err);\n            const resultPath = /** @type {ResolveRequest} */result.path;\n            if (resultPath !== expectedResult) return callback(INVALID);\n            callback();\n          });\n          break;\n        case \"f\":\n          resolveCjs(context, path, {}, (err, _, result) => {\n            if (expectedResult === false) return callback(err ? undefined : INVALID);\n            if (err) return callback(err);\n            const resultPath = /** @type {ResolveRequest} */result.path;\n            if (resultPath !== expectedResult) return callback(INVALID);\n            callback();\n          });\n          break;\n        case \"c\":\n          resolveCjsAsChild(context, path, {}, (err, _, result) => {\n            if (expectedResult === false) return callback(err ? undefined : INVALID);\n            if (err) return callback(err);\n            const resultPath = /** @type {ResolveRequest} */result.path;\n            if (resultPath !== expectedResult) return callback(INVALID);\n            callback();\n          });\n          break;\n        case \"e\":\n          resolveEsm(context, path, {}, (err, _, result) => {\n            if (expectedResult === false) return callback(err ? undefined : INVALID);\n            if (err) return callback(err);\n            const resultPath = /** @type {ResolveRequest} */result.path;\n            if (resultPath !== expectedResult) return callback(INVALID);\n            callback();\n          });\n          break;\n        default:\n          callback(new Error(\"Unexpected type in resolve result key\"));\n          break;\n      }\n    },\n    /**\n     * @param {Error | typeof INVALID=} err error or invalid flag\n     * @returns {void}\n     */\n    err => {\n      if (err === INVALID) {\n        return callback(null, false);\n      }\n      if (err) {\n        return callback(err);\n      }\n      return callback(null, true);\n    });\n  }\n\n  /**\n   * @param {number | null | undefined} startTime when processing the files has started\n   * @param {Iterable<string> | null} files all files\n   * @param {Iterable<string> | null} directories all directories\n   * @param {Iterable<string> | null} missing all missing files or directories\n   * @param {SnapshotOptions | null | undefined} options options object (for future extensions)\n   * @param {function(WebpackError | null, Snapshot | null): void} callback callback function\n   * @returns {void}\n   */\n  createSnapshot(startTime, files, directories, missing, options, callback) {\n    /** @type {FileTimestamps} */\n    const fileTimestamps = new Map();\n    /** @type {FileHashes} */\n    const fileHashes = new Map();\n    /** @type {FileTshs} */\n    const fileTshs = new Map();\n    /** @type {ContextTimestamps} */\n    const contextTimestamps = new Map();\n    /** @type {ContextHashes} */\n    const contextHashes = new Map();\n    /** @type {ContextTshs} */\n    const contextTshs = new Map();\n    /** @type {MissingExistence} */\n    const missingExistence = new Map();\n    /** @type {ManagedItemInfo} */\n    const managedItemInfo = new Map();\n    /** @type {ManagedFiles} */\n    const managedFiles = new Set();\n    /** @type {ManagedContexts} */\n    const managedContexts = new Set();\n    /** @type {ManagedMissing} */\n    const managedMissing = new Set();\n    /** @type {Children} */\n    const children = new Set();\n    const snapshot = new Snapshot();\n    if (startTime) snapshot.setStartTime(startTime);\n\n    /** @type {Set<string>} */\n    const managedItems = new Set();\n\n    /** 1 = timestamp, 2 = hash, 3 = timestamp + hash */\n    const mode = options && options.hash ? options.timestamp ? 3 : 2 : 1;\n    let jobs = 1;\n    const jobDone = () => {\n      if (--jobs === 0) {\n        if (fileTimestamps.size !== 0) {\n          snapshot.setFileTimestamps(fileTimestamps);\n        }\n        if (fileHashes.size !== 0) {\n          snapshot.setFileHashes(fileHashes);\n        }\n        if (fileTshs.size !== 0) {\n          snapshot.setFileTshs(fileTshs);\n        }\n        if (contextTimestamps.size !== 0) {\n          snapshot.setContextTimestamps(contextTimestamps);\n        }\n        if (contextHashes.size !== 0) {\n          snapshot.setContextHashes(contextHashes);\n        }\n        if (contextTshs.size !== 0) {\n          snapshot.setContextTshs(contextTshs);\n        }\n        if (missingExistence.size !== 0) {\n          snapshot.setMissingExistence(missingExistence);\n        }\n        if (managedItemInfo.size !== 0) {\n          snapshot.setManagedItemInfo(managedItemInfo);\n        }\n        this._managedFilesOptimization.optimize(snapshot, managedFiles);\n        if (managedFiles.size !== 0) {\n          snapshot.setManagedFiles(managedFiles);\n        }\n        this._managedContextsOptimization.optimize(snapshot, managedContexts);\n        if (managedContexts.size !== 0) {\n          snapshot.setManagedContexts(managedContexts);\n        }\n        this._managedMissingOptimization.optimize(snapshot, managedMissing);\n        if (managedMissing.size !== 0) {\n          snapshot.setManagedMissing(managedMissing);\n        }\n        if (children.size !== 0) {\n          snapshot.setChildren(children);\n        }\n        this._snapshotCache.set(snapshot, true);\n        this._statCreatedSnapshots++;\n        callback(null, snapshot);\n      }\n    };\n    const jobError = () => {\n      if (jobs > 0) {\n        // large negative number instead of NaN or something else to keep jobs to stay a SMI (v8)\n        jobs = -100000000;\n        callback(null, null);\n      }\n    };\n    /**\n     * @param {string} path path\n     * @param {Set<string>} managedSet managed set\n     * @returns {boolean} true when managed\n     */\n    const checkManaged = (path, managedSet) => {\n      for (const unmanagedPath of this.unmanagedPathsRegExps) {\n        if (unmanagedPath.test(path)) return false;\n      }\n      for (const unmanagedPath of this.unmanagedPathsWithSlash) {\n        if (path.startsWith(unmanagedPath)) return false;\n      }\n      for (const immutablePath of this.immutablePathsRegExps) {\n        if (immutablePath.test(path)) {\n          managedSet.add(path);\n          return true;\n        }\n      }\n      for (const immutablePath of this.immutablePathsWithSlash) {\n        if (path.startsWith(immutablePath)) {\n          managedSet.add(path);\n          return true;\n        }\n      }\n      for (const managedPath of this.managedPathsRegExps) {\n        const match = managedPath.exec(path);\n        if (match) {\n          const managedItem = getManagedItem(match[1], path);\n          if (managedItem) {\n            managedItems.add(managedItem);\n            managedSet.add(path);\n            return true;\n          }\n        }\n      }\n      for (const managedPath of this.managedPathsWithSlash) {\n        if (path.startsWith(managedPath)) {\n          const managedItem = getManagedItem(managedPath, path);\n          if (managedItem) {\n            managedItems.add(managedItem);\n            managedSet.add(path);\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    /**\n     * @param {Iterable<string>} items items\n     * @param {Set<string>} managedSet managed set\n     * @returns {Set<string>} result\n     */\n    const captureNonManaged = (items, managedSet) => {\n      const capturedItems = new Set();\n      for (const path of items) {\n        if (!checkManaged(path, managedSet)) capturedItems.add(path);\n      }\n      return capturedItems;\n    };\n    /**\n     * @param {Set<string>} capturedFiles captured files\n     */\n    const processCapturedFiles = capturedFiles => {\n      switch (mode) {\n        case 3:\n          this._fileTshsOptimization.optimize(snapshot, capturedFiles);\n          for (const path of capturedFiles) {\n            const cache = this._fileTshs.get(path);\n            if (cache !== undefined) {\n              fileTshs.set(path, cache);\n            } else {\n              jobs++;\n              this._getFileTimestampAndHash(path, (err, entry) => {\n                if (err) {\n                  if (this.logger) {\n                    this.logger.debug(`Error snapshotting file timestamp hash combination of ${path}: ${err.stack}`);\n                  }\n                  jobError();\n                } else {\n                  fileTshs.set(path, /** @type {TimestampAndHash} */entry);\n                  jobDone();\n                }\n              });\n            }\n          }\n          break;\n        case 2:\n          this._fileHashesOptimization.optimize(snapshot, capturedFiles);\n          for (const path of capturedFiles) {\n            const cache = this._fileHashes.get(path);\n            if (cache !== undefined) {\n              fileHashes.set(path, cache);\n            } else {\n              jobs++;\n              this.fileHashQueue.add(path, (err, entry) => {\n                if (err) {\n                  if (this.logger) {\n                    this.logger.debug(`Error snapshotting file hash of ${path}: ${err.stack}`);\n                  }\n                  jobError();\n                } else {\n                  fileHashes.set(path, /** @type {string} */entry);\n                  jobDone();\n                }\n              });\n            }\n          }\n          break;\n        case 1:\n          this._fileTimestampsOptimization.optimize(snapshot, capturedFiles);\n          for (const path of capturedFiles) {\n            const cache = this._fileTimestamps.get(path);\n            if (cache !== undefined) {\n              if (cache !== \"ignore\") {\n                fileTimestamps.set(path, cache);\n              }\n            } else {\n              jobs++;\n              this.fileTimestampQueue.add(path, (err, entry) => {\n                if (err) {\n                  if (this.logger) {\n                    this.logger.debug(`Error snapshotting file timestamp of ${path}: ${err.stack}`);\n                  }\n                  jobError();\n                } else {\n                  fileTimestamps.set(path, /** @type {FileSystemInfoEntry} */\n                  entry);\n                  jobDone();\n                }\n              });\n            }\n          }\n          break;\n      }\n    };\n    if (files) {\n      processCapturedFiles(captureNonManaged(files, managedFiles));\n    }\n    /**\n     * @param {Set<string>} capturedDirectories captured directories\n     */\n    const processCapturedDirectories = capturedDirectories => {\n      switch (mode) {\n        case 3:\n          this._contextTshsOptimization.optimize(snapshot, capturedDirectories);\n          for (const path of capturedDirectories) {\n            const cache = this._contextTshs.get(path);\n            /** @type {ResolvedContextTimestampAndHash | null | undefined} */\n            let resolved;\n            if (cache !== undefined && (resolved = getResolvedTimestamp(cache)) !== undefined) {\n              contextTshs.set(path, resolved);\n            } else {\n              jobs++;\n              /**\n               * @param {(WebpackError | null)=} err error\n               * @param {(ResolvedContextTimestampAndHash | null)=} entry entry\n               * @returns {void}\n               */\n              const callback = (err, entry) => {\n                if (err) {\n                  if (this.logger) {\n                    this.logger.debug(`Error snapshotting context timestamp hash combination of ${path}: ${err.stack}`);\n                  }\n                  jobError();\n                } else {\n                  contextTshs.set(path, /** @type {ResolvedContextTimestampAndHash | null} */\n                  entry);\n                  jobDone();\n                }\n              };\n              if (cache !== undefined) {\n                this._resolveContextTsh(cache, callback);\n              } else {\n                this.getContextTsh(path, callback);\n              }\n            }\n          }\n          break;\n        case 2:\n          this._contextHashesOptimization.optimize(snapshot, capturedDirectories);\n          for (const path of capturedDirectories) {\n            const cache = this._contextHashes.get(path);\n            let resolved;\n            if (cache !== undefined && (resolved = getResolvedHash(cache)) !== undefined) {\n              contextHashes.set(path, resolved);\n            } else {\n              jobs++;\n              /**\n               * @param {(WebpackError | null)=} err err\n               * @param {string=} entry entry\n               */\n              const callback = (err, entry) => {\n                if (err) {\n                  if (this.logger) {\n                    this.logger.debug(`Error snapshotting context hash of ${path}: ${err.stack}`);\n                  }\n                  jobError();\n                } else {\n                  contextHashes.set(path, /** @type {string} */entry);\n                  jobDone();\n                }\n              };\n              if (cache !== undefined) {\n                this._resolveContextHash(cache, callback);\n              } else {\n                this.getContextHash(path, callback);\n              }\n            }\n          }\n          break;\n        case 1:\n          this._contextTimestampsOptimization.optimize(snapshot, capturedDirectories);\n          for (const path of capturedDirectories) {\n            const cache = this._contextTimestamps.get(path);\n            if (cache === \"ignore\") continue;\n            let resolved;\n            if (cache !== undefined && (resolved = getResolvedTimestamp(cache)) !== undefined) {\n              contextTimestamps.set(path, resolved);\n            } else {\n              jobs++;\n              /**\n               * @param {(Error | null)=} err error\n               * @param {(FileSystemInfoEntry | \"ignore\" | null)=} entry entry\n               * @returns {void}\n               */\n              const callback = (err, entry) => {\n                if (err) {\n                  if (this.logger) {\n                    this.logger.debug(`Error snapshotting context timestamp of ${path}: ${err.stack}`);\n                  }\n                  jobError();\n                } else {\n                  contextTimestamps.set(path, /** @type {FileSystemInfoEntry | null} */\n                  entry);\n                  jobDone();\n                }\n              };\n              if (cache !== undefined) {\n                this._resolveContextTimestamp(/** @type {ContextFileSystemInfoEntry} */\n                cache, callback);\n              } else {\n                this.getContextTimestamp(path, callback);\n              }\n            }\n          }\n          break;\n      }\n    };\n    if (directories) {\n      processCapturedDirectories(captureNonManaged(directories, managedContexts));\n    }\n    /**\n     * @param {Set<string>} capturedMissing captured missing\n     */\n    const processCapturedMissing = capturedMissing => {\n      this._missingExistenceOptimization.optimize(snapshot, capturedMissing);\n      for (const path of capturedMissing) {\n        const cache = this._fileTimestamps.get(path);\n        if (cache !== undefined) {\n          if (cache !== \"ignore\") {\n            missingExistence.set(path, Boolean(cache));\n          }\n        } else {\n          jobs++;\n          this.fileTimestampQueue.add(path, (err, entry) => {\n            if (err) {\n              if (this.logger) {\n                this.logger.debug(`Error snapshotting missing timestamp of ${path}: ${err.stack}`);\n              }\n              jobError();\n            } else {\n              missingExistence.set(path, Boolean(entry));\n              jobDone();\n            }\n          });\n        }\n      }\n    };\n    if (missing) {\n      processCapturedMissing(captureNonManaged(missing, managedMissing));\n    }\n    this._managedItemInfoOptimization.optimize(snapshot, managedItems);\n    for (const path of managedItems) {\n      const cache = this._managedItems.get(path);\n      if (cache !== undefined) {\n        if (!cache.startsWith(\"*\")) {\n          managedFiles.add(join(this.fs, path, \"package.json\"));\n        } else if (cache === \"*nested\") {\n          managedMissing.add(join(this.fs, path, \"package.json\"));\n        }\n        managedItemInfo.set(path, cache);\n      } else {\n        jobs++;\n        this.managedItemQueue.add(path, (err, entry) => {\n          if (err) {\n            if (this.logger) {\n              this.logger.debug(`Error snapshotting managed item ${path}: ${err.stack}`);\n            }\n            jobError();\n          } else if (entry) {\n            if (!entry.startsWith(\"*\")) {\n              managedFiles.add(join(this.fs, path, \"package.json\"));\n            } else if (cache === \"*nested\") {\n              managedMissing.add(join(this.fs, path, \"package.json\"));\n            }\n            managedItemInfo.set(path, entry);\n            jobDone();\n          } else {\n            // Fallback to normal snapshotting\n            /**\n             * @param {Set<string>} set set\n             * @param {function(Set<string>): void} fn fn\n             */\n            const process = (set, fn) => {\n              if (set.size === 0) return;\n              const captured = new Set();\n              for (const file of set) {\n                if (file.startsWith(path)) captured.add(file);\n              }\n              if (captured.size > 0) fn(captured);\n            };\n            process(managedFiles, processCapturedFiles);\n            process(managedContexts, processCapturedDirectories);\n            process(managedMissing, processCapturedMissing);\n            jobDone();\n          }\n        });\n      }\n    }\n    jobDone();\n  }\n\n  /**\n   * @param {Snapshot} snapshot1 a snapshot\n   * @param {Snapshot} snapshot2 a snapshot\n   * @returns {Snapshot} merged snapshot\n   */\n  mergeSnapshots(snapshot1, snapshot2) {\n    const snapshot = new Snapshot();\n    if (snapshot1.hasStartTime() && snapshot2.hasStartTime()) {\n      snapshot.setStartTime(Math.min(/** @type {NonNullable<Snapshot[\"startTime\"]>} */\n      snapshot1.startTime, /** @type {NonNullable<Snapshot[\"startTime\"]>} */\n      snapshot2.startTime));\n    } else if (snapshot2.hasStartTime()) {\n      snapshot.startTime = snapshot2.startTime;\n    } else if (snapshot1.hasStartTime()) {\n      snapshot.startTime = snapshot1.startTime;\n    }\n    if (snapshot1.hasFileTimestamps() || snapshot2.hasFileTimestamps()) {\n      snapshot.setFileTimestamps(mergeMaps(snapshot1.fileTimestamps, snapshot2.fileTimestamps));\n    }\n    if (snapshot1.hasFileHashes() || snapshot2.hasFileHashes()) {\n      snapshot.setFileHashes(mergeMaps(snapshot1.fileHashes, snapshot2.fileHashes));\n    }\n    if (snapshot1.hasFileTshs() || snapshot2.hasFileTshs()) {\n      snapshot.setFileTshs(mergeMaps(snapshot1.fileTshs, snapshot2.fileTshs));\n    }\n    if (snapshot1.hasContextTimestamps() || snapshot2.hasContextTimestamps()) {\n      snapshot.setContextTimestamps(mergeMaps(snapshot1.contextTimestamps, snapshot2.contextTimestamps));\n    }\n    if (snapshot1.hasContextHashes() || snapshot2.hasContextHashes()) {\n      snapshot.setContextHashes(mergeMaps(snapshot1.contextHashes, snapshot2.contextHashes));\n    }\n    if (snapshot1.hasContextTshs() || snapshot2.hasContextTshs()) {\n      snapshot.setContextTshs(mergeMaps(snapshot1.contextTshs, snapshot2.contextTshs));\n    }\n    if (snapshot1.hasMissingExistence() || snapshot2.hasMissingExistence()) {\n      snapshot.setMissingExistence(mergeMaps(snapshot1.missingExistence, snapshot2.missingExistence));\n    }\n    if (snapshot1.hasManagedItemInfo() || snapshot2.hasManagedItemInfo()) {\n      snapshot.setManagedItemInfo(mergeMaps(snapshot1.managedItemInfo, snapshot2.managedItemInfo));\n    }\n    if (snapshot1.hasManagedFiles() || snapshot2.hasManagedFiles()) {\n      snapshot.setManagedFiles(mergeSets(snapshot1.managedFiles, snapshot2.managedFiles));\n    }\n    if (snapshot1.hasManagedContexts() || snapshot2.hasManagedContexts()) {\n      snapshot.setManagedContexts(mergeSets(snapshot1.managedContexts, snapshot2.managedContexts));\n    }\n    if (snapshot1.hasManagedMissing() || snapshot2.hasManagedMissing()) {\n      snapshot.setManagedMissing(mergeSets(snapshot1.managedMissing, snapshot2.managedMissing));\n    }\n    if (snapshot1.hasChildren() || snapshot2.hasChildren()) {\n      snapshot.setChildren(mergeSets(snapshot1.children, snapshot2.children));\n    }\n    if (this._snapshotCache.get(snapshot1) === true && this._snapshotCache.get(snapshot2) === true) {\n      this._snapshotCache.set(snapshot, true);\n    }\n    return snapshot;\n  }\n\n  /**\n   * @param {Snapshot} snapshot the snapshot made\n   * @param {function((WebpackError | null)=, boolean=): void} callback callback function\n   * @returns {void}\n   */\n  checkSnapshotValid(snapshot, callback) {\n    const cachedResult = this._snapshotCache.get(snapshot);\n    if (cachedResult !== undefined) {\n      this._statTestedSnapshotsCached++;\n      if (typeof cachedResult === \"boolean\") {\n        callback(null, cachedResult);\n      } else {\n        cachedResult.push(callback);\n      }\n      return;\n    }\n    this._statTestedSnapshotsNotCached++;\n    this._checkSnapshotValidNoCache(snapshot, callback);\n  }\n\n  /**\n   * @param {Snapshot} snapshot the snapshot made\n   * @param {function((WebpackError | null)=, boolean=): void} callback callback function\n   * @returns {void}\n   */\n  _checkSnapshotValidNoCache(snapshot, callback) {\n    /** @type {number | undefined} */\n    let startTime;\n    if (snapshot.hasStartTime()) {\n      startTime = snapshot.startTime;\n    }\n    let jobs = 1;\n    const jobDone = () => {\n      if (--jobs === 0) {\n        this._snapshotCache.set(snapshot, true);\n        callback(null, true);\n      }\n    };\n    const invalid = () => {\n      if (jobs > 0) {\n        // large negative number instead of NaN or something else to keep jobs to stay a SMI (v8)\n        jobs = -100000000;\n        this._snapshotCache.set(snapshot, false);\n        callback(null, false);\n      }\n    };\n    /**\n     * @param {string} path path\n     * @param {WebpackError} err err\n     */\n    const invalidWithError = (path, err) => {\n      if (this._remainingLogs > 0) {\n        this._log(path, \"error occurred: %s\", err);\n      }\n      invalid();\n    };\n    /**\n     * @param {string} path file path\n     * @param {string | null} current current hash\n     * @param {string | null} snap snapshot hash\n     * @returns {boolean} true, if ok\n     */\n    const checkHash = (path, current, snap) => {\n      if (current !== snap) {\n        // If hash differ it's invalid\n        if (this._remainingLogs > 0) {\n          this._log(path, \"hashes differ (%s != %s)\", current, snap);\n        }\n        return false;\n      }\n      return true;\n    };\n    /**\n     * @param {string} path file path\n     * @param {boolean} current current entry\n     * @param {boolean} snap entry from snapshot\n     * @returns {boolean} true, if ok\n     */\n    const checkExistence = (path, current, snap) => {\n      if (!current !== !snap) {\n        // If existence of item differs\n        // it's invalid\n        if (this._remainingLogs > 0) {\n          this._log(path, current ? \"it didn't exist before\" : \"it does no longer exist\");\n        }\n        return false;\n      }\n      return true;\n    };\n    /**\n     * @param {string} path file path\n     * @param {FileSystemInfoEntry | null} c current entry\n     * @param {FileSystemInfoEntry | null} s entry from snapshot\n     * @param {boolean} log log reason\n     * @returns {boolean} true, if ok\n     */\n    const checkFile = (path, c, s, log = true) => {\n      if (c === s) return true;\n      if (!checkExistence(path, Boolean(c), Boolean(s))) return false;\n      if (c) {\n        // For existing items only\n        if (typeof startTime === \"number\" && c.safeTime > startTime) {\n          // If a change happened after starting reading the item\n          // this may no longer be valid\n          if (log && this._remainingLogs > 0) {\n            this._log(path, \"it may have changed (%d) after the start time of the snapshot (%d)\", c.safeTime, startTime);\n          }\n          return false;\n        }\n        const snap = /** @type {FileSystemInfoEntry} */s;\n        if (snap.timestamp !== undefined && c.timestamp !== snap.timestamp) {\n          // If we have a timestamp (it was a file or symlink) and it differs from current timestamp\n          // it's invalid\n          if (log && this._remainingLogs > 0) {\n            this._log(path, \"timestamps differ (%d != %d)\", c.timestamp, snap.timestamp);\n          }\n          return false;\n        }\n      }\n      return true;\n    };\n    /**\n     * @param {string} path file path\n     * @param {ResolvedContextFileSystemInfoEntry | null} c current entry\n     * @param {ResolvedContextFileSystemInfoEntry | null} s entry from snapshot\n     * @param {boolean} log log reason\n     * @returns {boolean} true, if ok\n     */\n    const checkContext = (path, c, s, log = true) => {\n      if (c === s) return true;\n      if (!checkExistence(path, Boolean(c), Boolean(s))) return false;\n      if (c) {\n        // For existing items only\n        if (typeof startTime === \"number\" && c.safeTime > startTime) {\n          // If a change happened after starting reading the item\n          // this may no longer be valid\n          if (log && this._remainingLogs > 0) {\n            this._log(path, \"it may have changed (%d) after the start time of the snapshot (%d)\", c.safeTime, startTime);\n          }\n          return false;\n        }\n        const snap = /** @type {ResolvedContextFileSystemInfoEntry} */s;\n        if (snap.timestampHash !== undefined && c.timestampHash !== snap.timestampHash) {\n          // If we have a timestampHash (it was a directory) and it differs from current timestampHash\n          // it's invalid\n          if (log && this._remainingLogs > 0) {\n            this._log(path, \"timestamps hashes differ (%s != %s)\", c.timestampHash, snap.timestampHash);\n          }\n          return false;\n        }\n      }\n      return true;\n    };\n    if (snapshot.hasChildren()) {\n      /**\n       * @param {(WebpackError | null)=} err err\n       * @param {boolean=} result result\n       * @returns {void}\n       */\n      const childCallback = (err, result) => {\n        if (err || !result) return invalid();\n        jobDone();\n      };\n      for (const child of (/** @type {Children} */snapshot.children)) {\n        const cache = this._snapshotCache.get(child);\n        if (cache !== undefined) {\n          this._statTestedChildrenCached++;\n          /* istanbul ignore else */\n          if (typeof cache === \"boolean\") {\n            if (cache === false) {\n              invalid();\n              return;\n            }\n          } else {\n            jobs++;\n            cache.push(childCallback);\n          }\n        } else {\n          this._statTestedChildrenNotCached++;\n          jobs++;\n          this._checkSnapshotValidNoCache(child, childCallback);\n        }\n      }\n    }\n    if (snapshot.hasFileTimestamps()) {\n      const fileTimestamps = /** @type {FileTimestamps} */\n      snapshot.fileTimestamps;\n      this._statTestedEntries += fileTimestamps.size;\n      for (const [path, ts] of fileTimestamps) {\n        const cache = this._fileTimestamps.get(path);\n        if (cache !== undefined) {\n          if (cache !== \"ignore\" && !checkFile(path, cache, ts)) {\n            invalid();\n            return;\n          }\n        } else {\n          jobs++;\n          this.fileTimestampQueue.add(path, (err, entry) => {\n            if (err) return invalidWithError(path, err);\n            if (!checkFile(path, /** @type {FileSystemInfoEntry | null} */entry, ts)) {\n              invalid();\n            } else {\n              jobDone();\n            }\n          });\n        }\n      }\n    }\n    /**\n     * @param {string} path file path\n     * @param {string | null} hash hash\n     */\n    const processFileHashSnapshot = (path, hash) => {\n      const cache = this._fileHashes.get(path);\n      if (cache !== undefined) {\n        if (cache !== \"ignore\" && !checkHash(path, cache, hash)) {\n          invalid();\n        }\n      } else {\n        jobs++;\n        this.fileHashQueue.add(path, (err, entry) => {\n          if (err) return invalidWithError(path, err);\n          if (!checkHash(path, /** @type {string} */entry, hash)) {\n            invalid();\n          } else {\n            jobDone();\n          }\n        });\n      }\n    };\n    if (snapshot.hasFileHashes()) {\n      const fileHashes = /** @type {FileHashes} */snapshot.fileHashes;\n      this._statTestedEntries += fileHashes.size;\n      for (const [path, hash] of fileHashes) {\n        processFileHashSnapshot(path, hash);\n      }\n    }\n    if (snapshot.hasFileTshs()) {\n      const fileTshs = /** @type {FileTshs} */snapshot.fileTshs;\n      this._statTestedEntries += fileTshs.size;\n      for (const [path, tsh] of fileTshs) {\n        if (typeof tsh === \"string\") {\n          processFileHashSnapshot(path, tsh);\n        } else {\n          const cache = this._fileTimestamps.get(path);\n          if (cache !== undefined) {\n            if (cache === \"ignore\" || !checkFile(path, cache, tsh, false)) {\n              processFileHashSnapshot(path, tsh && tsh.hash);\n            }\n          } else {\n            jobs++;\n            this.fileTimestampQueue.add(path, (err, entry) => {\n              if (err) return invalidWithError(path, err);\n              if (!checkFile(path, /** @type {FileSystemInfoEntry | null} */\n              entry, tsh, false)) {\n                processFileHashSnapshot(path, tsh && tsh.hash);\n              }\n              jobDone();\n            });\n          }\n        }\n      }\n    }\n    if (snapshot.hasContextTimestamps()) {\n      const contextTimestamps = /** @type {ContextTimestamps} */\n      snapshot.contextTimestamps;\n      this._statTestedEntries += contextTimestamps.size;\n      for (const [path, ts] of contextTimestamps) {\n        const cache = this._contextTimestamps.get(path);\n        if (cache === \"ignore\") continue;\n        let resolved;\n        if (cache !== undefined && (resolved = getResolvedTimestamp(cache)) !== undefined) {\n          if (!checkContext(path, resolved, ts)) {\n            invalid();\n            return;\n          }\n        } else {\n          jobs++;\n          /**\n           * @param {(WebpackError | null)=} err error\n           * @param {(ResolvedContextFileSystemInfoEntry | \"ignore\" | null)=} entry entry\n           * @returns {void}\n           */\n          const callback = (err, entry) => {\n            if (err) return invalidWithError(path, err);\n            if (!checkContext(path, /** @type {ResolvedContextFileSystemInfoEntry | null} */\n            entry, ts)) {\n              invalid();\n            } else {\n              jobDone();\n            }\n          };\n          if (cache !== undefined) {\n            this._resolveContextTimestamp(/** @type {ContextFileSystemInfoEntry} */\n            cache, callback);\n          } else {\n            this.getContextTimestamp(path, callback);\n          }\n        }\n      }\n    }\n    /**\n     * @param {string} path path\n     * @param {string | null} hash hash\n     */\n    const processContextHashSnapshot = (path, hash) => {\n      const cache = this._contextHashes.get(path);\n      let resolved;\n      if (cache !== undefined && (resolved = getResolvedHash(cache)) !== undefined) {\n        if (!checkHash(path, resolved, hash)) {\n          invalid();\n        }\n      } else {\n        jobs++;\n        /**\n         * @param {(WebpackError | null)=} err err\n         * @param {string=} entry entry\n         * @returns {void}\n         */\n        const callback = (err, entry) => {\n          if (err) return invalidWithError(path, err);\n          if (!checkHash(path, /** @type {string} */entry, hash)) {\n            invalid();\n          } else {\n            jobDone();\n          }\n        };\n        if (cache !== undefined) {\n          this._resolveContextHash(cache, callback);\n        } else {\n          this.getContextHash(path, callback);\n        }\n      }\n    };\n    if (snapshot.hasContextHashes()) {\n      const contextHashes = /** @type {ContextHashes} */\n      snapshot.contextHashes;\n      this._statTestedEntries += contextHashes.size;\n      for (const [path, hash] of contextHashes) {\n        processContextHashSnapshot(path, hash);\n      }\n    }\n    if (snapshot.hasContextTshs()) {\n      const contextTshs = /** @type {ContextTshs} */snapshot.contextTshs;\n      this._statTestedEntries += contextTshs.size;\n      for (const [path, tsh] of contextTshs) {\n        if (typeof tsh === \"string\") {\n          processContextHashSnapshot(path, tsh);\n        } else {\n          const cache = this._contextTimestamps.get(path);\n          if (cache === \"ignore\") continue;\n          let resolved;\n          if (cache !== undefined && (resolved = getResolvedTimestamp(cache)) !== undefined) {\n            if (!checkContext(path, /** @type {ResolvedContextFileSystemInfoEntry | null} */\n            resolved, tsh, false)) {\n              processContextHashSnapshot(path, tsh && tsh.hash);\n            }\n          } else {\n            jobs++;\n            /**\n             * @param {(WebpackError | null)=} err error\n             * @param {(ResolvedContextFileSystemInfoEntry | \"ignore\" | null)=} entry entry\n             * @returns {void}\n             */\n            const callback = (err, entry) => {\n              if (err) return invalidWithError(path, err);\n              if (!checkContext(path,\n              // TODO: test with `\"ignore\"`\n              /** @type {ResolvedContextFileSystemInfoEntry | null} */\n              entry, tsh, false)) {\n                processContextHashSnapshot(path, tsh && tsh.hash);\n              }\n              jobDone();\n            };\n            if (cache !== undefined) {\n              this._resolveContextTimestamp(/** @type {ContextFileSystemInfoEntry} */\n              cache, callback);\n            } else {\n              this.getContextTimestamp(path, callback);\n            }\n          }\n        }\n      }\n    }\n    if (snapshot.hasMissingExistence()) {\n      const missingExistence = /** @type {MissingExistence} */\n      snapshot.missingExistence;\n      this._statTestedEntries += missingExistence.size;\n      for (const [path, existence] of missingExistence) {\n        const cache = this._fileTimestamps.get(path);\n        if (cache !== undefined) {\n          if (cache !== \"ignore\" && !checkExistence(path, Boolean(cache), Boolean(existence))) {\n            invalid();\n            return;\n          }\n        } else {\n          jobs++;\n          this.fileTimestampQueue.add(path, (err, entry) => {\n            if (err) return invalidWithError(path, err);\n            if (!checkExistence(path, Boolean(entry), Boolean(existence))) {\n              invalid();\n            } else {\n              jobDone();\n            }\n          });\n        }\n      }\n    }\n    if (snapshot.hasManagedItemInfo()) {\n      const managedItemInfo = /** @type {ManagedItemInfo} */\n      snapshot.managedItemInfo;\n      this._statTestedEntries += managedItemInfo.size;\n      for (const [path, info] of managedItemInfo) {\n        const cache = this._managedItems.get(path);\n        if (cache !== undefined) {\n          if (!checkHash(path, cache, info)) {\n            invalid();\n            return;\n          }\n        } else {\n          jobs++;\n          this.managedItemQueue.add(path, (err, entry) => {\n            if (err) return invalidWithError(path, err);\n            if (!checkHash(path, /** @type {string} */entry, info)) {\n              invalid();\n            } else {\n              jobDone();\n            }\n          });\n        }\n      }\n    }\n    jobDone();\n\n    // if there was an async action\n    // try to join multiple concurrent request for this snapshot\n    if (jobs > 0) {\n      const callbacks = [callback];\n      callback = (err, result) => {\n        for (const callback of callbacks) callback(err, result);\n      };\n      this._snapshotCache.set(snapshot, callbacks);\n    }\n  }\n\n  /**\n   * @type {Processor<string, FileSystemInfoEntry>}\n   * @private\n   */\n  _readFileTimestamp(path, callback) {\n    this.fs.stat(path, (err, _stat) => {\n      if (err) {\n        if (err.code === \"ENOENT\") {\n          this._fileTimestamps.set(path, null);\n          this._cachedDeprecatedFileTimestamps = undefined;\n          return callback(null, null);\n        }\n        return callback(/** @type {WebpackError} */err);\n      }\n      const stat = /** @type {IStats} */_stat;\n      let ts;\n      if (stat.isDirectory()) {\n        ts = {\n          safeTime: 0,\n          timestamp: undefined\n        };\n      } else {\n        const mtime = Number(stat.mtime);\n        if (mtime) applyMtime(mtime);\n        ts = {\n          safeTime: mtime ? mtime + FS_ACCURACY : Infinity,\n          timestamp: mtime\n        };\n      }\n      this._fileTimestamps.set(path, ts);\n      this._cachedDeprecatedFileTimestamps = undefined;\n      callback(null, ts);\n    });\n  }\n\n  /**\n   * @type {Processor<string, string>}\n   * @private\n   */\n  _readFileHash(path, callback) {\n    this.fs.readFile(path, (err, content) => {\n      if (err) {\n        if (err.code === \"EISDIR\") {\n          this._fileHashes.set(path, \"directory\");\n          return callback(null, \"directory\");\n        }\n        if (err.code === \"ENOENT\") {\n          this._fileHashes.set(path, null);\n          return callback(null, null);\n        }\n        if (err.code === \"ERR_FS_FILE_TOO_LARGE\") {\n          /** @type {Logger} */\n          this.logger.warn(`Ignoring ${path} for hashing as it's very large`);\n          this._fileHashes.set(path, \"too large\");\n          return callback(null, \"too large\");\n        }\n        return callback(/** @type {WebpackError} */err);\n      }\n      const hash = createHash(this._hashFunction);\n      hash.update(/** @type {string | Buffer} */content);\n      const digest = /** @type {string} */hash.digest(\"hex\");\n      this._fileHashes.set(path, digest);\n      callback(null, digest);\n    });\n  }\n\n  /**\n   * @param {string} path path\n   * @param {function(WebpackError | null, TimestampAndHash=) : void} callback callback\n   * @private\n   */\n  _getFileTimestampAndHash(path, callback) {\n    /**\n     * @param {string} hash hash\n     * @returns {void}\n     */\n    const continueWithHash = hash => {\n      const cache = this._fileTimestamps.get(path);\n      if (cache !== undefined) {\n        if (cache !== \"ignore\") {\n          /** @type {TimestampAndHash} */\n          const result = {\n            ...(/** @type {FileSystemInfoEntry} */cache),\n            hash\n          };\n          this._fileTshs.set(path, result);\n          return callback(null, result);\n        }\n        this._fileTshs.set(path, hash);\n        return callback(null, /** @type {TODO} */hash);\n      }\n      this.fileTimestampQueue.add(path, (err, entry) => {\n        if (err) {\n          return callback(err);\n        }\n        /** @type {TimestampAndHash} */\n        const result = {\n          ...(/** @type {FileSystemInfoEntry} */entry),\n          hash\n        };\n        this._fileTshs.set(path, result);\n        return callback(null, result);\n      });\n    };\n    const cache = this._fileHashes.get(path);\n    if (cache !== undefined) {\n      continueWithHash(/** @type {string} */cache);\n    } else {\n      this.fileHashQueue.add(path, (err, entry) => {\n        if (err) {\n          return callback(err);\n        }\n        continueWithHash(/** @type {string} */entry);\n      });\n    }\n  }\n\n  /**\n   * @template T\n   * @template ItemType\n   * @param {object} options options\n   * @param {string} options.path path\n   * @param {function(string): ItemType} options.fromImmutablePath called when context item is an immutable path\n   * @param {function(string): ItemType} options.fromManagedItem called when context item is a managed path\n   * @param {function(string, string, function((WebpackError | null)=, ItemType=): void): void} options.fromSymlink called when context item is a symlink\n   * @param {function(string, IStats, function((WebpackError | null)=, (ItemType | null)=): void): void} options.fromFile called when context item is a file\n   * @param {function(string, IStats, function((WebpackError | null)=, ItemType=): void): void} options.fromDirectory called when context item is a directory\n   * @param {function(string[], ItemType[]): T} options.reduce called from all context items\n   * @param {function((Error | null)=, (T | null)=): void} callback callback\n   */\n  _readContext({\n    path,\n    fromImmutablePath,\n    fromManagedItem,\n    fromSymlink,\n    fromFile,\n    fromDirectory,\n    reduce\n  }, callback) {\n    this.fs.readdir(path, (err, _files) => {\n      if (err) {\n        if (err.code === \"ENOENT\") {\n          return callback(null, null);\n        }\n        return callback(err);\n      }\n      const files = /** @type {string[]} */_files.map(file => file.normalize(\"NFC\")).filter(file => !/^\\./.test(file)).sort();\n      asyncLib.map(files, (file, callback) => {\n        const child = join(this.fs, path, file);\n        for (const immutablePath of this.immutablePathsRegExps) {\n          if (immutablePath.test(path)) {\n            // ignore any immutable path for timestamping\n            return callback(null, fromImmutablePath(path));\n          }\n        }\n        for (const immutablePath of this.immutablePathsWithSlash) {\n          if (path.startsWith(immutablePath)) {\n            // ignore any immutable path for timestamping\n            return callback(null, fromImmutablePath(path));\n          }\n        }\n        for (const managedPath of this.managedPathsRegExps) {\n          const match = managedPath.exec(path);\n          if (match) {\n            const managedItem = getManagedItem(match[1], path);\n            if (managedItem) {\n              // construct timestampHash from managed info\n              return this.managedItemQueue.add(managedItem, (err, info) => {\n                if (err) return callback(err);\n                return callback(null, fromManagedItem(/** @type {string} */info));\n              });\n            }\n          }\n        }\n        for (const managedPath of this.managedPathsWithSlash) {\n          if (path.startsWith(managedPath)) {\n            const managedItem = getManagedItem(managedPath, child);\n            if (managedItem) {\n              // construct timestampHash from managed info\n              return this.managedItemQueue.add(managedItem, (err, info) => {\n                if (err) return callback(err);\n                return callback(null, fromManagedItem(/** @type {string} */info));\n              });\n            }\n          }\n        }\n        lstatReadlinkAbsolute(this.fs, child, (err, _stat) => {\n          if (err) return callback(err);\n          const stat = /** @type {IStats | string} */_stat;\n          if (typeof stat === \"string\") {\n            return fromSymlink(child, stat, callback);\n          }\n          if (stat.isFile()) {\n            return fromFile(child, stat, callback);\n          }\n          if (stat.isDirectory()) {\n            return fromDirectory(child, stat, callback);\n          }\n          callback(null, null);\n        });\n      }, (err, results) => {\n        if (err) return callback(err);\n        const result = reduce(files, /** @type {ItemType[]} */results);\n        callback(null, result);\n      });\n    });\n  }\n\n  /**\n   * @type {Processor<string, ContextFileSystemInfoEntry>}\n   * @private\n   */\n  _readContextTimestamp(path, callback) {\n    this._readContext({\n      path,\n      fromImmutablePath: () => (/** @type {ContextFileSystemInfoEntry | FileSystemInfoEntry | \"ignore\" | null} */\n      null),\n      fromManagedItem: info => ({\n        safeTime: 0,\n        timestampHash: info\n      }),\n      fromSymlink: (file, target, callback) => {\n        callback(null, /** @type {ContextFileSystemInfoEntry} */\n        {\n          timestampHash: target,\n          symlinks: new Set([target])\n        });\n      },\n      fromFile: (file, stat, callback) => {\n        // Prefer the cached value over our new stat to report consistent results\n        const cache = this._fileTimestamps.get(file);\n        if (cache !== undefined) return callback(null, cache === \"ignore\" ? null : cache);\n        const mtime = Number(stat.mtime);\n        if (mtime) applyMtime(mtime);\n\n        /** @type {FileSystemInfoEntry} */\n        const ts = {\n          safeTime: mtime ? mtime + FS_ACCURACY : Infinity,\n          timestamp: mtime\n        };\n        this._fileTimestamps.set(file, ts);\n        this._cachedDeprecatedFileTimestamps = undefined;\n        callback(null, ts);\n      },\n      fromDirectory: (directory, stat, callback) => {\n        this.contextTimestampQueue.increaseParallelism();\n        this._getUnresolvedContextTimestamp(directory, (err, tsEntry) => {\n          this.contextTimestampQueue.decreaseParallelism();\n          callback(err, tsEntry);\n        });\n      },\n      reduce: (files, tsEntries) => {\n        let symlinks;\n        const hash = createHash(this._hashFunction);\n        for (const file of files) hash.update(file);\n        let safeTime = 0;\n        for (const _e of tsEntries) {\n          if (!_e) {\n            hash.update(\"n\");\n            continue;\n          }\n          const entry = /** @type {FileSystemInfoEntry | ContextFileSystemInfoEntry} */\n          _e;\n          if (/** @type {FileSystemInfoEntry} */entry.timestamp) {\n            hash.update(\"f\");\n            hash.update(`${/** @type {FileSystemInfoEntry} */entry.timestamp}`);\n          } else if (/** @type {ContextFileSystemInfoEntry} */entry.timestampHash) {\n            hash.update(\"d\");\n            hash.update(`${/** @type {ContextFileSystemInfoEntry} */entry.timestampHash}`);\n          }\n          if (/** @type {ContextFileSystemInfoEntry} */\n          entry.symlinks !== undefined) {\n            if (symlinks === undefined) symlinks = new Set();\n            addAll(/** @type {ContextFileSystemInfoEntry} */entry.symlinks, symlinks);\n          }\n          if (entry.safeTime) {\n            safeTime = Math.max(safeTime, entry.safeTime);\n          }\n        }\n        const digest = /** @type {string} */hash.digest(\"hex\");\n        /** @type {ContextFileSystemInfoEntry} */\n        const result = {\n          safeTime,\n          timestampHash: digest\n        };\n        if (symlinks) result.symlinks = symlinks;\n        return result;\n      }\n    }, (err, result) => {\n      if (err) return callback(/** @type {WebpackError} */err);\n      this._contextTimestamps.set(path, result);\n      this._cachedDeprecatedContextTimestamps = undefined;\n      callback(null, result);\n    });\n  }\n\n  /**\n   * @param {ContextFileSystemInfoEntry} entry entry\n   * @param {function((WebpackError | null)=, (ResolvedContextFileSystemInfoEntry | \"ignore\" | null)=): void} callback callback\n   * @returns {void}\n   */\n  _resolveContextTimestamp(entry, callback) {\n    /** @type {string[]} */\n    const hashes = [];\n    let safeTime = 0;\n    processAsyncTree(/** @type {NonNullable<ContextHash[\"symlinks\"]>} */entry.symlinks, 10, (target, push, callback) => {\n      this._getUnresolvedContextTimestamp(target, (err, entry) => {\n        if (err) return callback(err);\n        if (entry && entry !== \"ignore\") {\n          hashes.push(/** @type {string} */entry.timestampHash);\n          if (entry.safeTime) {\n            safeTime = Math.max(safeTime, entry.safeTime);\n          }\n          if (entry.symlinks !== undefined) {\n            for (const target of entry.symlinks) push(target);\n          }\n        }\n        callback();\n      });\n    }, err => {\n      if (err) return callback(/** @type {WebpackError} */err);\n      const hash = createHash(this._hashFunction);\n      hash.update(/** @type {string} */entry.timestampHash);\n      if (entry.safeTime) {\n        safeTime = Math.max(safeTime, entry.safeTime);\n      }\n      hashes.sort();\n      for (const h of hashes) {\n        hash.update(h);\n      }\n      callback(null, entry.resolved = {\n        safeTime,\n        timestampHash: (/** @type {string} */hash.digest(\"hex\"))\n      });\n    });\n  }\n\n  /**\n   * @type {Processor<string, ContextHash>}\n   * @private\n   */\n  _readContextHash(path, callback) {\n    this._readContext({\n      path,\n      fromImmutablePath: () => (/** @type {ContextHash} */ /** @type {unknown} */\"\"),\n      fromManagedItem: info => info || \"\",\n      fromSymlink: (file, target, callback) => {\n        callback(null, /** @type {ContextHash} */\n        {\n          hash: target,\n          symlinks: new Set([target])\n        });\n      },\n      fromFile: (file, stat, callback) => this.getFileHash(file, (err, hash) => {\n        callback(err, hash || \"\");\n      }),\n      fromDirectory: (directory, stat, callback) => {\n        this.contextHashQueue.increaseParallelism();\n        this._getUnresolvedContextHash(directory, (err, hash) => {\n          this.contextHashQueue.decreaseParallelism();\n          callback(err, hash || \"\");\n        });\n      },\n      /**\n       * @param {string[]} files files\n       * @param {(string | ContextHash)[]} fileHashes hashes\n       * @returns {ContextHash} reduced hash\n       */\n      reduce: (files, fileHashes) => {\n        let symlinks;\n        const hash = createHash(this._hashFunction);\n        for (const file of files) hash.update(file);\n        for (const entry of fileHashes) {\n          if (typeof entry === \"string\") {\n            hash.update(entry);\n          } else {\n            hash.update(entry.hash);\n            if (entry.symlinks) {\n              if (symlinks === undefined) symlinks = new Set();\n              addAll(entry.symlinks, symlinks);\n            }\n          }\n        }\n\n        /** @type {ContextHash} */\n        const result = {\n          hash: (/** @type {string} */hash.digest(\"hex\"))\n        };\n        if (symlinks) result.symlinks = symlinks;\n        return result;\n      }\n    }, (err, _result) => {\n      if (err) return callback(/** @type {WebpackError} */err);\n      const result = /** @type {ContextHash} */_result;\n      this._contextHashes.set(path, result);\n      return callback(null, result);\n    });\n  }\n\n  /**\n   * @param {ContextHash} entry context hash\n   * @param {function(WebpackError | null, string=): void} callback callback\n   * @returns {void}\n   */\n  _resolveContextHash(entry, callback) {\n    /** @type {string[]} */\n    const hashes = [];\n    processAsyncTree(/** @type {NonNullable<ContextHash[\"symlinks\"]>} */entry.symlinks, 10, (target, push, callback) => {\n      this._getUnresolvedContextHash(target, (err, hash) => {\n        if (err) return callback(err);\n        if (hash) {\n          hashes.push(hash.hash);\n          if (hash.symlinks !== undefined) {\n            for (const target of hash.symlinks) push(target);\n          }\n        }\n        callback();\n      });\n    }, err => {\n      if (err) return callback(/** @type {WebpackError} */err);\n      const hash = createHash(this._hashFunction);\n      hash.update(entry.hash);\n      hashes.sort();\n      for (const h of hashes) {\n        hash.update(h);\n      }\n      callback(null, entry.resolved = /** @type {string} */hash.digest(\"hex\"));\n    });\n  }\n\n  /**\n   * @type {Processor<string, ContextTimestampAndHash>}\n   * @private\n   */\n  _readContextTimestampAndHash(path, callback) {\n    /**\n     * @param {ContextFileSystemInfoEntry | \"ignore\" | null} timestamp timestamp\n     * @param {ContextHash} hash hash\n     */\n    const finalize = (timestamp, hash) => {\n      const result = /** @type {ContextTimestampAndHash} */\n      timestamp === \"ignore\" ? hash : {\n        ...timestamp,\n        ...hash\n      };\n      this._contextTshs.set(path, result);\n      callback(null, result);\n    };\n    const cachedHash = this._contextHashes.get(path);\n    const cachedTimestamp = this._contextTimestamps.get(path);\n    if (cachedHash !== undefined) {\n      if (cachedTimestamp !== undefined) {\n        finalize(cachedTimestamp, cachedHash);\n      } else {\n        this.contextTimestampQueue.add(path, (err, entry) => {\n          if (err) return callback(err);\n          finalize(/** @type {ContextFileSystemInfoEntry} */\n          entry, cachedHash);\n        });\n      }\n    } else if (cachedTimestamp !== undefined) {\n      this.contextHashQueue.add(path, (err, entry) => {\n        if (err) return callback(err);\n        finalize(cachedTimestamp, /** @type {ContextHash} */entry);\n      });\n    } else {\n      this._readContext({\n        path,\n        fromImmutablePath: () => null,\n        fromManagedItem: info => ({\n          safeTime: 0,\n          timestampHash: info,\n          hash: info || \"\"\n        }),\n        fromSymlink: (file, target, callback) => {\n          callback(null, {\n            timestampHash: target,\n            hash: target,\n            symlinks: new Set([target])\n          });\n        },\n        fromFile: (file, stat, callback) => {\n          this._getFileTimestampAndHash(file, callback);\n        },\n        fromDirectory: (directory, stat, callback) => {\n          this.contextTshQueue.increaseParallelism();\n          this.contextTshQueue.add(directory, (err, result) => {\n            this.contextTshQueue.decreaseParallelism();\n            callback(err, result);\n          });\n        },\n        /**\n         * @param {string[]} files files\n         * @param {(Partial<TimestampAndHash> & Partial<ContextTimestampAndHash> | string | null)[]} results results\n         * @returns {ContextTimestampAndHash} tsh\n         */\n        reduce: (files, results) => {\n          let symlinks;\n          const tsHash = createHash(this._hashFunction);\n          const hash = createHash(this._hashFunction);\n          for (const file of files) {\n            tsHash.update(file);\n            hash.update(file);\n          }\n          let safeTime = 0;\n          for (const entry of results) {\n            if (!entry) {\n              tsHash.update(\"n\");\n              continue;\n            }\n            if (typeof entry === \"string\") {\n              tsHash.update(\"n\");\n              hash.update(entry);\n              continue;\n            }\n            if (entry.timestamp) {\n              tsHash.update(\"f\");\n              tsHash.update(`${entry.timestamp}`);\n            } else if (entry.timestampHash) {\n              tsHash.update(\"d\");\n              tsHash.update(`${entry.timestampHash}`);\n            }\n            if (entry.symlinks !== undefined) {\n              if (symlinks === undefined) symlinks = new Set();\n              addAll(entry.symlinks, symlinks);\n            }\n            if (entry.safeTime) {\n              safeTime = Math.max(safeTime, entry.safeTime);\n            }\n            hash.update(/** @type {string} */entry.hash);\n          }\n\n          /** @type {ContextTimestampAndHash} */\n          const result = {\n            safeTime,\n            timestampHash: (/** @type {string} */tsHash.digest(\"hex\")),\n            hash: (/** @type {string} */hash.digest(\"hex\"))\n          };\n          if (symlinks) result.symlinks = symlinks;\n          return result;\n        }\n      }, (err, _result) => {\n        if (err) return callback(/** @type {WebpackError} */err);\n        const result = /** @type {ContextTimestampAndHash} */_result;\n        this._contextTshs.set(path, result);\n        return callback(null, result);\n      });\n    }\n  }\n\n  /**\n   * @param {ContextTimestampAndHash} entry entry\n   * @param {ProcessorCallback<ResolvedContextTimestampAndHash>} callback callback\n   * @returns {void}\n   */\n  _resolveContextTsh(entry, callback) {\n    /** @type {string[]} */\n    const hashes = [];\n    /** @type {string[]} */\n    const tsHashes = [];\n    let safeTime = 0;\n    processAsyncTree(/** @type {NonNullable<ContextHash[\"symlinks\"]>} */entry.symlinks, 10, (target, push, callback) => {\n      this._getUnresolvedContextTsh(target, (err, entry) => {\n        if (err) return callback(err);\n        if (entry) {\n          hashes.push(entry.hash);\n          if (entry.timestampHash) tsHashes.push(entry.timestampHash);\n          if (entry.safeTime) {\n            safeTime = Math.max(safeTime, entry.safeTime);\n          }\n          if (entry.symlinks !== undefined) {\n            for (const target of entry.symlinks) push(target);\n          }\n        }\n        callback();\n      });\n    }, err => {\n      if (err) return callback(/** @type {WebpackError} */err);\n      const hash = createHash(this._hashFunction);\n      const tsHash = createHash(this._hashFunction);\n      hash.update(entry.hash);\n      if (entry.timestampHash) tsHash.update(entry.timestampHash);\n      if (entry.safeTime) {\n        safeTime = Math.max(safeTime, entry.safeTime);\n      }\n      hashes.sort();\n      for (const h of hashes) {\n        hash.update(h);\n      }\n      tsHashes.sort();\n      for (const h of tsHashes) {\n        tsHash.update(h);\n      }\n      callback(null, entry.resolved = {\n        safeTime,\n        timestampHash: (/** @type {string} */tsHash.digest(\"hex\")),\n        hash: (/** @type {string} */hash.digest(\"hex\"))\n      });\n    });\n  }\n\n  /**\n   * @type {Processor<string, Set<string>>}\n   * @private\n   */\n  _getManagedItemDirectoryInfo(path, callback) {\n    this.fs.readdir(path, (err, elements) => {\n      if (err) {\n        if (err.code === \"ENOENT\" || err.code === \"ENOTDIR\") {\n          return callback(null, EMPTY_SET);\n        }\n        return callback(/** @type {WebpackError} */err);\n      }\n      const set = new Set(/** @type {string[]} */elements.map(element => join(this.fs, path, element)));\n      callback(null, set);\n    });\n  }\n\n  /**\n   * @type {Processor<string, string>}\n   * @private\n   */\n  _getManagedItemInfo(path, callback) {\n    const dir = dirname(this.fs, path);\n    this.managedItemDirectoryQueue.add(dir, (err, elements) => {\n      if (err) {\n        return callback(err);\n      }\n      if (!(/** @type {Set<string>} */elements.has(path))) {\n        // file or directory doesn't exist\n        this._managedItems.set(path, \"*missing\");\n        return callback(null, \"*missing\");\n      }\n      // something exists\n      // it may be a file or directory\n      if (path.endsWith(\"node_modules\") && (path.endsWith(\"/node_modules\") || path.endsWith(\"\\\\node_modules\"))) {\n        // we are only interested in existence of this special directory\n        this._managedItems.set(path, \"*node_modules\");\n        return callback(null, \"*node_modules\");\n      }\n\n      // we assume it's a directory, as files shouldn't occur in managed paths\n      const packageJsonPath = join(this.fs, path, \"package.json\");\n      this.fs.readFile(packageJsonPath, (err, content) => {\n        if (err) {\n          if (err.code === \"ENOENT\" || err.code === \"ENOTDIR\") {\n            // no package.json or path is not a directory\n            this.fs.readdir(path, (err, elements) => {\n              if (!err && /** @type {string[]} */elements.length === 1 && /** @type {string[]} */elements[0] === \"node_modules\") {\n                // This is only a grouping folder e.g. used by yarn\n                // we are only interested in existence of this special directory\n                this._managedItems.set(path, \"*nested\");\n                return callback(null, \"*nested\");\n              }\n              /** @type {Logger} */\n              this.logger.warn(`Managed item ${path} isn't a directory or doesn't contain a package.json (see snapshot.managedPaths option)`);\n              return callback();\n            });\n            return;\n          }\n          return callback(/** @type {WebpackError} */err);\n        }\n        let data;\n        try {\n          data = JSON.parse(/** @type {Buffer} */content.toString(\"utf-8\"));\n        } catch (parseErr) {\n          return callback(/** @type {WebpackError} */parseErr);\n        }\n        if (!data.name) {\n          /** @type {Logger} */\n          this.logger.warn(`${packageJsonPath} doesn't contain a \"name\" property (see snapshot.managedPaths option)`);\n          return callback();\n        }\n        const info = `${data.name || \"\"}@${data.version || \"\"}`;\n        this._managedItems.set(path, info);\n        callback(null, info);\n      });\n    });\n  }\n  getDeprecatedFileTimestamps() {\n    if (this._cachedDeprecatedFileTimestamps !== undefined) return this._cachedDeprecatedFileTimestamps;\n    const map = new Map();\n    for (const [path, info] of this._fileTimestamps) {\n      if (info) map.set(path, typeof info === \"object\" ? info.safeTime : null);\n    }\n    return this._cachedDeprecatedFileTimestamps = map;\n  }\n  getDeprecatedContextTimestamps() {\n    if (this._cachedDeprecatedContextTimestamps !== undefined) return this._cachedDeprecatedContextTimestamps;\n    const map = new Map();\n    for (const [path, info] of this._contextTimestamps) {\n      if (info) map.set(path, typeof info === \"object\" ? info.safeTime : null);\n    }\n    return this._cachedDeprecatedContextTimestamps = map;\n  }\n}\nmodule.exports = FileSystemInfo;\nmodule.exports.Snapshot = Snapshot;","map":{"version":3,"names":["create","createResolver","require","nodeModule","asyncLib","isAbsolute","AsyncQueue","StackedCacheMap","createHash","join","dirname","relative","lstatReadlinkAbsolute","makeSerializable","processAsyncTree","supportsEsm","Number","process","versions","modules","builtinModules","Set","FS_ACCURACY","EMPTY_SET","RBDT_RESOLVE_CJS","RBDT_RESOLVE_ESM","RBDT_RESOLVE_DIRECTORY","RBDT_RESOLVE_CJS_FILE","RBDT_RESOLVE_CJS_FILE_AS_CHILD","RBDT_RESOLVE_ESM_FILE","RBDT_DIRECTORY","RBDT_FILE","RBDT_DIRECTORY_DEPENDENCIES","RBDT_FILE_DEPENDENCIES","INVALID","Symbol","DONE_ITERATOR_RESULT","keys","next","SnapshotIterator","constructor","SnapshotIterable","snapshot","getMaps","iterator","state","it","maps","queue","length","map","pop","undefined","result","done","children","size","child","push","Snapshot","_flags","_cachedFileIterable","_cachedContextIterable","_cachedMissingIterable","startTime","fileTimestamps","fileHashes","fileTshs","contextTimestamps","contextHashes","contextTshs","missingExistence","managedItemInfo","managedFiles","managedContexts","managedMissing","hasStartTime","setStartTime","value","setMergedStartTime","Math","min","hasFileTimestamps","setFileTimestamps","hasFileHashes","setFileHashes","hasFileTshs","setFileTshs","hasContextTimestamps","setContextTimestamps","hasContextHashes","setContextHashes","hasContextTshs","setContextTshs","hasMissingExistence","setMissingExistence","hasManagedItemInfo","setManagedItemInfo","hasManagedFiles","setManagedFiles","hasManagedContexts","setManagedContexts","hasManagedMissing","setManagedMissing","hasChildren","setChildren","addChild","add","serialize","write","deserialize","read","_createIterable","getFileIterable","s","getContextIterable","getMissingIterable","MIN_COMMON_SNAPSHOT_SIZE","SnapshotOptimization","has","get","set","useStartTime","isSet","_has","_get","_set","_useStartTime","_isSet","_map","Map","_statItemsShared","_statItemsUnshared","_statSharedSnapshots","_statReusedSharedSnapshots","getStatisticMessage","total","round","clear","optimize","newSnapshot","capturedFiles","increaseSharedAndStoreOptimizationEntry","entry","shared","storeOptimizationEntry","path","snapshotContent","old","delete","newOptimizationEntry","capturedFilesSize","optimizationEntries","optimizationEntry","optimizationEntriesLabel","nonSharedFiles","snapshotEntries","sharedCount","commonMap","commonSnapshot","newEntry","ts","unshared","parseString","str","slice","replace","JSON","parse","applyMtime","mtime","mergeMaps","a","b","key","mergeSets","item","getManagedItem","managedPath","i","slashes","startingPosition","loop","charCodeAt","c","getResolvedTimestamp","resolved","symlinks","getResolvedHash","hash","addAll","source","target","FileSystemInfo","fs","unmanagedPaths","managedPaths","immutablePaths","logger","hashFunction","_remainingLogs","_loggedPaths","_hashFunction","_snapshotCache","WeakMap","_fileTimestampsOptimization","v","_fileHashesOptimization","_fileTshsOptimization","_contextTimestampsOptimization","_contextHashesOptimization","_contextTshsOptimization","_missingExistenceOptimization","_managedItemInfoOptimization","_managedFilesOptimization","_managedContextsOptimization","_managedMissingOptimization","_fileTimestamps","_fileHashes","_fileTshs","_contextTimestamps","_contextHashes","_contextTshs","_managedItems","fileTimestampQueue","name","parallelism","processor","_readFileTimestamp","bind","fileHashQueue","_readFileHash","contextTimestampQueue","_readContextTimestamp","contextHashQueue","_readContextHash","contextTshQueue","_readContextTimestampAndHash","managedItemQueue","_getManagedItemInfo","managedItemDirectoryQueue","_getManagedItemDirectoryInfo","_unmanagedPaths","Array","from","unmanagedPathsWithSlash","filter","p","unmanagedPathsRegExps","managedPathsWithSlash","managedPathsRegExps","immutablePathsWithSlash","immutablePathsRegExps","_cachedDeprecatedFileTimestamps","_cachedDeprecatedContextTimestamps","_warnAboutExperimentalEsmTracking","_statCreatedSnapshots","_statTestedSnapshotsCached","_statTestedSnapshotsNotCached","_statTestedChildrenCached","_statTestedChildrenNotCached","_statTestedEntries","logStatistics","logWhenMessage","header","message","log","_log","reason","args","loggedPaths","debug","addFileTimestamps","immutable","addContextTimestamps","getFileTimestamp","callback","cache","getContextTimestamp","_resolveContextTimestamp","err","_entry","_getUnresolvedContextTimestamp","getFileHash","getContextHash","_resolveContextHash","_getUnresolvedContextHash","getContextTsh","_resolveContextTsh","_getUnresolvedContextTsh","_createBuildDependenciesResolvers","resolveContext","resolveToContext","exportsFields","fileSystem","resolveCjs","extensions","conditionNames","resolveCjsAsChild","resolveEsm","fullySpecified","resolveBuildDependencies","context","deps","files","fileSymlinks","directories","directorySymlinks","missing","resolveFiles","resolveDirectories","resolveMissing","resolveResults","invalidResolveResults","resolverContext","fileDependencies","contextDependencies","missingDependencies","expectedToString","expected","jobToString","job","type","pathToString","issuer","dep","resolveDirectory","_","resultPath","resolveFile","symbol","resolve","warn","isDirectory","test","realpath","_realPath","realPath","nextTick","module","isArray","childPath","filename","modulePath","paths","startsWith","subPath","packageMatch","exec","request","endsWith","lexer","init","then","readFile","content","toString","imports","imp","dependency","d","substring","e","expr","trim","err1","stack","err2","match","packagePath","packageJson","code","parent","packageData","parseErr","depsObject","dependencies","optionalDepsObject","optionalDependencies","allDeps","optionalDeps","Object","l","k","resolveDependencies","checkResolveResultsValid","eachLimit","expectedResult","split","Error","createSnapshot","options","managedItems","mode","timestamp","jobs","jobDone","jobError","checkManaged","managedSet","unmanagedPath","immutablePath","managedItem","captureNonManaged","items","capturedItems","processCapturedFiles","_getFileTimestampAndHash","processCapturedDirectories","capturedDirectories","processCapturedMissing","capturedMissing","Boolean","fn","captured","file","mergeSnapshots","snapshot1","snapshot2","checkSnapshotValid","cachedResult","_checkSnapshotValidNoCache","invalid","invalidWithError","checkHash","current","snap","checkExistence","checkFile","safeTime","checkContext","timestampHash","childCallback","processFileHashSnapshot","tsh","processContextHashSnapshot","existence","info","callbacks","stat","_stat","Infinity","update","digest","continueWithHash","_readContext","fromImmutablePath","fromManagedItem","fromSymlink","fromFile","fromDirectory","reduce","readdir","_files","normalize","sort","isFile","results","directory","increaseParallelism","tsEntry","decreaseParallelism","tsEntries","_e","max","hashes","h","_result","finalize","cachedHash","cachedTimestamp","tsHash","tsHashes","elements","element","dir","packageJsonPath","data","version","getDeprecatedFileTimestamps","getDeprecatedContextTimestamps","exports"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/webpack/lib/FileSystemInfo.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst { create: createResolver } = require(\"enhanced-resolve\");\nconst nodeModule = require(\"module\");\nconst asyncLib = require(\"neo-async\");\nconst { isAbsolute } = require(\"path\");\nconst AsyncQueue = require(\"./util/AsyncQueue\");\nconst StackedCacheMap = require(\"./util/StackedCacheMap\");\nconst createHash = require(\"./util/createHash\");\nconst { join, dirname, relative, lstatReadlinkAbsolute } = require(\"./util/fs\");\nconst makeSerializable = require(\"./util/makeSerializable\");\nconst processAsyncTree = require(\"./util/processAsyncTree\");\n\n/** @typedef {import(\"enhanced-resolve\").Resolver} Resolver */\n/** @typedef {import(\"enhanced-resolve\").ResolveRequest} ResolveRequest */\n/** @typedef {import(\"enhanced-resolve\").ResolveFunctionAsync} ResolveFunctionAsync */\n/** @typedef {import(\"./WebpackError\")} WebpackError */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./serialization/ObjectMiddleware\").ObjectDeserializerContext} ObjectDeserializerContext */\n/** @typedef {import(\"./serialization/ObjectMiddleware\").ObjectSerializerContext} ObjectSerializerContext */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n/** @typedef {import(\"./util/fs\").IStats} IStats */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").PathLike} PathLike */\n/** @typedef {import(\"./util/fs\").StringCallback} StringCallback */\n/**\n * @template T\n * @typedef {import(\"./util/AsyncQueue\").Callback<T>} ProcessorCallback\n */\n/**\n * @template T, R\n * @typedef {import(\"./util/AsyncQueue\").Processor<T, R>} Processor\n */\n\nconst supportsEsm = Number(process.versions.modules) >= 83;\n\n/** @type {Set<string>} */\nconst builtinModules = new Set(nodeModule.builtinModules);\n\nlet FS_ACCURACY = 2000;\n\nconst EMPTY_SET = new Set();\n\nconst RBDT_RESOLVE_CJS = 0;\nconst RBDT_RESOLVE_ESM = 1;\nconst RBDT_RESOLVE_DIRECTORY = 2;\nconst RBDT_RESOLVE_CJS_FILE = 3;\nconst RBDT_RESOLVE_CJS_FILE_AS_CHILD = 4;\nconst RBDT_RESOLVE_ESM_FILE = 5;\nconst RBDT_DIRECTORY = 6;\nconst RBDT_FILE = 7;\nconst RBDT_DIRECTORY_DEPENDENCIES = 8;\nconst RBDT_FILE_DEPENDENCIES = 9;\n\n/** @typedef {RBDT_RESOLVE_CJS | RBDT_RESOLVE_ESM | RBDT_RESOLVE_DIRECTORY | RBDT_RESOLVE_CJS_FILE | RBDT_RESOLVE_CJS_FILE_AS_CHILD | RBDT_RESOLVE_ESM_FILE | RBDT_DIRECTORY | RBDT_FILE | RBDT_DIRECTORY_DEPENDENCIES | RBDT_FILE_DEPENDENCIES} JobType */\n\nconst INVALID = Symbol(\"invalid\");\n\n/**\n * @typedef {object} FileSystemInfoEntry\n * @property {number} safeTime\n * @property {number=} timestamp\n */\n\n/**\n * @typedef {object} ResolvedContextFileSystemInfoEntry\n * @property {number} safeTime\n * @property {string=} timestampHash\n */\n\n/**\n * @typedef {object} ContextFileSystemInfoEntry\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {ResolvedContextFileSystemInfoEntry=} resolved\n * @property {Set<string>=} symlinks\n */\n\n/**\n * @typedef {object} TimestampAndHash\n * @property {number} safeTime\n * @property {number=} timestamp\n * @property {string} hash\n */\n\n/**\n * @typedef {object} ResolvedContextTimestampAndHash\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {string} hash\n */\n\n/** @typedef {Set<string>} Symlinks */\n\n/**\n * @typedef {object} ContextTimestampAndHash\n * @property {number} safeTime\n * @property {string=} timestampHash\n * @property {string} hash\n * @property {ResolvedContextTimestampAndHash=} resolved\n * @property {Symlinks=} symlinks\n */\n\n/**\n * @typedef {object} ContextHash\n * @property {string} hash\n * @property {string=} resolved\n * @property {Symlinks=} symlinks\n */\n\n/** @typedef {Set<string>} SnapshotContent */\n\n/**\n * @typedef {object} SnapshotOptimizationEntry\n * @property {Snapshot} snapshot\n * @property {number} shared\n * @property {SnapshotContent | undefined} snapshotContent\n * @property {Set<SnapshotOptimizationEntry> | undefined} children\n */\n\n/**\n * @typedef {object} ResolveBuildDependenciesResult\n * @property {Set<string>} files list of files\n * @property {Set<string>} directories list of directories\n * @property {Set<string>} missing list of missing entries\n * @property {Map<string, string | false | undefined>} resolveResults stored resolve results\n * @property {object} resolveDependencies dependencies of the resolving\n * @property {Set<string>} resolveDependencies.files list of files\n * @property {Set<string>} resolveDependencies.directories list of directories\n * @property {Set<string>} resolveDependencies.missing list of missing entries\n */\n\n/**\n * @typedef {object} SnapshotOptions\n * @property {boolean=} hash should use hash to snapshot\n * @property {boolean=} timestamp should use timestamp to snapshot\n */\n\nconst DONE_ITERATOR_RESULT = new Set().keys().next();\n\n// cspell:word tshs\n// Tsh = Timestamp + Hash\n// Tshs = Timestamp + Hash combinations\n\nclass SnapshotIterator {\n\t/**\n\t * @param {() => IteratorResult<string>} next next\n\t */\n\tconstructor(next) {\n\t\tthis.next = next;\n\t}\n}\n\n/**\n * @typedef {(snapshot: Snapshot) => (Map<string, any> | Set<string> | undefined)[]} GetMapsFunction\n */\n\nclass SnapshotIterable {\n\t/**\n\t * @param {Snapshot} snapshot snapshot\n\t * @param {GetMapsFunction} getMaps get maps function\n\t */\n\tconstructor(snapshot, getMaps) {\n\t\tthis.snapshot = snapshot;\n\t\tthis.getMaps = getMaps;\n\t}\n\n\t[Symbol.iterator]() {\n\t\tlet state = 0;\n\t\t/** @type {IterableIterator<string>} */\n\t\tlet it;\n\t\t/** @type {(snapshot: Snapshot) => (Map<string, any> | Set<string> | undefined)[]} */\n\t\tlet getMaps;\n\t\t/** @type {(Map<string, any> | Set<string> | undefined)[]} */\n\t\tlet maps;\n\t\t/** @type {Snapshot} */\n\t\tlet snapshot;\n\t\t/** @type {Snapshot[] | undefined} */\n\t\tlet queue;\n\t\treturn new SnapshotIterator(() => {\n\t\t\tfor (;;) {\n\t\t\t\tswitch (state) {\n\t\t\t\t\tcase 0:\n\t\t\t\t\t\tsnapshot = this.snapshot;\n\t\t\t\t\t\tgetMaps = this.getMaps;\n\t\t\t\t\t\tmaps = getMaps(snapshot);\n\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t/* falls through */\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tif (maps.length > 0) {\n\t\t\t\t\t\t\tconst map = maps.pop();\n\t\t\t\t\t\t\tif (map !== undefined) {\n\t\t\t\t\t\t\t\tit = map.keys();\n\t\t\t\t\t\t\t\tstate = 2;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstate = 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t/* falls through */\n\t\t\t\t\tcase 2: {\n\t\t\t\t\t\tconst result = it.next();\n\t\t\t\t\t\tif (!result.done) return result;\n\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase 3: {\n\t\t\t\t\t\tconst children = snapshot.children;\n\t\t\t\t\t\tif (children !== undefined) {\n\t\t\t\t\t\t\tif (children.size === 1) {\n\t\t\t\t\t\t\t\t// shortcut for a single child\n\t\t\t\t\t\t\t\t// avoids allocation of queue\n\t\t\t\t\t\t\t\tfor (const child of children) snapshot = child;\n\t\t\t\t\t\t\t\tmaps = getMaps(snapshot);\n\t\t\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (queue === undefined) queue = [];\n\t\t\t\t\t\t\tfor (const child of children) {\n\t\t\t\t\t\t\t\tqueue.push(child);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (queue !== undefined && queue.length > 0) {\n\t\t\t\t\t\t\tsnapshot = /** @type {Snapshot} */ (queue.pop());\n\t\t\t\t\t\t\tmaps = getMaps(snapshot);\n\t\t\t\t\t\t\tstate = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstate = 4;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t/* falls through */\n\t\t\t\t\tcase 4:\n\t\t\t\t\t\treturn DONE_ITERATOR_RESULT;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\n/** @typedef {Map<string, FileSystemInfoEntry | null>} FileTimestamps */\n/** @typedef {Map<string, string | null>} FileHashes */\n/** @typedef {Map<string, TimestampAndHash | string | null>} FileTshs */\n/** @typedef {Map<string, ResolvedContextFileSystemInfoEntry | null>} ContextTimestamps */\n/** @typedef {Map<string, string | null>} ContextHashes */\n/** @typedef {Map<string, ResolvedContextTimestampAndHash | null>} ContextTshs */\n/** @typedef {Map<string, boolean>} MissingExistence */\n/** @typedef {Map<string, string>} ManagedItemInfo */\n/** @typedef {Set<string>} ManagedFiles */\n/** @typedef {Set<string>} ManagedContexts */\n/** @typedef {Set<string>} ManagedMissing */\n/** @typedef {Set<Snapshot>} Children */\n\nclass Snapshot {\n\tconstructor() {\n\t\tthis._flags = 0;\n\t\t/** @type {Iterable<string> | undefined} */\n\t\tthis._cachedFileIterable = undefined;\n\t\t/** @type {Iterable<string> | undefined} */\n\t\tthis._cachedContextIterable = undefined;\n\t\t/** @type {Iterable<string> | undefined} */\n\t\tthis._cachedMissingIterable = undefined;\n\t\t/** @type {number | undefined} */\n\t\tthis.startTime = undefined;\n\t\t/** @type {FileTimestamps | undefined} */\n\t\tthis.fileTimestamps = undefined;\n\t\t/** @type {FileHashes | undefined} */\n\t\tthis.fileHashes = undefined;\n\t\t/** @type {FileTshs | undefined} */\n\t\tthis.fileTshs = undefined;\n\t\t/** @type {ContextTimestamps | undefined} */\n\t\tthis.contextTimestamps = undefined;\n\t\t/** @type {ContextHashes | undefined} */\n\t\tthis.contextHashes = undefined;\n\t\t/** @type {ContextTshs | undefined} */\n\t\tthis.contextTshs = undefined;\n\t\t/** @type {MissingExistence | undefined} */\n\t\tthis.missingExistence = undefined;\n\t\t/** @type {ManagedItemInfo | undefined} */\n\t\tthis.managedItemInfo = undefined;\n\t\t/** @type {ManagedFiles | undefined} */\n\t\tthis.managedFiles = undefined;\n\t\t/** @type {ManagedContexts | undefined} */\n\t\tthis.managedContexts = undefined;\n\t\t/** @type {ManagedMissing | undefined} */\n\t\tthis.managedMissing = undefined;\n\t\t/** @type {Children | undefined} */\n\t\tthis.children = undefined;\n\t}\n\n\thasStartTime() {\n\t\treturn (this._flags & 1) !== 0;\n\t}\n\n\t/**\n\t * @param {number} value start value\n\t */\n\tsetStartTime(value) {\n\t\tthis._flags = this._flags | 1;\n\t\tthis.startTime = value;\n\t}\n\n\t/**\n\t * @param {number | undefined} value value\n\t * @param {Snapshot} snapshot snapshot\n\t */\n\tsetMergedStartTime(value, snapshot) {\n\t\tif (value) {\n\t\t\tif (snapshot.hasStartTime()) {\n\t\t\t\tthis.setStartTime(\n\t\t\t\t\tMath.min(\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t/** @type {NonNullable<Snapshot[\"startTime\"]>} */\n\t\t\t\t\t\t(snapshot.startTime)\n\t\t\t\t\t)\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis.setStartTime(value);\n\t\t\t}\n\t\t} else if (snapshot.hasStartTime()) {\n\t\t\tthis.setStartTime(\n\t\t\t\t/** @type {NonNullable<Snapshot[\"startTime\"]>} */\n\t\t\t\t(snapshot.startTime)\n\t\t\t);\n\t\t}\n\t}\n\n\thasFileTimestamps() {\n\t\treturn (this._flags & 2) !== 0;\n\t}\n\n\t/**\n\t * @param {FileTimestamps} value file timestamps\n\t */\n\tsetFileTimestamps(value) {\n\t\tthis._flags = this._flags | 2;\n\t\tthis.fileTimestamps = value;\n\t}\n\n\thasFileHashes() {\n\t\treturn (this._flags & 4) !== 0;\n\t}\n\n\t/**\n\t * @param {FileHashes} value file hashes\n\t */\n\tsetFileHashes(value) {\n\t\tthis._flags = this._flags | 4;\n\t\tthis.fileHashes = value;\n\t}\n\n\thasFileTshs() {\n\t\treturn (this._flags & 8) !== 0;\n\t}\n\n\t/**\n\t * @param {FileTshs} value file tshs\n\t */\n\tsetFileTshs(value) {\n\t\tthis._flags = this._flags | 8;\n\t\tthis.fileTshs = value;\n\t}\n\n\thasContextTimestamps() {\n\t\treturn (this._flags & 0x10) !== 0;\n\t}\n\n\t/**\n\t * @param {ContextTimestamps} value context timestamps\n\t */\n\tsetContextTimestamps(value) {\n\t\tthis._flags = this._flags | 0x10;\n\t\tthis.contextTimestamps = value;\n\t}\n\n\thasContextHashes() {\n\t\treturn (this._flags & 0x20) !== 0;\n\t}\n\n\t/**\n\t * @param {ContextHashes} value context hashes\n\t */\n\tsetContextHashes(value) {\n\t\tthis._flags = this._flags | 0x20;\n\t\tthis.contextHashes = value;\n\t}\n\n\thasContextTshs() {\n\t\treturn (this._flags & 0x40) !== 0;\n\t}\n\n\t/**\n\t * @param {ContextTshs} value context tshs\n\t */\n\tsetContextTshs(value) {\n\t\tthis._flags = this._flags | 0x40;\n\t\tthis.contextTshs = value;\n\t}\n\n\thasMissingExistence() {\n\t\treturn (this._flags & 0x80) !== 0;\n\t}\n\n\t/**\n\t * @param {MissingExistence} value context tshs\n\t */\n\tsetMissingExistence(value) {\n\t\tthis._flags = this._flags | 0x80;\n\t\tthis.missingExistence = value;\n\t}\n\n\thasManagedItemInfo() {\n\t\treturn (this._flags & 0x100) !== 0;\n\t}\n\n\t/**\n\t * @param {ManagedItemInfo} value managed item info\n\t */\n\tsetManagedItemInfo(value) {\n\t\tthis._flags = this._flags | 0x100;\n\t\tthis.managedItemInfo = value;\n\t}\n\n\thasManagedFiles() {\n\t\treturn (this._flags & 0x200) !== 0;\n\t}\n\n\t/**\n\t * @param {ManagedFiles} value managed files\n\t */\n\tsetManagedFiles(value) {\n\t\tthis._flags = this._flags | 0x200;\n\t\tthis.managedFiles = value;\n\t}\n\n\thasManagedContexts() {\n\t\treturn (this._flags & 0x400) !== 0;\n\t}\n\n\t/**\n\t * @param {ManagedContexts} value managed contexts\n\t */\n\tsetManagedContexts(value) {\n\t\tthis._flags = this._flags | 0x400;\n\t\tthis.managedContexts = value;\n\t}\n\n\thasManagedMissing() {\n\t\treturn (this._flags & 0x800) !== 0;\n\t}\n\n\t/**\n\t * @param {ManagedMissing} value managed missing\n\t */\n\tsetManagedMissing(value) {\n\t\tthis._flags = this._flags | 0x800;\n\t\tthis.managedMissing = value;\n\t}\n\n\thasChildren() {\n\t\treturn (this._flags & 0x1000) !== 0;\n\t}\n\n\t/**\n\t * @param {Children} value children\n\t */\n\tsetChildren(value) {\n\t\tthis._flags = this._flags | 0x1000;\n\t\tthis.children = value;\n\t}\n\n\t/**\n\t * @param {Snapshot} child children\n\t */\n\taddChild(child) {\n\t\tif (!this.hasChildren()) {\n\t\t\tthis.setChildren(new Set());\n\t\t}\n\t\t/** @type {Children} */\n\t\t(this.children).add(child);\n\t}\n\n\t/**\n\t * @param {ObjectSerializerContext} context context\n\t */\n\tserialize({ write }) {\n\t\twrite(this._flags);\n\t\tif (this.hasStartTime()) write(this.startTime);\n\t\tif (this.hasFileTimestamps()) write(this.fileTimestamps);\n\t\tif (this.hasFileHashes()) write(this.fileHashes);\n\t\tif (this.hasFileTshs()) write(this.fileTshs);\n\t\tif (this.hasContextTimestamps()) write(this.contextTimestamps);\n\t\tif (this.hasContextHashes()) write(this.contextHashes);\n\t\tif (this.hasContextTshs()) write(this.contextTshs);\n\t\tif (this.hasMissingExistence()) write(this.missingExistence);\n\t\tif (this.hasManagedItemInfo()) write(this.managedItemInfo);\n\t\tif (this.hasManagedFiles()) write(this.managedFiles);\n\t\tif (this.hasManagedContexts()) write(this.managedContexts);\n\t\tif (this.hasManagedMissing()) write(this.managedMissing);\n\t\tif (this.hasChildren()) write(this.children);\n\t}\n\n\t/**\n\t * @param {ObjectDeserializerContext} context context\n\t */\n\tdeserialize({ read }) {\n\t\tthis._flags = read();\n\t\tif (this.hasStartTime()) this.startTime = read();\n\t\tif (this.hasFileTimestamps()) this.fileTimestamps = read();\n\t\tif (this.hasFileHashes()) this.fileHashes = read();\n\t\tif (this.hasFileTshs()) this.fileTshs = read();\n\t\tif (this.hasContextTimestamps()) this.contextTimestamps = read();\n\t\tif (this.hasContextHashes()) this.contextHashes = read();\n\t\tif (this.hasContextTshs()) this.contextTshs = read();\n\t\tif (this.hasMissingExistence()) this.missingExistence = read();\n\t\tif (this.hasManagedItemInfo()) this.managedItemInfo = read();\n\t\tif (this.hasManagedFiles()) this.managedFiles = read();\n\t\tif (this.hasManagedContexts()) this.managedContexts = read();\n\t\tif (this.hasManagedMissing()) this.managedMissing = read();\n\t\tif (this.hasChildren()) this.children = read();\n\t}\n\n\t/**\n\t * @param {GetMapsFunction} getMaps first\n\t * @returns {Iterable<string>} iterable\n\t */\n\t_createIterable(getMaps) {\n\t\treturn new SnapshotIterable(this, getMaps);\n\t}\n\n\t/**\n\t * @returns {Iterable<string>} iterable\n\t */\n\tgetFileIterable() {\n\t\tif (this._cachedFileIterable === undefined) {\n\t\t\tthis._cachedFileIterable = this._createIterable(s => [\n\t\t\t\ts.fileTimestamps,\n\t\t\t\ts.fileHashes,\n\t\t\t\ts.fileTshs,\n\t\t\t\ts.managedFiles\n\t\t\t]);\n\t\t}\n\t\treturn this._cachedFileIterable;\n\t}\n\n\t/**\n\t * @returns {Iterable<string>} iterable\n\t */\n\tgetContextIterable() {\n\t\tif (this._cachedContextIterable === undefined) {\n\t\t\tthis._cachedContextIterable = this._createIterable(s => [\n\t\t\t\ts.contextTimestamps,\n\t\t\t\ts.contextHashes,\n\t\t\t\ts.contextTshs,\n\t\t\t\ts.managedContexts\n\t\t\t]);\n\t\t}\n\t\treturn this._cachedContextIterable;\n\t}\n\n\t/**\n\t * @returns {Iterable<string>} iterable\n\t */\n\tgetMissingIterable() {\n\t\tif (this._cachedMissingIterable === undefined) {\n\t\t\tthis._cachedMissingIterable = this._createIterable(s => [\n\t\t\t\ts.missingExistence,\n\t\t\t\ts.managedMissing\n\t\t\t]);\n\t\t}\n\t\treturn this._cachedMissingIterable;\n\t}\n}\n\nmakeSerializable(Snapshot, \"webpack/lib/FileSystemInfo\", \"Snapshot\");\n\nconst MIN_COMMON_SNAPSHOT_SIZE = 3;\n\n/**\n * @template U, T\n * @typedef {U extends true ? Set<string> : Map<string, T>} SnapshotOptimizationValue\n */\n\n/**\n * @template T\n * @template {boolean} [U=false]\n */\nclass SnapshotOptimization {\n\t/**\n\t * @param {function(Snapshot): boolean} has has value\n\t * @param {function(Snapshot): SnapshotOptimizationValue<U, T> | undefined} get get value\n\t * @param {function(Snapshot, SnapshotOptimizationValue<U, T>): void} set set value\n\t * @param {boolean=} useStartTime use the start time of snapshots\n\t * @param {U=} isSet value is an Set instead of a Map\n\t */\n\tconstructor(\n\t\thas,\n\t\tget,\n\t\tset,\n\t\tuseStartTime = true,\n\t\tisSet = /** @type {U} */ (false)\n\t) {\n\t\tthis._has = has;\n\t\tthis._get = get;\n\t\tthis._set = set;\n\t\tthis._useStartTime = useStartTime;\n\t\t/** @type {U} */\n\t\tthis._isSet = isSet;\n\t\t/** @type {Map<string, SnapshotOptimizationEntry>} */\n\t\tthis._map = new Map();\n\t\tthis._statItemsShared = 0;\n\t\tthis._statItemsUnshared = 0;\n\t\tthis._statSharedSnapshots = 0;\n\t\tthis._statReusedSharedSnapshots = 0;\n\t}\n\n\tgetStatisticMessage() {\n\t\tconst total = this._statItemsShared + this._statItemsUnshared;\n\t\tif (total === 0) return;\n\t\treturn `${\n\t\t\tthis._statItemsShared && Math.round((this._statItemsShared * 100) / total)\n\t\t}% (${this._statItemsShared}/${total}) entries shared via ${\n\t\t\tthis._statSharedSnapshots\n\t\t} shared snapshots (${\n\t\t\tthis._statReusedSharedSnapshots + this._statSharedSnapshots\n\t\t} times referenced)`;\n\t}\n\n\tclear() {\n\t\tthis._map.clear();\n\t\tthis._statItemsShared = 0;\n\t\tthis._statItemsUnshared = 0;\n\t\tthis._statSharedSnapshots = 0;\n\t\tthis._statReusedSharedSnapshots = 0;\n\t}\n\n\t/**\n\t * @param {Snapshot} newSnapshot snapshot\n\t * @param {Set<string>} capturedFiles files to snapshot/share\n\t * @returns {void}\n\t */\n\toptimize(newSnapshot, capturedFiles) {\n\t\t/**\n\t\t * @param {SnapshotOptimizationEntry} entry optimization entry\n\t\t * @returns {void}\n\t\t */\n\t\tconst increaseSharedAndStoreOptimizationEntry = entry => {\n\t\t\tif (entry.children !== undefined) {\n\t\t\t\tfor (const child of entry.children) {\n\t\t\t\t\tincreaseSharedAndStoreOptimizationEntry(child);\n\t\t\t\t}\n\t\t\t}\n\t\t\tentry.shared++;\n\t\t\tstoreOptimizationEntry(entry);\n\t\t};\n\t\t/**\n\t\t * @param {SnapshotOptimizationEntry} entry optimization entry\n\t\t * @returns {void}\n\t\t */\n\t\tconst storeOptimizationEntry = entry => {\n\t\t\tfor (const path of /** @type {SnapshotContent} */ (\n\t\t\t\tentry.snapshotContent\n\t\t\t)) {\n\t\t\t\tconst old =\n\t\t\t\t\t/** @type {SnapshotOptimizationEntry} */\n\t\t\t\t\t(this._map.get(path));\n\t\t\t\tif (old.shared < entry.shared) {\n\t\t\t\t\tthis._map.set(path, entry);\n\t\t\t\t}\n\t\t\t\tcapturedFiles.delete(path);\n\t\t\t}\n\t\t};\n\n\t\t/** @type {SnapshotOptimizationEntry | undefined} */\n\t\tlet newOptimizationEntry;\n\n\t\tconst capturedFilesSize = capturedFiles.size;\n\n\t\t/** @type {Set<SnapshotOptimizationEntry> | undefined} */\n\t\tconst optimizationEntries = new Set();\n\n\t\tfor (const path of capturedFiles) {\n\t\t\tconst optimizationEntry = this._map.get(path);\n\t\t\tif (optimizationEntry === undefined) {\n\t\t\t\tif (newOptimizationEntry === undefined) {\n\t\t\t\t\tnewOptimizationEntry = {\n\t\t\t\t\t\tsnapshot: newSnapshot,\n\t\t\t\t\t\tshared: 0,\n\t\t\t\t\t\tsnapshotContent: undefined,\n\t\t\t\t\t\tchildren: undefined\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tthis._map.set(path, newOptimizationEntry);\n\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\toptimizationEntries.add(optimizationEntry);\n\t\t\t}\n\t\t}\n\n\t\toptimizationEntriesLabel: for (const optimizationEntry of optimizationEntries) {\n\t\t\tconst snapshot = optimizationEntry.snapshot;\n\t\t\tif (optimizationEntry.shared > 0) {\n\t\t\t\t// It's a shared snapshot\n\t\t\t\t// We can't change it, so we can only use it when all files match\n\t\t\t\t// and startTime is compatible\n\t\t\t\tif (\n\t\t\t\t\tthis._useStartTime &&\n\t\t\t\t\tnewSnapshot.startTime &&\n\t\t\t\t\t(!snapshot.startTime || snapshot.startTime > newSnapshot.startTime)\n\t\t\t\t) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst nonSharedFiles = new Set();\n\t\t\t\tconst snapshotContent =\n\t\t\t\t\t/** @type {NonNullable<SnapshotOptimizationEntry[\"snapshotContent\"]>} */\n\t\t\t\t\t(optimizationEntry.snapshotContent);\n\t\t\t\tconst snapshotEntries =\n\t\t\t\t\t/** @type {SnapshotOptimizationValue<U, T>} */\n\t\t\t\t\t(this._get(snapshot));\n\t\t\t\tfor (const path of snapshotContent) {\n\t\t\t\t\tif (!capturedFiles.has(path)) {\n\t\t\t\t\t\tif (!snapshotEntries.has(path)) {\n\t\t\t\t\t\t\t// File is not shared and can't be removed from the snapshot\n\t\t\t\t\t\t\t// because it's in a child of the snapshot\n\t\t\t\t\t\t\tcontinue optimizationEntriesLabel;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnonSharedFiles.add(path);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (nonSharedFiles.size === 0) {\n\t\t\t\t\t// The complete snapshot is shared\n\t\t\t\t\t// add it as child\n\t\t\t\t\tnewSnapshot.addChild(snapshot);\n\t\t\t\t\tincreaseSharedAndStoreOptimizationEntry(optimizationEntry);\n\t\t\t\t\tthis._statReusedSharedSnapshots++;\n\t\t\t\t} else {\n\t\t\t\t\t// Only a part of the snapshot is shared\n\t\t\t\t\tconst sharedCount = snapshotContent.size - nonSharedFiles.size;\n\t\t\t\t\tif (sharedCount < MIN_COMMON_SNAPSHOT_SIZE) {\n\t\t\t\t\t\t// Common part it too small\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t// Extract common timestamps from both snapshots\n\t\t\t\t\tlet commonMap;\n\t\t\t\t\tif (this._isSet) {\n\t\t\t\t\t\tcommonMap = new Set();\n\t\t\t\t\t\tfor (const path of /** @type {Set<string>} */ (snapshotEntries)) {\n\t\t\t\t\t\t\tif (nonSharedFiles.has(path)) continue;\n\t\t\t\t\t\t\tcommonMap.add(path);\n\t\t\t\t\t\t\tsnapshotEntries.delete(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcommonMap = new Map();\n\t\t\t\t\t\tconst map = /** @type {Map<string, T>} */ (snapshotEntries);\n\t\t\t\t\t\tfor (const [path, value] of map) {\n\t\t\t\t\t\t\tif (nonSharedFiles.has(path)) continue;\n\t\t\t\t\t\t\tcommonMap.set(path, value);\n\t\t\t\t\t\t\tsnapshotEntries.delete(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// Create and attach snapshot\n\t\t\t\t\tconst commonSnapshot = new Snapshot();\n\t\t\t\t\tif (this._useStartTime) {\n\t\t\t\t\t\tcommonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot);\n\t\t\t\t\t}\n\t\t\t\t\tthis._set(\n\t\t\t\t\t\tcommonSnapshot,\n\t\t\t\t\t\t/** @type {SnapshotOptimizationValue<U, T>} */ (commonMap)\n\t\t\t\t\t);\n\t\t\t\t\tnewSnapshot.addChild(commonSnapshot);\n\t\t\t\t\tsnapshot.addChild(commonSnapshot);\n\t\t\t\t\t// Create optimization entry\n\t\t\t\t\tconst newEntry = {\n\t\t\t\t\t\tsnapshot: commonSnapshot,\n\t\t\t\t\t\tshared: optimizationEntry.shared + 1,\n\t\t\t\t\t\tsnapshotContent: new Set(commonMap.keys()),\n\t\t\t\t\t\tchildren: undefined\n\t\t\t\t\t};\n\t\t\t\t\tif (optimizationEntry.children === undefined)\n\t\t\t\t\t\toptimizationEntry.children = new Set();\n\t\t\t\t\toptimizationEntry.children.add(newEntry);\n\t\t\t\t\tstoreOptimizationEntry(newEntry);\n\t\t\t\t\tthis._statSharedSnapshots++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// It's a unshared snapshot\n\t\t\t\t// We can extract a common shared snapshot\n\t\t\t\t// with all common files\n\t\t\t\tconst snapshotEntries = this._get(snapshot);\n\t\t\t\tif (snapshotEntries === undefined) {\n\t\t\t\t\t// Incomplete snapshot, that can't be used\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet commonMap;\n\t\t\t\tif (this._isSet) {\n\t\t\t\t\tcommonMap = new Set();\n\t\t\t\t\tconst set = /** @type {Set<string>} */ (snapshotEntries);\n\t\t\t\t\tif (capturedFiles.size < set.size) {\n\t\t\t\t\t\tfor (const path of capturedFiles) {\n\t\t\t\t\t\t\tif (set.has(path)) commonMap.add(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (const path of set) {\n\t\t\t\t\t\t\tif (capturedFiles.has(path)) commonMap.add(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcommonMap = new Map();\n\t\t\t\t\tconst map = /** @type {Map<string, T>} */ (snapshotEntries);\n\t\t\t\t\tfor (const path of capturedFiles) {\n\t\t\t\t\t\tconst ts = map.get(path);\n\t\t\t\t\t\tif (ts === undefined) continue;\n\t\t\t\t\t\tcommonMap.set(path, ts);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (commonMap.size < MIN_COMMON_SNAPSHOT_SIZE) {\n\t\t\t\t\t// Common part it too small\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// Create and attach snapshot\n\t\t\t\tconst commonSnapshot = new Snapshot();\n\t\t\t\tif (this._useStartTime) {\n\t\t\t\t\tcommonSnapshot.setMergedStartTime(newSnapshot.startTime, snapshot);\n\t\t\t\t}\n\t\t\t\tthis._set(\n\t\t\t\t\tcommonSnapshot,\n\t\t\t\t\t/** @type {SnapshotOptimizationValue<U, T>} */\n\t\t\t\t\t(commonMap)\n\t\t\t\t);\n\t\t\t\tnewSnapshot.addChild(commonSnapshot);\n\t\t\t\tsnapshot.addChild(commonSnapshot);\n\t\t\t\t// Remove files from snapshot\n\t\t\t\tfor (const path of commonMap.keys()) snapshotEntries.delete(path);\n\t\t\t\tconst sharedCount = commonMap.size;\n\t\t\t\tthis._statItemsUnshared -= sharedCount;\n\t\t\t\tthis._statItemsShared += sharedCount;\n\t\t\t\t// Create optimization entry\n\t\t\t\tstoreOptimizationEntry({\n\t\t\t\t\tsnapshot: commonSnapshot,\n\t\t\t\t\tshared: 2,\n\t\t\t\t\tsnapshotContent: new Set(commonMap.keys()),\n\t\t\t\t\tchildren: undefined\n\t\t\t\t});\n\t\t\t\tthis._statSharedSnapshots++;\n\t\t\t}\n\t\t}\n\t\tconst unshared = capturedFiles.size;\n\t\tthis._statItemsUnshared += unshared;\n\t\tthis._statItemsShared += capturedFilesSize - unshared;\n\t}\n}\n\n/**\n * @param {string} str input\n * @returns {string} result\n */\nconst parseString = str => {\n\tif (str[0] === \"'\" || str[0] === \"`\")\n\t\tstr = `\"${str.slice(1, -1).replace(/\"/g, '\\\\\"')}\"`;\n\treturn JSON.parse(str);\n};\n\n/* istanbul ignore next */\n/**\n * @param {number} mtime mtime\n */\nconst applyMtime = mtime => {\n\tif (FS_ACCURACY > 1 && mtime % 2 !== 0) FS_ACCURACY = 1;\n\telse if (FS_ACCURACY > 10 && mtime % 20 !== 0) FS_ACCURACY = 10;\n\telse if (FS_ACCURACY > 100 && mtime % 200 !== 0) FS_ACCURACY = 100;\n\telse if (FS_ACCURACY > 1000 && mtime % 2000 !== 0) FS_ACCURACY = 1000;\n};\n\n/**\n * @template T\n * @template K\n * @param {Map<T, K> | undefined} a source map\n * @param {Map<T, K> | undefined} b joining map\n * @returns {Map<T, K>} joined map\n */\nconst mergeMaps = (a, b) => {\n\tif (!b || b.size === 0) return /** @type {Map<T, K>} */ (a);\n\tif (!a || a.size === 0) return /** @type {Map<T, K>} */ (b);\n\t/** @type {Map<T, K>} */\n\tconst map = new Map(a);\n\tfor (const [key, value] of b) {\n\t\tmap.set(key, value);\n\t}\n\treturn map;\n};\n\n/**\n * @template T\n * @param {Set<T> | undefined} a source map\n * @param {Set<T> | undefined} b joining map\n * @returns {Set<T>} joined map\n */\nconst mergeSets = (a, b) => {\n\tif (!b || b.size === 0) return /** @type {Set<T>} */ (a);\n\tif (!a || a.size === 0) return /** @type {Set<T>} */ (b);\n\t/** @type {Set<T>} */\n\tconst map = new Set(a);\n\tfor (const item of b) {\n\t\tmap.add(item);\n\t}\n\treturn map;\n};\n\n/**\n * Finding file or directory to manage\n * @param {string} managedPath path that is managing by {@link FileSystemInfo}\n * @param {string} path path to file or directory\n * @returns {string|null} managed item\n * @example\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package/index.js'\n * ) === '/Users/user/my-project/node_modules/package'\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package1/node_modules/package2'\n * ) === '/Users/user/my-project/node_modules/package1/node_modules/package2'\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/.bin/script.js'\n * ) === null // hidden files are disallowed as managed items\n * getManagedItem(\n *   '/Users/user/my-project/node_modules/',\n *   '/Users/user/my-project/node_modules/package'\n * ) === '/Users/user/my-project/node_modules/package'\n */\nconst getManagedItem = (managedPath, path) => {\n\tlet i = managedPath.length;\n\tlet slashes = 1;\n\tlet startingPosition = true;\n\tloop: while (i < path.length) {\n\t\tswitch (path.charCodeAt(i)) {\n\t\t\tcase 47: // slash\n\t\t\tcase 92: // backslash\n\t\t\t\tif (--slashes === 0) break loop;\n\t\t\t\tstartingPosition = true;\n\t\t\t\tbreak;\n\t\t\tcase 46: // .\n\t\t\t\t// hidden files are disallowed as managed items\n\t\t\t\t// it's probably .yarn-integrity or .cache\n\t\t\t\tif (startingPosition) return null;\n\t\t\t\tbreak;\n\t\t\tcase 64: // @\n\t\t\t\tif (!startingPosition) return null;\n\t\t\t\tslashes++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tstartingPosition = false;\n\t\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\tif (i === path.length) slashes--;\n\t// return null when path is incomplete\n\tif (slashes !== 0) return null;\n\t// if (path.slice(i + 1, i + 13) === \"node_modules\")\n\tif (\n\t\tpath.length >= i + 13 &&\n\t\tpath.charCodeAt(i + 1) === 110 &&\n\t\tpath.charCodeAt(i + 2) === 111 &&\n\t\tpath.charCodeAt(i + 3) === 100 &&\n\t\tpath.charCodeAt(i + 4) === 101 &&\n\t\tpath.charCodeAt(i + 5) === 95 &&\n\t\tpath.charCodeAt(i + 6) === 109 &&\n\t\tpath.charCodeAt(i + 7) === 111 &&\n\t\tpath.charCodeAt(i + 8) === 100 &&\n\t\tpath.charCodeAt(i + 9) === 117 &&\n\t\tpath.charCodeAt(i + 10) === 108 &&\n\t\tpath.charCodeAt(i + 11) === 101 &&\n\t\tpath.charCodeAt(i + 12) === 115\n\t) {\n\t\t// if this is the end of the path\n\t\tif (path.length === i + 13) {\n\t\t\t// return the node_modules directory\n\t\t\t// it's special\n\t\t\treturn path;\n\t\t}\n\t\tconst c = path.charCodeAt(i + 13);\n\t\t// if next symbol is slash or backslash\n\t\tif (c === 47 || c === 92) {\n\t\t\t// Managed subpath\n\t\t\treturn getManagedItem(path.slice(0, i + 14), path);\n\t\t}\n\t}\n\treturn path.slice(0, i);\n};\n\n/**\n * @template {ContextFileSystemInfoEntry | ContextTimestampAndHash} T\n * @param {T | null} entry entry\n * @returns {T[\"resolved\"] | null | undefined} the resolved entry\n */\nconst getResolvedTimestamp = entry => {\n\tif (entry === null) return null;\n\tif (entry.resolved !== undefined) return entry.resolved;\n\treturn entry.symlinks === undefined ? entry : undefined;\n};\n\n/**\n * @param {ContextHash | null} entry entry\n * @returns {string | null | undefined} the resolved entry\n */\nconst getResolvedHash = entry => {\n\tif (entry === null) return null;\n\tif (entry.resolved !== undefined) return entry.resolved;\n\treturn entry.symlinks === undefined ? entry.hash : undefined;\n};\n\n/**\n * @template T\n * @param {Set<T>} source source\n * @param {Set<T>} target target\n */\nconst addAll = (source, target) => {\n\tfor (const key of source) target.add(key);\n};\n\n/** @typedef {Set<string>} LoggedPaths */\n\n/**\n * Used to access information about the filesystem in a cached way\n */\nclass FileSystemInfo {\n\t/**\n\t * @param {InputFileSystem} fs file system\n\t * @param {object} options options\n\t * @param {Iterable<string | RegExp>=} options.unmanagedPaths paths that are not managed by a package manager and the contents are subject to change\n\t * @param {Iterable<string | RegExp>=} options.managedPaths paths that are only managed by a package manager\n\t * @param {Iterable<string | RegExp>=} options.immutablePaths paths that are immutable\n\t * @param {Logger=} options.logger logger used to log invalid snapshots\n\t * @param {string | Hash=} options.hashFunction the hash function to use\n\t */\n\tconstructor(\n\t\tfs,\n\t\t{\n\t\t\tunmanagedPaths = [],\n\t\t\tmanagedPaths = [],\n\t\t\timmutablePaths = [],\n\t\t\tlogger,\n\t\t\thashFunction = \"md4\"\n\t\t} = {}\n\t) {\n\t\tthis.fs = fs;\n\t\tthis.logger = logger;\n\t\tthis._remainingLogs = logger ? 40 : 0;\n\t\t/** @type {LoggedPaths | undefined} */\n\t\tthis._loggedPaths = logger ? new Set() : undefined;\n\t\tthis._hashFunction = hashFunction;\n\t\t/** @type {WeakMap<Snapshot, boolean | (function((WebpackError | null)=, boolean=): void)[]>} */\n\t\tthis._snapshotCache = new WeakMap();\n\t\tthis._fileTimestampsOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasFileTimestamps(),\n\t\t\ts => s.fileTimestamps,\n\t\t\t(s, v) => s.setFileTimestamps(v)\n\t\t);\n\t\tthis._fileHashesOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasFileHashes(),\n\t\t\ts => s.fileHashes,\n\t\t\t(s, v) => s.setFileHashes(v),\n\t\t\tfalse\n\t\t);\n\t\tthis._fileTshsOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasFileTshs(),\n\t\t\ts => s.fileTshs,\n\t\t\t(s, v) => s.setFileTshs(v)\n\t\t);\n\t\tthis._contextTimestampsOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasContextTimestamps(),\n\t\t\ts => s.contextTimestamps,\n\t\t\t(s, v) => s.setContextTimestamps(v)\n\t\t);\n\t\tthis._contextHashesOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasContextHashes(),\n\t\t\ts => s.contextHashes,\n\t\t\t(s, v) => s.setContextHashes(v),\n\t\t\tfalse\n\t\t);\n\t\tthis._contextTshsOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasContextTshs(),\n\t\t\ts => s.contextTshs,\n\t\t\t(s, v) => s.setContextTshs(v)\n\t\t);\n\t\tthis._missingExistenceOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasMissingExistence(),\n\t\t\ts => s.missingExistence,\n\t\t\t(s, v) => s.setMissingExistence(v),\n\t\t\tfalse\n\t\t);\n\t\tthis._managedItemInfoOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasManagedItemInfo(),\n\t\t\ts => s.managedItemInfo,\n\t\t\t(s, v) => s.setManagedItemInfo(v),\n\t\t\tfalse\n\t\t);\n\t\tthis._managedFilesOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasManagedFiles(),\n\t\t\ts => s.managedFiles,\n\t\t\t(s, v) => s.setManagedFiles(v),\n\t\t\tfalse,\n\t\t\ttrue\n\t\t);\n\t\tthis._managedContextsOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasManagedContexts(),\n\t\t\ts => s.managedContexts,\n\t\t\t(s, v) => s.setManagedContexts(v),\n\t\t\tfalse,\n\t\t\ttrue\n\t\t);\n\t\tthis._managedMissingOptimization = new SnapshotOptimization(\n\t\t\ts => s.hasManagedMissing(),\n\t\t\ts => s.managedMissing,\n\t\t\t(s, v) => s.setManagedMissing(v),\n\t\t\tfalse,\n\t\t\ttrue\n\t\t);\n\t\t/** @type {StackedCacheMap<string, FileSystemInfoEntry | \"ignore\" | null>} */\n\t\tthis._fileTimestamps = new StackedCacheMap();\n\t\t/** @type {Map<string, string | null>} */\n\t\tthis._fileHashes = new Map();\n\t\t/** @type {Map<string, TimestampAndHash | string>} */\n\t\tthis._fileTshs = new Map();\n\t\t/** @type {StackedCacheMap<string, ContextFileSystemInfoEntry | \"ignore\" | null>} */\n\t\tthis._contextTimestamps = new StackedCacheMap();\n\t\t/** @type {Map<string, ContextHash>} */\n\t\tthis._contextHashes = new Map();\n\t\t/** @type {Map<string, ContextTimestampAndHash>} */\n\t\tthis._contextTshs = new Map();\n\t\t/** @type {Map<string, string>} */\n\t\tthis._managedItems = new Map();\n\t\t/** @type {AsyncQueue<string, string, FileSystemInfoEntry>} */\n\t\tthis.fileTimestampQueue = new AsyncQueue({\n\t\t\tname: \"file timestamp\",\n\t\t\tparallelism: 30,\n\t\t\tprocessor: this._readFileTimestamp.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, string>} */\n\t\tthis.fileHashQueue = new AsyncQueue({\n\t\t\tname: \"file hash\",\n\t\t\tparallelism: 10,\n\t\t\tprocessor: this._readFileHash.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, ContextFileSystemInfoEntry>} */\n\t\tthis.contextTimestampQueue = new AsyncQueue({\n\t\t\tname: \"context timestamp\",\n\t\t\tparallelism: 2,\n\t\t\tprocessor: this._readContextTimestamp.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, ContextHash>} */\n\t\tthis.contextHashQueue = new AsyncQueue({\n\t\t\tname: \"context hash\",\n\t\t\tparallelism: 2,\n\t\t\tprocessor: this._readContextHash.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, ContextTimestampAndHash>} */\n\t\tthis.contextTshQueue = new AsyncQueue({\n\t\t\tname: \"context hash and timestamp\",\n\t\t\tparallelism: 2,\n\t\t\tprocessor: this._readContextTimestampAndHash.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, string>} */\n\t\tthis.managedItemQueue = new AsyncQueue({\n\t\t\tname: \"managed item info\",\n\t\t\tparallelism: 10,\n\t\t\tprocessor: this._getManagedItemInfo.bind(this)\n\t\t});\n\t\t/** @type {AsyncQueue<string, string, Set<string>>} */\n\t\tthis.managedItemDirectoryQueue = new AsyncQueue({\n\t\t\tname: \"managed item directory info\",\n\t\t\tparallelism: 10,\n\t\t\tprocessor: this._getManagedItemDirectoryInfo.bind(this)\n\t\t});\n\t\tconst _unmanagedPaths = Array.from(unmanagedPaths);\n\t\tthis.unmanagedPathsWithSlash = /** @type {string[]} */ (\n\t\t\t_unmanagedPaths.filter(p => typeof p === \"string\")\n\t\t).map(p => join(fs, p, \"_\").slice(0, -1));\n\t\tthis.unmanagedPathsRegExps = /** @type {RegExp[]} */ (\n\t\t\t_unmanagedPaths.filter(p => typeof p !== \"string\")\n\t\t);\n\n\t\tthis.managedPaths = Array.from(managedPaths);\n\t\tthis.managedPathsWithSlash = /** @type {string[]} */ (\n\t\t\tthis.managedPaths.filter(p => typeof p === \"string\")\n\t\t).map(p => join(fs, p, \"_\").slice(0, -1));\n\n\t\tthis.managedPathsRegExps = /** @type {RegExp[]} */ (\n\t\t\tthis.managedPaths.filter(p => typeof p !== \"string\")\n\t\t);\n\t\tthis.immutablePaths = Array.from(immutablePaths);\n\t\tthis.immutablePathsWithSlash = /** @type {string[]} */ (\n\t\t\tthis.immutablePaths.filter(p => typeof p === \"string\")\n\t\t).map(p => join(fs, p, \"_\").slice(0, -1));\n\t\tthis.immutablePathsRegExps = /** @type {RegExp[]} */ (\n\t\t\tthis.immutablePaths.filter(p => typeof p !== \"string\")\n\t\t);\n\n\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\t\tthis._cachedDeprecatedContextTimestamps = undefined;\n\n\t\tthis._warnAboutExperimentalEsmTracking = false;\n\n\t\tthis._statCreatedSnapshots = 0;\n\t\tthis._statTestedSnapshotsCached = 0;\n\t\tthis._statTestedSnapshotsNotCached = 0;\n\t\tthis._statTestedChildrenCached = 0;\n\t\tthis._statTestedChildrenNotCached = 0;\n\t\tthis._statTestedEntries = 0;\n\t}\n\n\tlogStatistics() {\n\t\tconst logger = /** @type {Logger} */ (this.logger);\n\t\t/**\n\t\t * @param {string} header header\n\t\t * @param {string | undefined} message message\n\t\t */\n\t\tconst logWhenMessage = (header, message) => {\n\t\t\tif (message) {\n\t\t\t\tlogger.log(`${header}: ${message}`);\n\t\t\t}\n\t\t};\n\t\tlogger.log(`${this._statCreatedSnapshots} new snapshots created`);\n\t\tlogger.log(\n\t\t\t`${\n\t\t\t\tthis._statTestedSnapshotsNotCached &&\n\t\t\t\tMath.round(\n\t\t\t\t\t(this._statTestedSnapshotsNotCached * 100) /\n\t\t\t\t\t\t(this._statTestedSnapshotsCached +\n\t\t\t\t\t\t\tthis._statTestedSnapshotsNotCached)\n\t\t\t\t)\n\t\t\t}% root snapshot uncached (${this._statTestedSnapshotsNotCached} / ${\n\t\t\t\tthis._statTestedSnapshotsCached + this._statTestedSnapshotsNotCached\n\t\t\t})`\n\t\t);\n\t\tlogger.log(\n\t\t\t`${\n\t\t\t\tthis._statTestedChildrenNotCached &&\n\t\t\t\tMath.round(\n\t\t\t\t\t(this._statTestedChildrenNotCached * 100) /\n\t\t\t\t\t\t(this._statTestedChildrenCached + this._statTestedChildrenNotCached)\n\t\t\t\t)\n\t\t\t}% children snapshot uncached (${this._statTestedChildrenNotCached} / ${\n\t\t\t\tthis._statTestedChildrenCached + this._statTestedChildrenNotCached\n\t\t\t})`\n\t\t);\n\t\tlogger.log(`${this._statTestedEntries} entries tested`);\n\t\tlogger.log(\n\t\t\t`File info in cache: ${this._fileTimestamps.size} timestamps ${this._fileHashes.size} hashes ${this._fileTshs.size} timestamp hash combinations`\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t\"File timestamp snapshot optimization\",\n\t\t\tthis._fileTimestampsOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t\"File hash snapshot optimization\",\n\t\t\tthis._fileHashesOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t\"File timestamp hash combination snapshot optimization\",\n\t\t\tthis._fileTshsOptimization.getStatisticMessage()\n\t\t);\n\t\tlogger.log(\n\t\t\t`Directory info in cache: ${this._contextTimestamps.size} timestamps ${this._contextHashes.size} hashes ${this._contextTshs.size} timestamp hash combinations`\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t\"Directory timestamp snapshot optimization\",\n\t\t\tthis._contextTimestampsOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t\"Directory hash snapshot optimization\",\n\t\t\tthis._contextHashesOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t\"Directory timestamp hash combination snapshot optimization\",\n\t\t\tthis._contextTshsOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t\"Missing items snapshot optimization\",\n\t\t\tthis._missingExistenceOptimization.getStatisticMessage()\n\t\t);\n\t\tlogger.log(`Managed items info in cache: ${this._managedItems.size} items`);\n\t\tlogWhenMessage(\n\t\t\t\"Managed items snapshot optimization\",\n\t\t\tthis._managedItemInfoOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t\"Managed files snapshot optimization\",\n\t\t\tthis._managedFilesOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t\"Managed contexts snapshot optimization\",\n\t\t\tthis._managedContextsOptimization.getStatisticMessage()\n\t\t);\n\t\tlogWhenMessage(\n\t\t\t\"Managed missing snapshot optimization\",\n\t\t\tthis._managedMissingOptimization.getStatisticMessage()\n\t\t);\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @param {string} reason reason\n\t * @param {any[]} args arguments\n\t */\n\t_log(path, reason, ...args) {\n\t\tconst key = path + reason;\n\t\tconst loggedPaths = /** @type {LoggedPaths} */ (this._loggedPaths);\n\t\tif (loggedPaths.has(key)) return;\n\t\tloggedPaths.add(key);\n\t\t/** @type {Logger} */\n\t\t(this.logger).debug(`${path} invalidated because ${reason}`, ...args);\n\t\tif (--this._remainingLogs === 0) {\n\t\t\t/** @type {Logger} */\n\t\t\t(this.logger).debug(\n\t\t\t\t\"Logging limit has been reached and no further logging will be emitted by FileSystemInfo\"\n\t\t\t);\n\t\t}\n\t}\n\n\tclear() {\n\t\tthis._remainingLogs = this.logger ? 40 : 0;\n\t\tif (this._loggedPaths !== undefined) this._loggedPaths.clear();\n\n\t\tthis._snapshotCache = new WeakMap();\n\t\tthis._fileTimestampsOptimization.clear();\n\t\tthis._fileHashesOptimization.clear();\n\t\tthis._fileTshsOptimization.clear();\n\t\tthis._contextTimestampsOptimization.clear();\n\t\tthis._contextHashesOptimization.clear();\n\t\tthis._contextTshsOptimization.clear();\n\t\tthis._missingExistenceOptimization.clear();\n\t\tthis._managedItemInfoOptimization.clear();\n\t\tthis._managedFilesOptimization.clear();\n\t\tthis._managedContextsOptimization.clear();\n\t\tthis._managedMissingOptimization.clear();\n\t\tthis._fileTimestamps.clear();\n\t\tthis._fileHashes.clear();\n\t\tthis._fileTshs.clear();\n\t\tthis._contextTimestamps.clear();\n\t\tthis._contextHashes.clear();\n\t\tthis._contextTshs.clear();\n\t\tthis._managedItems.clear();\n\t\tthis._managedItems.clear();\n\n\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\t\tthis._cachedDeprecatedContextTimestamps = undefined;\n\n\t\tthis._statCreatedSnapshots = 0;\n\t\tthis._statTestedSnapshotsCached = 0;\n\t\tthis._statTestedSnapshotsNotCached = 0;\n\t\tthis._statTestedChildrenCached = 0;\n\t\tthis._statTestedChildrenNotCached = 0;\n\t\tthis._statTestedEntries = 0;\n\t}\n\n\t/**\n\t * @param {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} map timestamps\n\t * @param {boolean=} immutable if 'map' is immutable and FileSystemInfo can keep referencing it\n\t * @returns {void}\n\t */\n\taddFileTimestamps(map, immutable) {\n\t\tthis._fileTimestamps.addAll(map, immutable);\n\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\t}\n\n\t/**\n\t * @param {ReadonlyMap<string, FileSystemInfoEntry | \"ignore\" | null>} map timestamps\n\t * @param {boolean=} immutable if 'map' is immutable and FileSystemInfo can keep referencing it\n\t * @returns {void}\n\t */\n\taddContextTimestamps(map, immutable) {\n\t\tthis._contextTimestamps.addAll(map, immutable);\n\t\tthis._cachedDeprecatedContextTimestamps = undefined;\n\t}\n\n\t/**\n\t * @param {string} path file path\n\t * @param {function((WebpackError | null)=, (FileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n\t * @returns {void}\n\t */\n\tgetFileTimestamp(path, callback) {\n\t\tconst cache = this._fileTimestamps.get(path);\n\t\tif (cache !== undefined) return callback(null, cache);\n\t\tthis.fileTimestampQueue.add(path, callback);\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, (ResolvedContextFileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n\t * @returns {void}\n\t */\n\tgetContextTimestamp(path, callback) {\n\t\tconst cache = this._contextTimestamps.get(path);\n\t\tif (cache !== undefined) {\n\t\t\tif (cache === \"ignore\") return callback(null, \"ignore\");\n\t\t\tconst resolved = getResolvedTimestamp(cache);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\treturn this._resolveContextTimestamp(\n\t\t\t\t/** @type {ResolvedContextFileSystemInfoEntry} */\n\t\t\t\t(cache),\n\t\t\t\tcallback\n\t\t\t);\n\t\t}\n\t\tthis.contextTimestampQueue.add(path, (err, _entry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tconst entry = /** @type {ContextFileSystemInfoEntry} */ (_entry);\n\t\t\tconst resolved = getResolvedTimestamp(entry);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\tthis._resolveContextTimestamp(entry, callback);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, (ContextFileSystemInfoEntry | \"ignore\" | null)=): void} callback callback function\n\t * @returns {void}\n\t */\n\t_getUnresolvedContextTimestamp(path, callback) {\n\t\tconst cache = this._contextTimestamps.get(path);\n\t\tif (cache !== undefined) return callback(null, cache);\n\t\tthis.contextTimestampQueue.add(path, callback);\n\t}\n\n\t/**\n\t * @param {string} path file path\n\t * @param {function((WebpackError | null)=, (string | null)=): void} callback callback function\n\t * @returns {void}\n\t */\n\tgetFileHash(path, callback) {\n\t\tconst cache = this._fileHashes.get(path);\n\t\tif (cache !== undefined) return callback(null, cache);\n\t\tthis.fileHashQueue.add(path, callback);\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, string=): void} callback callback function\n\t * @returns {void}\n\t */\n\tgetContextHash(path, callback) {\n\t\tconst cache = this._contextHashes.get(path);\n\t\tif (cache !== undefined) {\n\t\t\tconst resolved = getResolvedHash(cache);\n\t\t\tif (resolved !== undefined)\n\t\t\t\treturn callback(null, /** @type {string} */ (resolved));\n\t\t\treturn this._resolveContextHash(cache, callback);\n\t\t}\n\t\tthis.contextHashQueue.add(path, (err, _entry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tconst entry = /** @type {ContextHash} */ (_entry);\n\t\t\tconst resolved = getResolvedHash(entry);\n\t\t\tif (resolved !== undefined)\n\t\t\t\treturn callback(null, /** @type {string} */ (resolved));\n\t\t\tthis._resolveContextHash(entry, callback);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, (ContextHash | null)=): void} callback callback function\n\t * @returns {void}\n\t */\n\t_getUnresolvedContextHash(path, callback) {\n\t\tconst cache = this._contextHashes.get(path);\n\t\tif (cache !== undefined) return callback(null, cache);\n\t\tthis.contextHashQueue.add(path, callback);\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, (ResolvedContextTimestampAndHash | null)=): void} callback callback function\n\t * @returns {void}\n\t */\n\tgetContextTsh(path, callback) {\n\t\tconst cache = this._contextTshs.get(path);\n\t\tif (cache !== undefined) {\n\t\t\tconst resolved = getResolvedTimestamp(cache);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\treturn this._resolveContextTsh(cache, callback);\n\t\t}\n\t\tthis.contextTshQueue.add(path, (err, _entry) => {\n\t\t\tif (err) return callback(err);\n\t\t\tconst entry = /** @type {ContextTimestampAndHash} */ (_entry);\n\t\t\tconst resolved = getResolvedTimestamp(entry);\n\t\t\tif (resolved !== undefined) return callback(null, resolved);\n\t\t\tthis._resolveContextTsh(entry, callback);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} path context path\n\t * @param {function((WebpackError | null)=, (ContextTimestampAndHash | null)=): void} callback callback function\n\t * @returns {void}\n\t */\n\t_getUnresolvedContextTsh(path, callback) {\n\t\tconst cache = this._contextTshs.get(path);\n\t\tif (cache !== undefined) return callback(null, cache);\n\t\tthis.contextTshQueue.add(path, callback);\n\t}\n\n\t_createBuildDependenciesResolvers() {\n\t\tconst resolveContext = createResolver({\n\t\t\tresolveToContext: true,\n\t\t\texportsFields: [],\n\t\t\tfileSystem: this.fs\n\t\t});\n\t\tconst resolveCjs = createResolver({\n\t\t\textensions: [\".js\", \".json\", \".node\"],\n\t\t\tconditionNames: [\"require\", \"node\"],\n\t\t\texportsFields: [\"exports\"],\n\t\t\tfileSystem: this.fs\n\t\t});\n\t\tconst resolveCjsAsChild = createResolver({\n\t\t\textensions: [\".js\", \".json\", \".node\"],\n\t\t\tconditionNames: [\"require\", \"node\"],\n\t\t\texportsFields: [],\n\t\t\tfileSystem: this.fs\n\t\t});\n\t\tconst resolveEsm = createResolver({\n\t\t\textensions: [\".js\", \".json\", \".node\"],\n\t\t\tfullySpecified: true,\n\t\t\tconditionNames: [\"import\", \"node\"],\n\t\t\texportsFields: [\"exports\"],\n\t\t\tfileSystem: this.fs\n\t\t});\n\t\treturn { resolveContext, resolveEsm, resolveCjs, resolveCjsAsChild };\n\t}\n\n\t/**\n\t * @param {string} context context directory\n\t * @param {Iterable<string>} deps dependencies\n\t * @param {function((Error | null)=, ResolveBuildDependenciesResult=): void} callback callback function\n\t * @returns {void}\n\t */\n\tresolveBuildDependencies(context, deps, callback) {\n\t\tconst { resolveContext, resolveEsm, resolveCjs, resolveCjsAsChild } =\n\t\t\tthis._createBuildDependenciesResolvers();\n\n\t\t/** @type {Set<string>} */\n\t\tconst files = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst fileSymlinks = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst directories = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst directorySymlinks = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst missing = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst resolveFiles = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst resolveDirectories = new Set();\n\t\t/** @type {Set<string>} */\n\t\tconst resolveMissing = new Set();\n\t\t/** @type {Map<string, string | false | undefined>} */\n\t\tconst resolveResults = new Map();\n\t\tconst invalidResolveResults = new Set();\n\t\tconst resolverContext = {\n\t\t\tfileDependencies: resolveFiles,\n\t\t\tcontextDependencies: resolveDirectories,\n\t\t\tmissingDependencies: resolveMissing\n\t\t};\n\t\t/**\n\t\t * @param {undefined | boolean | string} expected expected result\n\t\t * @returns {string} expected result\n\t\t */\n\t\tconst expectedToString = expected =>\n\t\t\texpected ? ` (expected ${expected})` : \"\";\n\t\t/** @typedef {{ type: JobType, context: string | undefined, path: string, issuer: Job | undefined, expected: undefined | boolean | string }} Job */\n\n\t\t/**\n\t\t * @param {Job} job job\n\t\t * @returns {`resolve commonjs file ${string}${string}`|`resolve esm file ${string}${string}`|`resolve esm ${string}${string}`|`resolve directory ${string}`|`file ${string}`|`unknown ${string} ${string}`|`resolve commonjs ${string}${string}`|`directory ${string}`|`file dependencies ${string}`|`directory dependencies ${string}`} result\n\t\t */\n\t\tconst jobToString = job => {\n\t\t\tswitch (job.type) {\n\t\t\t\tcase RBDT_RESOLVE_CJS:\n\t\t\t\t\treturn `resolve commonjs ${job.path}${expectedToString(\n\t\t\t\t\t\tjob.expected\n\t\t\t\t\t)}`;\n\t\t\t\tcase RBDT_RESOLVE_ESM:\n\t\t\t\t\treturn `resolve esm ${job.path}${expectedToString(job.expected)}`;\n\t\t\t\tcase RBDT_RESOLVE_DIRECTORY:\n\t\t\t\t\treturn `resolve directory ${job.path}`;\n\t\t\t\tcase RBDT_RESOLVE_CJS_FILE:\n\t\t\t\t\treturn `resolve commonjs file ${job.path}${expectedToString(\n\t\t\t\t\t\tjob.expected\n\t\t\t\t\t)}`;\n\t\t\t\tcase RBDT_RESOLVE_ESM_FILE:\n\t\t\t\t\treturn `resolve esm file ${job.path}${expectedToString(\n\t\t\t\t\t\tjob.expected\n\t\t\t\t\t)}`;\n\t\t\t\tcase RBDT_DIRECTORY:\n\t\t\t\t\treturn `directory ${job.path}`;\n\t\t\t\tcase RBDT_FILE:\n\t\t\t\t\treturn `file ${job.path}`;\n\t\t\t\tcase RBDT_DIRECTORY_DEPENDENCIES:\n\t\t\t\t\treturn `directory dependencies ${job.path}`;\n\t\t\t\tcase RBDT_FILE_DEPENDENCIES:\n\t\t\t\t\treturn `file dependencies ${job.path}`;\n\t\t\t}\n\t\t\treturn `unknown ${job.type} ${job.path}`;\n\t\t};\n\t\t/**\n\t\t * @param {Job} job job\n\t\t * @returns {string} string value\n\t\t */\n\t\tconst pathToString = job => {\n\t\t\tlet result = ` at ${jobToString(job)}`;\n\t\t\t/** @type {Job | undefined} */\n\t\t\t(job) = job.issuer;\n\t\t\twhile (job !== undefined) {\n\t\t\t\tresult += `\\n at ${jobToString(job)}`;\n\t\t\t\tjob = /** @type {Job} */ (job.issuer);\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t\tconst logger = /** @type {Logger} */ (this.logger);\n\t\tprocessAsyncTree(\n\t\t\tArray.from(\n\t\t\t\tdeps,\n\t\t\t\tdep =>\n\t\t\t\t\t/** @type {Job} */ ({\n\t\t\t\t\t\ttype: RBDT_RESOLVE_CJS,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tpath: dep,\n\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\tissuer: undefined\n\t\t\t\t\t})\n\t\t\t),\n\t\t\t20,\n\t\t\t(job, push, callback) => {\n\t\t\t\tconst { type, context, path, expected } = job;\n\t\t\t\t/**\n\t\t\t\t * @param {string} path path\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst resolveDirectory = path => {\n\t\t\t\t\tconst key = `d\\n${context}\\n${path}`;\n\t\t\t\t\tif (resolveResults.has(key)) {\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t}\n\t\t\t\t\tresolveResults.set(key, undefined);\n\t\t\t\t\tresolveContext(\n\t\t\t\t\t\t/** @type {string} */ (context),\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tresolverContext,\n\t\t\t\t\t\t(err, _, result) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tif (expected === false) {\n\t\t\t\t\t\t\t\t\tresolveResults.set(key, false);\n\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tinvalidResolveResults.add(key);\n\t\t\t\t\t\t\t\terr.message += `\\nwhile resolving '${path}' in ${context} to a directory`;\n\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst resultPath = /** @type {ResolveRequest} */ (result).path;\n\t\t\t\t\t\t\tresolveResults.set(key, resultPath);\n\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\ttype: RBDT_DIRECTORY,\n\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\tpath: /** @type {string} */ (resultPath),\n\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t};\n\t\t\t\t/**\n\t\t\t\t * @param {string} path path\n\t\t\t\t * @param {(\"f\" | \"c\" | \"e\")=} symbol symbol\n\t\t\t\t * @param {(ResolveFunctionAsync)=} resolve resolve fn\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst resolveFile = (path, symbol, resolve) => {\n\t\t\t\t\tconst key = `${symbol}\\n${context}\\n${path}`;\n\t\t\t\t\tif (resolveResults.has(key)) {\n\t\t\t\t\t\treturn callback();\n\t\t\t\t\t}\n\t\t\t\t\tresolveResults.set(key, undefined);\n\t\t\t\t\t/** @type {ResolveFunctionAsync} */\n\t\t\t\t\t(resolve)(\n\t\t\t\t\t\t/** @type {string} */ (context),\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tresolverContext,\n\t\t\t\t\t\t(err, _, result) => {\n\t\t\t\t\t\t\tif (typeof expected === \"string\") {\n\t\t\t\t\t\t\t\tif (!err && result && result.path === expected) {\n\t\t\t\t\t\t\t\t\tresolveResults.set(key, result.path);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tinvalidResolveResults.add(key);\n\t\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t\t`Resolving '${path}' in ${context} for build dependencies doesn't lead to expected result '${expected}', but to '${\n\t\t\t\t\t\t\t\t\t\t\terr || (result && result.path)\n\t\t\t\t\t\t\t\t\t\t}' instead. Resolving dependencies are ignored for this path.\\n${pathToString(\n\t\t\t\t\t\t\t\t\t\t\tjob\n\t\t\t\t\t\t\t\t\t\t)}`\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (expected === false) {\n\t\t\t\t\t\t\t\t\t\tresolveResults.set(key, false);\n\t\t\t\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tinvalidResolveResults.add(key);\n\t\t\t\t\t\t\t\t\terr.message += `\\nwhile resolving '${path}' in ${context} as file\\n${pathToString(\n\t\t\t\t\t\t\t\t\t\tjob\n\t\t\t\t\t\t\t\t\t)}`;\n\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst resultPath = /** @type {ResolveRequest} */ (result).path;\n\t\t\t\t\t\t\t\tresolveResults.set(key, resultPath);\n\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\ttype: RBDT_FILE,\n\t\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\t\tpath: /** @type {string} */ (resultPath),\n\t\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t};\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase RBDT_RESOLVE_CJS: {\n\t\t\t\t\t\tconst isDirectory = /[\\\\/]$/.test(path);\n\t\t\t\t\t\tif (isDirectory) {\n\t\t\t\t\t\t\tresolveDirectory(path.slice(0, -1));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolveFile(path, \"f\", resolveCjs);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_RESOLVE_ESM: {\n\t\t\t\t\t\tconst isDirectory = /[\\\\/]$/.test(path);\n\t\t\t\t\t\tif (isDirectory) {\n\t\t\t\t\t\t\tresolveDirectory(path.slice(0, -1));\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolveFile(path);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_RESOLVE_DIRECTORY: {\n\t\t\t\t\t\tresolveDirectory(path);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_RESOLVE_CJS_FILE: {\n\t\t\t\t\t\tresolveFile(path, \"f\", resolveCjs);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_RESOLVE_CJS_FILE_AS_CHILD: {\n\t\t\t\t\t\tresolveFile(path, \"c\", resolveCjsAsChild);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_RESOLVE_ESM_FILE: {\n\t\t\t\t\t\tresolveFile(path, \"e\", resolveEsm);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_FILE: {\n\t\t\t\t\t\tif (files.has(path)) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfiles.add(path);\n\t\t\t\t\t\t/** @type {NonNullable<InputFileSystem[\"realpath\"]>} */\n\t\t\t\t\t\t(this.fs.realpath)(path, (err, _realPath) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst realPath = /** @type {string} */ (_realPath);\n\t\t\t\t\t\t\tif (realPath !== path) {\n\t\t\t\t\t\t\t\tfileSymlinks.add(path);\n\t\t\t\t\t\t\t\tresolveFiles.add(path);\n\t\t\t\t\t\t\t\tif (files.has(realPath)) return callback();\n\t\t\t\t\t\t\t\tfiles.add(realPath);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\ttype: RBDT_FILE_DEPENDENCIES,\n\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\tpath: realPath,\n\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_DIRECTORY: {\n\t\t\t\t\t\tif (directories.has(path)) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdirectories.add(path);\n\t\t\t\t\t\t/** @type {NonNullable<InputFileSystem[\"realpath\"]>} */\n\t\t\t\t\t\t(this.fs.realpath)(path, (err, _realPath) => {\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst realPath = /** @type {string} */ (_realPath);\n\t\t\t\t\t\t\tif (realPath !== path) {\n\t\t\t\t\t\t\t\tdirectorySymlinks.add(path);\n\t\t\t\t\t\t\t\tresolveFiles.add(path);\n\t\t\t\t\t\t\t\tif (directories.has(realPath)) return callback();\n\t\t\t\t\t\t\t\tdirectories.add(realPath);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\ttype: RBDT_DIRECTORY_DEPENDENCIES,\n\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\tpath: realPath,\n\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_FILE_DEPENDENCIES: {\n\t\t\t\t\t\t// Check for known files without dependencies\n\t\t\t\t\t\tif (/\\.json5?$|\\.yarn-integrity$|yarn\\.lock$|\\.ya?ml/.test(path)) {\n\t\t\t\t\t\t\tprocess.nextTick(callback);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Check commonjs cache for the module\n\t\t\t\t\t\t/** @type {NodeModule | undefined} */\n\t\t\t\t\t\tconst module = require.cache[path];\n\t\t\t\t\t\tif (module && Array.isArray(module.children)) {\n\t\t\t\t\t\t\tchildren: for (const child of module.children) {\n\t\t\t\t\t\t\t\tconst childPath = child.filename;\n\t\t\t\t\t\t\t\tif (childPath) {\n\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\ttype: RBDT_FILE,\n\t\t\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\t\t\tpath: childPath,\n\t\t\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tconst context = dirname(this.fs, path);\n\t\t\t\t\t\t\t\t\tfor (const modulePath of module.paths) {\n\t\t\t\t\t\t\t\t\t\tif (childPath.startsWith(modulePath)) {\n\t\t\t\t\t\t\t\t\t\t\tconst subPath = childPath.slice(modulePath.length + 1);\n\t\t\t\t\t\t\t\t\t\t\tconst packageMatch = /^(@[^\\\\/]+[\\\\/])[^\\\\/]+/.exec(\n\t\t\t\t\t\t\t\t\t\t\t\tsubPath\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tif (packageMatch) {\n\t\t\t\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: RBDT_FILE,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\t\t\t\t\t\tpath: `${\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodulePath +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchildPath[modulePath.length] +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpackageMatch[0] +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tchildPath[modulePath.length]\n\t\t\t\t\t\t\t\t\t\t\t\t\t}package.json`,\n\t\t\t\t\t\t\t\t\t\t\t\t\texpected: false,\n\t\t\t\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\tlet request = subPath.replace(/\\\\/g, \"/\");\n\t\t\t\t\t\t\t\t\t\t\tif (request.endsWith(\".js\"))\n\t\t\t\t\t\t\t\t\t\t\t\trequest = request.slice(0, -3);\n\t\t\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: RBDT_RESOLVE_CJS_FILE_AS_CHILD,\n\t\t\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\t\t\tpath: request,\n\t\t\t\t\t\t\t\t\t\t\t\texpected: child.filename,\n\t\t\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\tcontinue children;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet request = relative(this.fs, context, childPath);\n\t\t\t\t\t\t\t\t\tif (request.endsWith(\".js\")) request = request.slice(0, -3);\n\t\t\t\t\t\t\t\t\trequest = request.replace(/\\\\/g, \"/\");\n\t\t\t\t\t\t\t\t\tif (!request.startsWith(\"../\") && !isAbsolute(request)) {\n\t\t\t\t\t\t\t\t\t\trequest = `./${request}`;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\ttype: RBDT_RESOLVE_CJS_FILE,\n\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\tpath: request,\n\t\t\t\t\t\t\t\t\t\texpected: child.filename,\n\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (supportsEsm && /\\.m?js$/.test(path)) {\n\t\t\t\t\t\t\tif (!this._warnAboutExperimentalEsmTracking) {\n\t\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t\t\"Node.js doesn't offer a (nice) way to introspect the ESM dependency graph yet.\\n\" +\n\t\t\t\t\t\t\t\t\t\t\"Until a full solution is available webpack uses an experimental ESM tracking based on parsing.\\n\" +\n\t\t\t\t\t\t\t\t\t\t\"As best effort webpack parses the ESM files to guess dependencies. But this can lead to expensive and incorrect tracking.\"\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis._warnAboutExperimentalEsmTracking = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst lexer = require(\"es-module-lexer\");\n\t\t\t\t\t\t\tlexer.init.then(() => {\n\t\t\t\t\t\t\t\tthis.fs.readFile(path, (err, content) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tconst context = dirname(this.fs, path);\n\t\t\t\t\t\t\t\t\t\tconst source = /** @type {Buffer} */ (content).toString();\n\t\t\t\t\t\t\t\t\t\tconst [imports] = lexer.parse(source);\n\t\t\t\t\t\t\t\t\t\tfor (const imp of imports) {\n\t\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\t\tlet dependency;\n\t\t\t\t\t\t\t\t\t\t\t\tif (imp.d === -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// import ... from \"...\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tdependency = parseString(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsource.substring(imp.s - 1, imp.e + 1)\n\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t} else if (imp.d > -1) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// import()\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst expr = source.substring(imp.s, imp.e).trim();\n\t\t\t\t\t\t\t\t\t\t\t\t\tdependency = parseString(expr);\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// e.g. import.meta\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// we should not track Node.js build dependencies\n\t\t\t\t\t\t\t\t\t\t\t\tif (dependency.startsWith(\"node:\")) continue;\n\t\t\t\t\t\t\t\t\t\t\t\tif (builtinModules.has(dependency)) continue;\n\n\t\t\t\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\t\t\t\ttype: RBDT_RESOLVE_ESM_FILE,\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\t\t\t\t\t\t\tpath: dependency,\n\t\t\t\t\t\t\t\t\t\t\t\t\texpected: imp.d > -1 ? false : undefined,\n\t\t\t\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t} catch (err1) {\n\t\t\t\t\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t`Parsing of ${path} for build dependencies failed at 'import(${source.substring(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\timp.s,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\timp.e\n\t\t\t\t\t\t\t\t\t\t\t\t\t)})'.\\n` +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\"Build dependencies behind this expression are ignored and might cause incorrect cache invalidation.\"\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\tlogger.debug(pathToString(job));\n\t\t\t\t\t\t\t\t\t\t\t\tlogger.debug(/** @type {Error} */ (err1).stack);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} catch (err2) {\n\t\t\t\t\t\t\t\t\t\tlogger.warn(\n\t\t\t\t\t\t\t\t\t\t\t`Parsing of ${path} for build dependencies failed and all dependencies of this file are ignored, which might cause incorrect cache invalidation..`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\tlogger.debug(pathToString(job));\n\t\t\t\t\t\t\t\t\t\tlogger.debug(/** @type {Error} */ (err2).stack);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tprocess.nextTick(callback);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}, callback);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.log(\n\t\t\t\t\t\t\t\t`Assuming ${path} has no dependencies as we were unable to assign it to any module system.`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tlogger.debug(pathToString(job));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprocess.nextTick(callback);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase RBDT_DIRECTORY_DEPENDENCIES: {\n\t\t\t\t\t\tconst match =\n\t\t\t\t\t\t\t/(^.+[\\\\/]node_modules[\\\\/](?:@[^\\\\/]+[\\\\/])?[^\\\\/]+)/.exec(path);\n\t\t\t\t\t\tconst packagePath = match ? match[1] : path;\n\t\t\t\t\t\tconst packageJson = join(this.fs, packagePath, \"package.json\");\n\t\t\t\t\t\tthis.fs.readFile(packageJson, (err, content) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\t\t\t\t\tresolveMissing.add(packageJson);\n\t\t\t\t\t\t\t\t\tconst parent = dirname(this.fs, packagePath);\n\t\t\t\t\t\t\t\t\tif (parent !== packagePath) {\n\t\t\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\t\t\ttype: RBDT_DIRECTORY_DEPENDENCIES,\n\t\t\t\t\t\t\t\t\t\t\tcontext: undefined,\n\t\t\t\t\t\t\t\t\t\t\tpath: parent,\n\t\t\t\t\t\t\t\t\t\t\texpected: undefined,\n\t\t\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tresolveFiles.add(packageJson);\n\t\t\t\t\t\t\tlet packageData;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tpackageData = JSON.parse(\n\t\t\t\t\t\t\t\t\t/** @type {Buffer} */ (content).toString(\"utf-8\")\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} catch (parseErr) {\n\t\t\t\t\t\t\t\treturn callback(/** @type {Error} */ (parseErr));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tconst depsObject = packageData.dependencies;\n\t\t\t\t\t\t\tconst optionalDepsObject = packageData.optionalDependencies;\n\t\t\t\t\t\t\tconst allDeps = new Set();\n\t\t\t\t\t\t\tconst optionalDeps = new Set();\n\t\t\t\t\t\t\tif (typeof depsObject === \"object\" && depsObject) {\n\t\t\t\t\t\t\t\tfor (const dep of Object.keys(depsObject)) {\n\t\t\t\t\t\t\t\t\tallDeps.add(dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\ttypeof optionalDepsObject === \"object\" &&\n\t\t\t\t\t\t\t\toptionalDepsObject\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tfor (const dep of Object.keys(optionalDepsObject)) {\n\t\t\t\t\t\t\t\t\tallDeps.add(dep);\n\t\t\t\t\t\t\t\t\toptionalDeps.add(dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (const dep of allDeps) {\n\t\t\t\t\t\t\t\tpush({\n\t\t\t\t\t\t\t\t\ttype: RBDT_RESOLVE_DIRECTORY,\n\t\t\t\t\t\t\t\t\tcontext: packagePath,\n\t\t\t\t\t\t\t\t\tpath: dep,\n\t\t\t\t\t\t\t\t\texpected: !optionalDeps.has(dep),\n\t\t\t\t\t\t\t\t\tissuer: job\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tfor (const l of fileSymlinks) files.delete(l);\n\t\t\t\tfor (const l of directorySymlinks) directories.delete(l);\n\t\t\t\tfor (const k of invalidResolveResults) resolveResults.delete(k);\n\t\t\t\tcallback(null, {\n\t\t\t\t\tfiles,\n\t\t\t\t\tdirectories,\n\t\t\t\t\tmissing,\n\t\t\t\t\tresolveResults,\n\t\t\t\t\tresolveDependencies: {\n\t\t\t\t\t\tfiles: resolveFiles,\n\t\t\t\t\t\tdirectories: resolveDirectories,\n\t\t\t\t\t\tmissing: resolveMissing\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {Map<string, string | false>} resolveResults results from resolving\n\t * @param {function((Error | null)=, boolean=): void} callback callback with true when resolveResults resolve the same way\n\t * @returns {void}\n\t */\n\tcheckResolveResultsValid(resolveResults, callback) {\n\t\tconst { resolveCjs, resolveCjsAsChild, resolveEsm, resolveContext } =\n\t\t\tthis._createBuildDependenciesResolvers();\n\t\tasyncLib.eachLimit(\n\t\t\tresolveResults,\n\t\t\t20,\n\t\t\t([key, expectedResult], callback) => {\n\t\t\t\tconst [type, context, path] = key.split(\"\\n\");\n\t\t\t\tswitch (type) {\n\t\t\t\t\tcase \"d\":\n\t\t\t\t\t\tresolveContext(context, path, {}, (err, _, result) => {\n\t\t\t\t\t\t\tif (expectedResult === false)\n\t\t\t\t\t\t\t\treturn callback(err ? undefined : INVALID);\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resultPath = /** @type {ResolveRequest} */ (result).path;\n\t\t\t\t\t\t\tif (resultPath !== expectedResult) return callback(INVALID);\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"f\":\n\t\t\t\t\t\tresolveCjs(context, path, {}, (err, _, result) => {\n\t\t\t\t\t\t\tif (expectedResult === false)\n\t\t\t\t\t\t\t\treturn callback(err ? undefined : INVALID);\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resultPath = /** @type {ResolveRequest} */ (result).path;\n\t\t\t\t\t\t\tif (resultPath !== expectedResult) return callback(INVALID);\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"c\":\n\t\t\t\t\t\tresolveCjsAsChild(context, path, {}, (err, _, result) => {\n\t\t\t\t\t\t\tif (expectedResult === false)\n\t\t\t\t\t\t\t\treturn callback(err ? undefined : INVALID);\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resultPath = /** @type {ResolveRequest} */ (result).path;\n\t\t\t\t\t\t\tif (resultPath !== expectedResult) return callback(INVALID);\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"e\":\n\t\t\t\t\t\tresolveEsm(context, path, {}, (err, _, result) => {\n\t\t\t\t\t\t\tif (expectedResult === false)\n\t\t\t\t\t\t\t\treturn callback(err ? undefined : INVALID);\n\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\tconst resultPath = /** @type {ResolveRequest} */ (result).path;\n\t\t\t\t\t\t\tif (resultPath !== expectedResult) return callback(INVALID);\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcallback(new Error(\"Unexpected type in resolve result key\"));\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t},\n\t\t\t/**\n\t\t\t * @param {Error | typeof INVALID=} err error or invalid flag\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\terr => {\n\t\t\t\tif (err === INVALID) {\n\t\t\t\t\treturn callback(null, false);\n\t\t\t\t}\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\treturn callback(null, true);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {number | null | undefined} startTime when processing the files has started\n\t * @param {Iterable<string> | null} files all files\n\t * @param {Iterable<string> | null} directories all directories\n\t * @param {Iterable<string> | null} missing all missing files or directories\n\t * @param {SnapshotOptions | null | undefined} options options object (for future extensions)\n\t * @param {function(WebpackError | null, Snapshot | null): void} callback callback function\n\t * @returns {void}\n\t */\n\tcreateSnapshot(startTime, files, directories, missing, options, callback) {\n\t\t/** @type {FileTimestamps} */\n\t\tconst fileTimestamps = new Map();\n\t\t/** @type {FileHashes} */\n\t\tconst fileHashes = new Map();\n\t\t/** @type {FileTshs} */\n\t\tconst fileTshs = new Map();\n\t\t/** @type {ContextTimestamps} */\n\t\tconst contextTimestamps = new Map();\n\t\t/** @type {ContextHashes} */\n\t\tconst contextHashes = new Map();\n\t\t/** @type {ContextTshs} */\n\t\tconst contextTshs = new Map();\n\t\t/** @type {MissingExistence} */\n\t\tconst missingExistence = new Map();\n\t\t/** @type {ManagedItemInfo} */\n\t\tconst managedItemInfo = new Map();\n\t\t/** @type {ManagedFiles} */\n\t\tconst managedFiles = new Set();\n\t\t/** @type {ManagedContexts} */\n\t\tconst managedContexts = new Set();\n\t\t/** @type {ManagedMissing} */\n\t\tconst managedMissing = new Set();\n\t\t/** @type {Children} */\n\t\tconst children = new Set();\n\n\t\tconst snapshot = new Snapshot();\n\t\tif (startTime) snapshot.setStartTime(startTime);\n\n\t\t/** @type {Set<string>} */\n\t\tconst managedItems = new Set();\n\n\t\t/** 1 = timestamp, 2 = hash, 3 = timestamp + hash */\n\t\tconst mode = options && options.hash ? (options.timestamp ? 3 : 2) : 1;\n\n\t\tlet jobs = 1;\n\t\tconst jobDone = () => {\n\t\t\tif (--jobs === 0) {\n\t\t\t\tif (fileTimestamps.size !== 0) {\n\t\t\t\t\tsnapshot.setFileTimestamps(fileTimestamps);\n\t\t\t\t}\n\t\t\t\tif (fileHashes.size !== 0) {\n\t\t\t\t\tsnapshot.setFileHashes(fileHashes);\n\t\t\t\t}\n\t\t\t\tif (fileTshs.size !== 0) {\n\t\t\t\t\tsnapshot.setFileTshs(fileTshs);\n\t\t\t\t}\n\t\t\t\tif (contextTimestamps.size !== 0) {\n\t\t\t\t\tsnapshot.setContextTimestamps(contextTimestamps);\n\t\t\t\t}\n\t\t\t\tif (contextHashes.size !== 0) {\n\t\t\t\t\tsnapshot.setContextHashes(contextHashes);\n\t\t\t\t}\n\t\t\t\tif (contextTshs.size !== 0) {\n\t\t\t\t\tsnapshot.setContextTshs(contextTshs);\n\t\t\t\t}\n\t\t\t\tif (missingExistence.size !== 0) {\n\t\t\t\t\tsnapshot.setMissingExistence(missingExistence);\n\t\t\t\t}\n\t\t\t\tif (managedItemInfo.size !== 0) {\n\t\t\t\t\tsnapshot.setManagedItemInfo(managedItemInfo);\n\t\t\t\t}\n\t\t\t\tthis._managedFilesOptimization.optimize(snapshot, managedFiles);\n\t\t\t\tif (managedFiles.size !== 0) {\n\t\t\t\t\tsnapshot.setManagedFiles(managedFiles);\n\t\t\t\t}\n\t\t\t\tthis._managedContextsOptimization.optimize(snapshot, managedContexts);\n\t\t\t\tif (managedContexts.size !== 0) {\n\t\t\t\t\tsnapshot.setManagedContexts(managedContexts);\n\t\t\t\t}\n\t\t\t\tthis._managedMissingOptimization.optimize(snapshot, managedMissing);\n\t\t\t\tif (managedMissing.size !== 0) {\n\t\t\t\t\tsnapshot.setManagedMissing(managedMissing);\n\t\t\t\t}\n\t\t\t\tif (children.size !== 0) {\n\t\t\t\t\tsnapshot.setChildren(children);\n\t\t\t\t}\n\t\t\t\tthis._snapshotCache.set(snapshot, true);\n\t\t\t\tthis._statCreatedSnapshots++;\n\n\t\t\t\tcallback(null, snapshot);\n\t\t\t}\n\t\t};\n\t\tconst jobError = () => {\n\t\t\tif (jobs > 0) {\n\t\t\t\t// large negative number instead of NaN or something else to keep jobs to stay a SMI (v8)\n\t\t\t\tjobs = -100000000;\n\t\t\t\tcallback(null, null);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {string} path path\n\t\t * @param {Set<string>} managedSet managed set\n\t\t * @returns {boolean} true when managed\n\t\t */\n\t\tconst checkManaged = (path, managedSet) => {\n\t\t\tfor (const unmanagedPath of this.unmanagedPathsRegExps) {\n\t\t\t\tif (unmanagedPath.test(path)) return false;\n\t\t\t}\n\t\t\tfor (const unmanagedPath of this.unmanagedPathsWithSlash) {\n\t\t\t\tif (path.startsWith(unmanagedPath)) return false;\n\t\t\t}\n\t\t\tfor (const immutablePath of this.immutablePathsRegExps) {\n\t\t\t\tif (immutablePath.test(path)) {\n\t\t\t\t\tmanagedSet.add(path);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const immutablePath of this.immutablePathsWithSlash) {\n\t\t\t\tif (path.startsWith(immutablePath)) {\n\t\t\t\t\tmanagedSet.add(path);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const managedPath of this.managedPathsRegExps) {\n\t\t\t\tconst match = managedPath.exec(path);\n\t\t\t\tif (match) {\n\t\t\t\t\tconst managedItem = getManagedItem(match[1], path);\n\t\t\t\t\tif (managedItem) {\n\t\t\t\t\t\tmanagedItems.add(managedItem);\n\t\t\t\t\t\tmanagedSet.add(path);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const managedPath of this.managedPathsWithSlash) {\n\t\t\t\tif (path.startsWith(managedPath)) {\n\t\t\t\t\tconst managedItem = getManagedItem(managedPath, path);\n\t\t\t\t\tif (managedItem) {\n\t\t\t\t\t\tmanagedItems.add(managedItem);\n\t\t\t\t\t\tmanagedSet.add(path);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\t/**\n\t\t * @param {Iterable<string>} items items\n\t\t * @param {Set<string>} managedSet managed set\n\t\t * @returns {Set<string>} result\n\t\t */\n\t\tconst captureNonManaged = (items, managedSet) => {\n\t\t\tconst capturedItems = new Set();\n\t\t\tfor (const path of items) {\n\t\t\t\tif (!checkManaged(path, managedSet)) capturedItems.add(path);\n\t\t\t}\n\t\t\treturn capturedItems;\n\t\t};\n\t\t/**\n\t\t * @param {Set<string>} capturedFiles captured files\n\t\t */\n\t\tconst processCapturedFiles = capturedFiles => {\n\t\t\tswitch (mode) {\n\t\t\t\tcase 3:\n\t\t\t\t\tthis._fileTshsOptimization.optimize(snapshot, capturedFiles);\n\t\t\t\t\tfor (const path of capturedFiles) {\n\t\t\t\t\t\tconst cache = this._fileTshs.get(path);\n\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\tfileTshs.set(path, cache);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\tthis._getFileTimestampAndHash(path, (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting file timestamp hash combination of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfileTshs.set(path, /** @type {TimestampAndHash} */ (entry));\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis._fileHashesOptimization.optimize(snapshot, capturedFiles);\n\t\t\t\t\tfor (const path of capturedFiles) {\n\t\t\t\t\t\tconst cache = this._fileHashes.get(path);\n\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\tfileHashes.set(path, cache);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\tthis.fileHashQueue.add(path, (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting file hash of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfileHashes.set(path, /** @type {string} */ (entry));\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tthis._fileTimestampsOptimization.optimize(snapshot, capturedFiles);\n\t\t\t\t\tfor (const path of capturedFiles) {\n\t\t\t\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\tif (cache !== \"ignore\") {\n\t\t\t\t\t\t\t\tfileTimestamps.set(path, cache);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting file timestamp of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfileTimestamps.set(\n\t\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\t\t/** @type {FileSystemInfoEntry} */\n\t\t\t\t\t\t\t\t\t\t(entry)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t\tif (files) {\n\t\t\tprocessCapturedFiles(captureNonManaged(files, managedFiles));\n\t\t}\n\t\t/**\n\t\t * @param {Set<string>} capturedDirectories captured directories\n\t\t */\n\t\tconst processCapturedDirectories = capturedDirectories => {\n\t\t\tswitch (mode) {\n\t\t\t\tcase 3:\n\t\t\t\t\tthis._contextTshsOptimization.optimize(snapshot, capturedDirectories);\n\t\t\t\t\tfor (const path of capturedDirectories) {\n\t\t\t\t\t\tconst cache = this._contextTshs.get(path);\n\t\t\t\t\t\t/** @type {ResolvedContextTimestampAndHash | null | undefined} */\n\t\t\t\t\t\tlet resolved;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcache !== undefined &&\n\t\t\t\t\t\t\t(resolved = getResolvedTimestamp(cache)) !== undefined\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontextTshs.set(path, resolved);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {(WebpackError | null)=} err error\n\t\t\t\t\t\t\t * @param {(ResolvedContextTimestampAndHash | null)=} entry entry\n\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting context timestamp hash combination of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcontextTshs.set(\n\t\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\t\t/** @type {ResolvedContextTimestampAndHash | null} */\n\t\t\t\t\t\t\t\t\t\t(entry)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\t\tthis._resolveContextTsh(cache, callback);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.getContextTsh(path, callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tthis._contextHashesOptimization.optimize(\n\t\t\t\t\t\tsnapshot,\n\t\t\t\t\t\tcapturedDirectories\n\t\t\t\t\t);\n\t\t\t\t\tfor (const path of capturedDirectories) {\n\t\t\t\t\t\tconst cache = this._contextHashes.get(path);\n\t\t\t\t\t\tlet resolved;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcache !== undefined &&\n\t\t\t\t\t\t\t(resolved = getResolvedHash(cache)) !== undefined\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontextHashes.set(path, resolved);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {(WebpackError | null)=} err err\n\t\t\t\t\t\t\t * @param {string=} entry entry\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting context hash of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcontextHashes.set(path, /** @type {string} */ (entry));\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\t\tthis._resolveContextHash(cache, callback);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.getContextHash(path, callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tthis._contextTimestampsOptimization.optimize(\n\t\t\t\t\t\tsnapshot,\n\t\t\t\t\t\tcapturedDirectories\n\t\t\t\t\t);\n\t\t\t\t\tfor (const path of capturedDirectories) {\n\t\t\t\t\t\tconst cache = this._contextTimestamps.get(path);\n\t\t\t\t\t\tif (cache === \"ignore\") continue;\n\t\t\t\t\t\tlet resolved;\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcache !== undefined &&\n\t\t\t\t\t\t\t(resolved = getResolvedTimestamp(cache)) !== undefined\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontextTimestamps.set(path, resolved);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * @param {(Error | null)=} err error\n\t\t\t\t\t\t\t * @param {(FileSystemInfoEntry | \"ignore\" | null)=} entry entry\n\t\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t\t\t`Error snapshotting context timestamp of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tcontextTimestamps.set(\n\t\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\t\t/** @type {FileSystemInfoEntry | null} */\n\t\t\t\t\t\t\t\t\t\t(entry)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\t\tthis._resolveContextTimestamp(\n\t\t\t\t\t\t\t\t\t/** @type {ContextFileSystemInfoEntry} */\n\t\t\t\t\t\t\t\t\t(cache),\n\t\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis.getContextTimestamp(path, callback);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t\tif (directories) {\n\t\t\tprocessCapturedDirectories(\n\t\t\t\tcaptureNonManaged(directories, managedContexts)\n\t\t\t);\n\t\t}\n\t\t/**\n\t\t * @param {Set<string>} capturedMissing captured missing\n\t\t */\n\t\tconst processCapturedMissing = capturedMissing => {\n\t\t\tthis._missingExistenceOptimization.optimize(snapshot, capturedMissing);\n\t\t\tfor (const path of capturedMissing) {\n\t\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tif (cache !== \"ignore\") {\n\t\t\t\t\t\tmissingExistence.set(path, Boolean(cache));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjobs++;\n\t\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t\t`Error snapshotting missing timestamp of ${path}: ${err.stack}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjobError();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmissingExistence.set(path, Boolean(entry));\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (missing) {\n\t\t\tprocessCapturedMissing(captureNonManaged(missing, managedMissing));\n\t\t}\n\t\tthis._managedItemInfoOptimization.optimize(snapshot, managedItems);\n\t\tfor (const path of managedItems) {\n\t\t\tconst cache = this._managedItems.get(path);\n\t\t\tif (cache !== undefined) {\n\t\t\t\tif (!cache.startsWith(\"*\")) {\n\t\t\t\t\tmanagedFiles.add(join(this.fs, path, \"package.json\"));\n\t\t\t\t} else if (cache === \"*nested\") {\n\t\t\t\t\tmanagedMissing.add(join(this.fs, path, \"package.json\"));\n\t\t\t\t}\n\t\t\t\tmanagedItemInfo.set(path, cache);\n\t\t\t} else {\n\t\t\t\tjobs++;\n\t\t\t\tthis.managedItemQueue.add(path, (err, entry) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tif (this.logger) {\n\t\t\t\t\t\t\tthis.logger.debug(\n\t\t\t\t\t\t\t\t`Error snapshotting managed item ${path}: ${err.stack}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tjobError();\n\t\t\t\t\t} else if (entry) {\n\t\t\t\t\t\tif (!entry.startsWith(\"*\")) {\n\t\t\t\t\t\t\tmanagedFiles.add(join(this.fs, path, \"package.json\"));\n\t\t\t\t\t\t} else if (cache === \"*nested\") {\n\t\t\t\t\t\t\tmanagedMissing.add(join(this.fs, path, \"package.json\"));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmanagedItemInfo.set(path, entry);\n\t\t\t\t\t\tjobDone();\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Fallback to normal snapshotting\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {Set<string>} set set\n\t\t\t\t\t\t * @param {function(Set<string>): void} fn fn\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst process = (set, fn) => {\n\t\t\t\t\t\t\tif (set.size === 0) return;\n\t\t\t\t\t\t\tconst captured = new Set();\n\t\t\t\t\t\t\tfor (const file of set) {\n\t\t\t\t\t\t\t\tif (file.startsWith(path)) captured.add(file);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (captured.size > 0) fn(captured);\n\t\t\t\t\t\t};\n\t\t\t\t\t\tprocess(managedFiles, processCapturedFiles);\n\t\t\t\t\t\tprocess(managedContexts, processCapturedDirectories);\n\t\t\t\t\t\tprocess(managedMissing, processCapturedMissing);\n\t\t\t\t\t\tjobDone();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tjobDone();\n\t}\n\n\t/**\n\t * @param {Snapshot} snapshot1 a snapshot\n\t * @param {Snapshot} snapshot2 a snapshot\n\t * @returns {Snapshot} merged snapshot\n\t */\n\tmergeSnapshots(snapshot1, snapshot2) {\n\t\tconst snapshot = new Snapshot();\n\t\tif (snapshot1.hasStartTime() && snapshot2.hasStartTime()) {\n\t\t\tsnapshot.setStartTime(\n\t\t\t\tMath.min(\n\t\t\t\t\t/** @type {NonNullable<Snapshot[\"startTime\"]>} */\n\t\t\t\t\t(snapshot1.startTime),\n\t\t\t\t\t/** @type {NonNullable<Snapshot[\"startTime\"]>} */\n\t\t\t\t\t(snapshot2.startTime)\n\t\t\t\t)\n\t\t\t);\n\t\t} else if (snapshot2.hasStartTime()) {\n\t\t\tsnapshot.startTime = snapshot2.startTime;\n\t\t} else if (snapshot1.hasStartTime()) {\n\t\t\tsnapshot.startTime = snapshot1.startTime;\n\t\t}\n\t\tif (snapshot1.hasFileTimestamps() || snapshot2.hasFileTimestamps()) {\n\t\t\tsnapshot.setFileTimestamps(\n\t\t\t\tmergeMaps(snapshot1.fileTimestamps, snapshot2.fileTimestamps)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasFileHashes() || snapshot2.hasFileHashes()) {\n\t\t\tsnapshot.setFileHashes(\n\t\t\t\tmergeMaps(snapshot1.fileHashes, snapshot2.fileHashes)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasFileTshs() || snapshot2.hasFileTshs()) {\n\t\t\tsnapshot.setFileTshs(mergeMaps(snapshot1.fileTshs, snapshot2.fileTshs));\n\t\t}\n\t\tif (snapshot1.hasContextTimestamps() || snapshot2.hasContextTimestamps()) {\n\t\t\tsnapshot.setContextTimestamps(\n\t\t\t\tmergeMaps(snapshot1.contextTimestamps, snapshot2.contextTimestamps)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasContextHashes() || snapshot2.hasContextHashes()) {\n\t\t\tsnapshot.setContextHashes(\n\t\t\t\tmergeMaps(snapshot1.contextHashes, snapshot2.contextHashes)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasContextTshs() || snapshot2.hasContextTshs()) {\n\t\t\tsnapshot.setContextTshs(\n\t\t\t\tmergeMaps(snapshot1.contextTshs, snapshot2.contextTshs)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasMissingExistence() || snapshot2.hasMissingExistence()) {\n\t\t\tsnapshot.setMissingExistence(\n\t\t\t\tmergeMaps(snapshot1.missingExistence, snapshot2.missingExistence)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasManagedItemInfo() || snapshot2.hasManagedItemInfo()) {\n\t\t\tsnapshot.setManagedItemInfo(\n\t\t\t\tmergeMaps(snapshot1.managedItemInfo, snapshot2.managedItemInfo)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasManagedFiles() || snapshot2.hasManagedFiles()) {\n\t\t\tsnapshot.setManagedFiles(\n\t\t\t\tmergeSets(snapshot1.managedFiles, snapshot2.managedFiles)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasManagedContexts() || snapshot2.hasManagedContexts()) {\n\t\t\tsnapshot.setManagedContexts(\n\t\t\t\tmergeSets(snapshot1.managedContexts, snapshot2.managedContexts)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasManagedMissing() || snapshot2.hasManagedMissing()) {\n\t\t\tsnapshot.setManagedMissing(\n\t\t\t\tmergeSets(snapshot1.managedMissing, snapshot2.managedMissing)\n\t\t\t);\n\t\t}\n\t\tif (snapshot1.hasChildren() || snapshot2.hasChildren()) {\n\t\t\tsnapshot.setChildren(mergeSets(snapshot1.children, snapshot2.children));\n\t\t}\n\t\tif (\n\t\t\tthis._snapshotCache.get(snapshot1) === true &&\n\t\t\tthis._snapshotCache.get(snapshot2) === true\n\t\t) {\n\t\t\tthis._snapshotCache.set(snapshot, true);\n\t\t}\n\t\treturn snapshot;\n\t}\n\n\t/**\n\t * @param {Snapshot} snapshot the snapshot made\n\t * @param {function((WebpackError | null)=, boolean=): void} callback callback function\n\t * @returns {void}\n\t */\n\tcheckSnapshotValid(snapshot, callback) {\n\t\tconst cachedResult = this._snapshotCache.get(snapshot);\n\t\tif (cachedResult !== undefined) {\n\t\t\tthis._statTestedSnapshotsCached++;\n\t\t\tif (typeof cachedResult === \"boolean\") {\n\t\t\t\tcallback(null, cachedResult);\n\t\t\t} else {\n\t\t\t\tcachedResult.push(callback);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis._statTestedSnapshotsNotCached++;\n\t\tthis._checkSnapshotValidNoCache(snapshot, callback);\n\t}\n\n\t/**\n\t * @param {Snapshot} snapshot the snapshot made\n\t * @param {function((WebpackError | null)=, boolean=): void} callback callback function\n\t * @returns {void}\n\t */\n\t_checkSnapshotValidNoCache(snapshot, callback) {\n\t\t/** @type {number | undefined} */\n\t\tlet startTime;\n\t\tif (snapshot.hasStartTime()) {\n\t\t\tstartTime = snapshot.startTime;\n\t\t}\n\t\tlet jobs = 1;\n\t\tconst jobDone = () => {\n\t\t\tif (--jobs === 0) {\n\t\t\t\tthis._snapshotCache.set(snapshot, true);\n\t\t\t\tcallback(null, true);\n\t\t\t}\n\t\t};\n\t\tconst invalid = () => {\n\t\t\tif (jobs > 0) {\n\t\t\t\t// large negative number instead of NaN or something else to keep jobs to stay a SMI (v8)\n\t\t\t\tjobs = -100000000;\n\t\t\t\tthis._snapshotCache.set(snapshot, false);\n\t\t\t\tcallback(null, false);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {string} path path\n\t\t * @param {WebpackError} err err\n\t\t */\n\t\tconst invalidWithError = (path, err) => {\n\t\t\tif (this._remainingLogs > 0) {\n\t\t\t\tthis._log(path, \"error occurred: %s\", err);\n\t\t\t}\n\t\t\tinvalid();\n\t\t};\n\t\t/**\n\t\t * @param {string} path file path\n\t\t * @param {string | null} current current hash\n\t\t * @param {string | null} snap snapshot hash\n\t\t * @returns {boolean} true, if ok\n\t\t */\n\t\tconst checkHash = (path, current, snap) => {\n\t\t\tif (current !== snap) {\n\t\t\t\t// If hash differ it's invalid\n\t\t\t\tif (this._remainingLogs > 0) {\n\t\t\t\t\tthis._log(path, \"hashes differ (%s != %s)\", current, snap);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\t/**\n\t\t * @param {string} path file path\n\t\t * @param {boolean} current current entry\n\t\t * @param {boolean} snap entry from snapshot\n\t\t * @returns {boolean} true, if ok\n\t\t */\n\t\tconst checkExistence = (path, current, snap) => {\n\t\t\tif (!current !== !snap) {\n\t\t\t\t// If existence of item differs\n\t\t\t\t// it's invalid\n\t\t\t\tif (this._remainingLogs > 0) {\n\t\t\t\t\tthis._log(\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tcurrent ? \"it didn't exist before\" : \"it does no longer exist\"\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\t/**\n\t\t * @param {string} path file path\n\t\t * @param {FileSystemInfoEntry | null} c current entry\n\t\t * @param {FileSystemInfoEntry | null} s entry from snapshot\n\t\t * @param {boolean} log log reason\n\t\t * @returns {boolean} true, if ok\n\t\t */\n\t\tconst checkFile = (path, c, s, log = true) => {\n\t\t\tif (c === s) return true;\n\t\t\tif (!checkExistence(path, Boolean(c), Boolean(s))) return false;\n\t\t\tif (c) {\n\t\t\t\t// For existing items only\n\t\t\t\tif (typeof startTime === \"number\" && c.safeTime > startTime) {\n\t\t\t\t\t// If a change happened after starting reading the item\n\t\t\t\t\t// this may no longer be valid\n\t\t\t\t\tif (log && this._remainingLogs > 0) {\n\t\t\t\t\t\tthis._log(\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\"it may have changed (%d) after the start time of the snapshot (%d)\",\n\t\t\t\t\t\t\tc.safeTime,\n\t\t\t\t\t\t\tstartTime\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tconst snap = /** @type {FileSystemInfoEntry} */ (s);\n\t\t\t\tif (snap.timestamp !== undefined && c.timestamp !== snap.timestamp) {\n\t\t\t\t\t// If we have a timestamp (it was a file or symlink) and it differs from current timestamp\n\t\t\t\t\t// it's invalid\n\t\t\t\t\tif (log && this._remainingLogs > 0) {\n\t\t\t\t\t\tthis._log(\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\"timestamps differ (%d != %d)\",\n\t\t\t\t\t\t\tc.timestamp,\n\t\t\t\t\t\t\tsnap.timestamp\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\t/**\n\t\t * @param {string} path file path\n\t\t * @param {ResolvedContextFileSystemInfoEntry | null} c current entry\n\t\t * @param {ResolvedContextFileSystemInfoEntry | null} s entry from snapshot\n\t\t * @param {boolean} log log reason\n\t\t * @returns {boolean} true, if ok\n\t\t */\n\t\tconst checkContext = (path, c, s, log = true) => {\n\t\t\tif (c === s) return true;\n\t\t\tif (!checkExistence(path, Boolean(c), Boolean(s))) return false;\n\t\t\tif (c) {\n\t\t\t\t// For existing items only\n\t\t\t\tif (typeof startTime === \"number\" && c.safeTime > startTime) {\n\t\t\t\t\t// If a change happened after starting reading the item\n\t\t\t\t\t// this may no longer be valid\n\t\t\t\t\tif (log && this._remainingLogs > 0) {\n\t\t\t\t\t\tthis._log(\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\"it may have changed (%d) after the start time of the snapshot (%d)\",\n\t\t\t\t\t\t\tc.safeTime,\n\t\t\t\t\t\t\tstartTime\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tconst snap = /** @type {ResolvedContextFileSystemInfoEntry} */ (s);\n\t\t\t\tif (\n\t\t\t\t\tsnap.timestampHash !== undefined &&\n\t\t\t\t\tc.timestampHash !== snap.timestampHash\n\t\t\t\t) {\n\t\t\t\t\t// If we have a timestampHash (it was a directory) and it differs from current timestampHash\n\t\t\t\t\t// it's invalid\n\t\t\t\t\tif (log && this._remainingLogs > 0) {\n\t\t\t\t\t\tthis._log(\n\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\"timestamps hashes differ (%s != %s)\",\n\t\t\t\t\t\t\tc.timestampHash,\n\t\t\t\t\t\t\tsnap.timestampHash\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\t\tif (snapshot.hasChildren()) {\n\t\t\t/**\n\t\t\t * @param {(WebpackError | null)=} err err\n\t\t\t * @param {boolean=} result result\n\t\t\t * @returns {void}\n\t\t\t */\n\t\t\tconst childCallback = (err, result) => {\n\t\t\t\tif (err || !result) return invalid();\n\t\t\t\tjobDone();\n\t\t\t};\n\t\t\tfor (const child of /** @type {Children} */ (snapshot.children)) {\n\t\t\t\tconst cache = this._snapshotCache.get(child);\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tthis._statTestedChildrenCached++;\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif (typeof cache === \"boolean\") {\n\t\t\t\t\t\tif (cache === false) {\n\t\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\tcache.push(childCallback);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._statTestedChildrenNotCached++;\n\t\t\t\t\tjobs++;\n\t\t\t\t\tthis._checkSnapshotValidNoCache(child, childCallback);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasFileTimestamps()) {\n\t\t\tconst fileTimestamps =\n\t\t\t\t/** @type {FileTimestamps} */\n\t\t\t\t(snapshot.fileTimestamps);\n\t\t\tthis._statTestedEntries += fileTimestamps.size;\n\t\t\tfor (const [path, ts] of fileTimestamps) {\n\t\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tif (cache !== \"ignore\" && !checkFile(path, cache, ts)) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjobs++;\n\t\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!checkFile(\n\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t/** @type {FileSystemInfoEntry | null} */ (entry),\n\t\t\t\t\t\t\t\tts\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * @param {string} path file path\n\t\t * @param {string | null} hash hash\n\t\t */\n\t\tconst processFileHashSnapshot = (path, hash) => {\n\t\t\tconst cache = this._fileHashes.get(path);\n\t\t\tif (cache !== undefined) {\n\t\t\t\tif (cache !== \"ignore\" && !checkHash(path, cache, hash)) {\n\t\t\t\t\tinvalid();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjobs++;\n\t\t\t\tthis.fileHashQueue.add(path, (err, entry) => {\n\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\tif (!checkHash(path, /** @type {string} */ (entry), hash)) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjobDone();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t\tif (snapshot.hasFileHashes()) {\n\t\t\tconst fileHashes = /** @type {FileHashes} */ (snapshot.fileHashes);\n\t\t\tthis._statTestedEntries += fileHashes.size;\n\t\t\tfor (const [path, hash] of fileHashes) {\n\t\t\t\tprocessFileHashSnapshot(path, hash);\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasFileTshs()) {\n\t\t\tconst fileTshs = /** @type {FileTshs} */ (snapshot.fileTshs);\n\t\t\tthis._statTestedEntries += fileTshs.size;\n\t\t\tfor (const [path, tsh] of fileTshs) {\n\t\t\t\tif (typeof tsh === \"string\") {\n\t\t\t\t\tprocessFileHashSnapshot(path, tsh);\n\t\t\t\t} else {\n\t\t\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\tif (cache === \"ignore\" || !checkFile(path, cache, tsh, false)) {\n\t\t\t\t\t\t\tprocessFileHashSnapshot(path, tsh && tsh.hash);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!checkFile(\n\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\t/** @type {FileSystemInfoEntry | null} */\n\t\t\t\t\t\t\t\t\t(entry),\n\t\t\t\t\t\t\t\t\ttsh,\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tprocessFileHashSnapshot(path, tsh && tsh.hash);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasContextTimestamps()) {\n\t\t\tconst contextTimestamps =\n\t\t\t\t/** @type {ContextTimestamps} */\n\t\t\t\t(snapshot.contextTimestamps);\n\t\t\tthis._statTestedEntries += contextTimestamps.size;\n\t\t\tfor (const [path, ts] of contextTimestamps) {\n\t\t\t\tconst cache = this._contextTimestamps.get(path);\n\t\t\t\tif (cache === \"ignore\") continue;\n\t\t\t\tlet resolved;\n\t\t\t\tif (\n\t\t\t\t\tcache !== undefined &&\n\t\t\t\t\t(resolved = getResolvedTimestamp(cache)) !== undefined\n\t\t\t\t) {\n\t\t\t\t\tif (!checkContext(path, resolved, ts)) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjobs++;\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {(WebpackError | null)=} err error\n\t\t\t\t\t * @param {(ResolvedContextFileSystemInfoEntry | \"ignore\" | null)=} entry entry\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!checkContext(\n\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t/** @type {ResolvedContextFileSystemInfoEntry | null} */\n\t\t\t\t\t\t\t\t(entry),\n\t\t\t\t\t\t\t\tts\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\tthis._resolveContextTimestamp(\n\t\t\t\t\t\t\t/** @type {ContextFileSystemInfoEntry} */\n\t\t\t\t\t\t\t(cache),\n\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.getContextTimestamp(path, callback);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/**\n\t\t * @param {string} path path\n\t\t * @param {string | null} hash hash\n\t\t */\n\t\tconst processContextHashSnapshot = (path, hash) => {\n\t\t\tconst cache = this._contextHashes.get(path);\n\t\t\tlet resolved;\n\t\t\tif (\n\t\t\t\tcache !== undefined &&\n\t\t\t\t(resolved = getResolvedHash(cache)) !== undefined\n\t\t\t) {\n\t\t\t\tif (!checkHash(path, resolved, hash)) {\n\t\t\t\t\tinvalid();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tjobs++;\n\t\t\t\t/**\n\t\t\t\t * @param {(WebpackError | null)=} err err\n\t\t\t\t * @param {string=} entry entry\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\tif (!checkHash(path, /** @type {string} */ (entry), hash)) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjobDone();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tthis._resolveContextHash(cache, callback);\n\t\t\t\t} else {\n\t\t\t\t\tthis.getContextHash(path, callback);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (snapshot.hasContextHashes()) {\n\t\t\tconst contextHashes =\n\t\t\t\t/** @type {ContextHashes} */\n\t\t\t\t(snapshot.contextHashes);\n\t\t\tthis._statTestedEntries += contextHashes.size;\n\t\t\tfor (const [path, hash] of contextHashes) {\n\t\t\t\tprocessContextHashSnapshot(path, hash);\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasContextTshs()) {\n\t\t\tconst contextTshs = /** @type {ContextTshs} */ (snapshot.contextTshs);\n\t\t\tthis._statTestedEntries += contextTshs.size;\n\t\t\tfor (const [path, tsh] of contextTshs) {\n\t\t\t\tif (typeof tsh === \"string\") {\n\t\t\t\t\tprocessContextHashSnapshot(path, tsh);\n\t\t\t\t} else {\n\t\t\t\t\tconst cache = this._contextTimestamps.get(path);\n\t\t\t\t\tif (cache === \"ignore\") continue;\n\t\t\t\t\tlet resolved;\n\t\t\t\t\tif (\n\t\t\t\t\t\tcache !== undefined &&\n\t\t\t\t\t\t(resolved = getResolvedTimestamp(cache)) !== undefined\n\t\t\t\t\t) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!checkContext(\n\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t/** @type {ResolvedContextFileSystemInfoEntry | null} */\n\t\t\t\t\t\t\t\t(resolved),\n\t\t\t\t\t\t\t\ttsh,\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tprocessContextHashSnapshot(path, tsh && tsh.hash);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tjobs++;\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * @param {(WebpackError | null)=} err error\n\t\t\t\t\t\t * @param {(ResolvedContextFileSystemInfoEntry | \"ignore\" | null)=} entry entry\n\t\t\t\t\t\t * @returns {void}\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst callback = (err, entry) => {\n\t\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!checkContext(\n\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\t// TODO: test with `\"ignore\"`\n\t\t\t\t\t\t\t\t\t/** @type {ResolvedContextFileSystemInfoEntry | null} */\n\t\t\t\t\t\t\t\t\t(entry),\n\t\t\t\t\t\t\t\t\ttsh,\n\t\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tprocessContextHashSnapshot(path, tsh && tsh.hash);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\t\t\tthis._resolveContextTimestamp(\n\t\t\t\t\t\t\t\t/** @type {ContextFileSystemInfoEntry} */\n\t\t\t\t\t\t\t\t(cache),\n\t\t\t\t\t\t\t\tcallback\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.getContextTimestamp(path, callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasMissingExistence()) {\n\t\t\tconst missingExistence =\n\t\t\t\t/** @type {MissingExistence} */\n\t\t\t\t(snapshot.missingExistence);\n\t\t\tthis._statTestedEntries += missingExistence.size;\n\t\t\tfor (const [path, existence] of missingExistence) {\n\t\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tcache !== \"ignore\" &&\n\t\t\t\t\t\t!checkExistence(path, Boolean(cache), Boolean(existence))\n\t\t\t\t\t) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjobs++;\n\t\t\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\tif (!checkExistence(path, Boolean(entry), Boolean(existence))) {\n\t\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (snapshot.hasManagedItemInfo()) {\n\t\t\tconst managedItemInfo =\n\t\t\t\t/** @type {ManagedItemInfo} */\n\t\t\t\t(snapshot.managedItemInfo);\n\t\t\tthis._statTestedEntries += managedItemInfo.size;\n\t\t\tfor (const [path, info] of managedItemInfo) {\n\t\t\t\tconst cache = this._managedItems.get(path);\n\t\t\t\tif (cache !== undefined) {\n\t\t\t\t\tif (!checkHash(path, cache, info)) {\n\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tjobs++;\n\t\t\t\t\tthis.managedItemQueue.add(path, (err, entry) => {\n\t\t\t\t\t\tif (err) return invalidWithError(path, err);\n\t\t\t\t\t\tif (!checkHash(path, /** @type {string} */ (entry), info)) {\n\t\t\t\t\t\t\tinvalid();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tjobDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tjobDone();\n\n\t\t// if there was an async action\n\t\t// try to join multiple concurrent request for this snapshot\n\t\tif (jobs > 0) {\n\t\t\tconst callbacks = [callback];\n\t\t\tcallback = (err, result) => {\n\t\t\t\tfor (const callback of callbacks) callback(err, result);\n\t\t\t};\n\t\t\tthis._snapshotCache.set(snapshot, callbacks);\n\t\t}\n\t}\n\n\t/**\n\t * @type {Processor<string, FileSystemInfoEntry>}\n\t * @private\n\t */\n\t_readFileTimestamp(path, callback) {\n\t\tthis.fs.stat(path, (err, _stat) => {\n\t\t\tif (err) {\n\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\tthis._fileTimestamps.set(path, null);\n\t\t\t\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\t\t\t\t\treturn callback(null, null);\n\t\t\t\t}\n\t\t\t\treturn callback(/** @type {WebpackError} */ (err));\n\t\t\t}\n\t\t\tconst stat = /** @type {IStats} */ (_stat);\n\t\t\tlet ts;\n\t\t\tif (stat.isDirectory()) {\n\t\t\t\tts = {\n\t\t\t\t\tsafeTime: 0,\n\t\t\t\t\ttimestamp: undefined\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tconst mtime = Number(stat.mtime);\n\n\t\t\t\tif (mtime) applyMtime(mtime);\n\n\t\t\t\tts = {\n\t\t\t\t\tsafeTime: mtime ? mtime + FS_ACCURACY : Infinity,\n\t\t\t\t\ttimestamp: mtime\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tthis._fileTimestamps.set(path, ts);\n\t\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\n\t\t\tcallback(null, ts);\n\t\t});\n\t}\n\n\t/**\n\t * @type {Processor<string, string>}\n\t * @private\n\t */\n\t_readFileHash(path, callback) {\n\t\tthis.fs.readFile(path, (err, content) => {\n\t\t\tif (err) {\n\t\t\t\tif (err.code === \"EISDIR\") {\n\t\t\t\t\tthis._fileHashes.set(path, \"directory\");\n\t\t\t\t\treturn callback(null, \"directory\");\n\t\t\t\t}\n\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\tthis._fileHashes.set(path, null);\n\t\t\t\t\treturn callback(null, null);\n\t\t\t\t}\n\t\t\t\tif (err.code === \"ERR_FS_FILE_TOO_LARGE\") {\n\t\t\t\t\t/** @type {Logger} */\n\t\t\t\t\t(this.logger).warn(`Ignoring ${path} for hashing as it's very large`);\n\t\t\t\t\tthis._fileHashes.set(path, \"too large\");\n\t\t\t\t\treturn callback(null, \"too large\");\n\t\t\t\t}\n\t\t\t\treturn callback(/** @type {WebpackError} */ (err));\n\t\t\t}\n\n\t\t\tconst hash = createHash(this._hashFunction);\n\n\t\t\thash.update(/** @type {string | Buffer} */ (content));\n\n\t\t\tconst digest = /** @type {string} */ (hash.digest(\"hex\"));\n\n\t\t\tthis._fileHashes.set(path, digest);\n\n\t\t\tcallback(null, digest);\n\t\t});\n\t}\n\n\t/**\n\t * @param {string} path path\n\t * @param {function(WebpackError | null, TimestampAndHash=) : void} callback callback\n\t * @private\n\t */\n\t_getFileTimestampAndHash(path, callback) {\n\t\t/**\n\t\t * @param {string} hash hash\n\t\t * @returns {void}\n\t\t */\n\t\tconst continueWithHash = hash => {\n\t\t\tconst cache = this._fileTimestamps.get(path);\n\t\t\tif (cache !== undefined) {\n\t\t\t\tif (cache !== \"ignore\") {\n\t\t\t\t\t/** @type {TimestampAndHash} */\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\t.../** @type {FileSystemInfoEntry} */ (cache),\n\t\t\t\t\t\thash\n\t\t\t\t\t};\n\t\t\t\t\tthis._fileTshs.set(path, result);\n\t\t\t\t\treturn callback(null, result);\n\t\t\t\t}\n\t\t\t\tthis._fileTshs.set(path, hash);\n\t\t\t\treturn callback(null, /** @type {TODO} */ (hash));\n\t\t\t}\n\t\t\tthis.fileTimestampQueue.add(path, (err, entry) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\t/** @type {TimestampAndHash} */\n\t\t\t\tconst result = {\n\t\t\t\t\t.../** @type {FileSystemInfoEntry} */ (entry),\n\t\t\t\t\thash\n\t\t\t\t};\n\t\t\t\tthis._fileTshs.set(path, result);\n\t\t\t\treturn callback(null, result);\n\t\t\t});\n\t\t};\n\n\t\tconst cache = this._fileHashes.get(path);\n\t\tif (cache !== undefined) {\n\t\t\tcontinueWithHash(/** @type {string} */ (cache));\n\t\t} else {\n\t\t\tthis.fileHashQueue.add(path, (err, entry) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treturn callback(err);\n\t\t\t\t}\n\t\t\t\tcontinueWithHash(/** @type {string} */ (entry));\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * @template T\n\t * @template ItemType\n\t * @param {object} options options\n\t * @param {string} options.path path\n\t * @param {function(string): ItemType} options.fromImmutablePath called when context item is an immutable path\n\t * @param {function(string): ItemType} options.fromManagedItem called when context item is a managed path\n\t * @param {function(string, string, function((WebpackError | null)=, ItemType=): void): void} options.fromSymlink called when context item is a symlink\n\t * @param {function(string, IStats, function((WebpackError | null)=, (ItemType | null)=): void): void} options.fromFile called when context item is a file\n\t * @param {function(string, IStats, function((WebpackError | null)=, ItemType=): void): void} options.fromDirectory called when context item is a directory\n\t * @param {function(string[], ItemType[]): T} options.reduce called from all context items\n\t * @param {function((Error | null)=, (T | null)=): void} callback callback\n\t */\n\t_readContext(\n\t\t{\n\t\t\tpath,\n\t\t\tfromImmutablePath,\n\t\t\tfromManagedItem,\n\t\t\tfromSymlink,\n\t\t\tfromFile,\n\t\t\tfromDirectory,\n\t\t\treduce\n\t\t},\n\t\tcallback\n\t) {\n\t\tthis.fs.readdir(path, (err, _files) => {\n\t\t\tif (err) {\n\t\t\t\tif (err.code === \"ENOENT\") {\n\t\t\t\t\treturn callback(null, null);\n\t\t\t\t}\n\t\t\t\treturn callback(err);\n\t\t\t}\n\t\t\tconst files = /** @type {string[]} */ (_files)\n\t\t\t\t.map(file => file.normalize(\"NFC\"))\n\t\t\t\t.filter(file => !/^\\./.test(file))\n\t\t\t\t.sort();\n\t\t\tasyncLib.map(\n\t\t\t\tfiles,\n\t\t\t\t(file, callback) => {\n\t\t\t\t\tconst child = join(this.fs, path, file);\n\t\t\t\t\tfor (const immutablePath of this.immutablePathsRegExps) {\n\t\t\t\t\t\tif (immutablePath.test(path)) {\n\t\t\t\t\t\t\t// ignore any immutable path for timestamping\n\t\t\t\t\t\t\treturn callback(null, fromImmutablePath(path));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const immutablePath of this.immutablePathsWithSlash) {\n\t\t\t\t\t\tif (path.startsWith(immutablePath)) {\n\t\t\t\t\t\t\t// ignore any immutable path for timestamping\n\t\t\t\t\t\t\treturn callback(null, fromImmutablePath(path));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const managedPath of this.managedPathsRegExps) {\n\t\t\t\t\t\tconst match = managedPath.exec(path);\n\t\t\t\t\t\tif (match) {\n\t\t\t\t\t\t\tconst managedItem = getManagedItem(match[1], path);\n\t\t\t\t\t\t\tif (managedItem) {\n\t\t\t\t\t\t\t\t// construct timestampHash from managed info\n\t\t\t\t\t\t\t\treturn this.managedItemQueue.add(managedItem, (err, info) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\tfromManagedItem(/** @type {string} */ (info))\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (const managedPath of this.managedPathsWithSlash) {\n\t\t\t\t\t\tif (path.startsWith(managedPath)) {\n\t\t\t\t\t\t\tconst managedItem = getManagedItem(managedPath, child);\n\t\t\t\t\t\t\tif (managedItem) {\n\t\t\t\t\t\t\t\t// construct timestampHash from managed info\n\t\t\t\t\t\t\t\treturn this.managedItemQueue.add(managedItem, (err, info) => {\n\t\t\t\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\t\t\t\treturn callback(\n\t\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\t\tfromManagedItem(/** @type {string} */ (info))\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlstatReadlinkAbsolute(this.fs, child, (err, _stat) => {\n\t\t\t\t\t\tif (err) return callback(err);\n\n\t\t\t\t\t\tconst stat = /** @type {IStats | string} */ (_stat);\n\n\t\t\t\t\t\tif (typeof stat === \"string\") {\n\t\t\t\t\t\t\treturn fromSymlink(child, stat, callback);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (stat.isFile()) {\n\t\t\t\t\t\t\treturn fromFile(child, stat, callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (stat.isDirectory()) {\n\t\t\t\t\t\t\treturn fromDirectory(child, stat, callback);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcallback(null, null);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\t(err, results) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tconst result = reduce(files, /** @type {ItemType[]} */ (results));\n\t\t\t\t\tcallback(null, result);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * @type {Processor<string, ContextFileSystemInfoEntry>}\n\t * @private\n\t */\n\t_readContextTimestamp(path, callback) {\n\t\tthis._readContext(\n\t\t\t{\n\t\t\t\tpath,\n\t\t\t\tfromImmutablePath: () =>\n\t\t\t\t\t/** @type {ContextFileSystemInfoEntry | FileSystemInfoEntry | \"ignore\" | null} */\n\t\t\t\t\t(null),\n\t\t\t\tfromManagedItem: info => ({\n\t\t\t\t\tsafeTime: 0,\n\t\t\t\t\ttimestampHash: info\n\t\t\t\t}),\n\t\t\t\tfromSymlink: (file, target, callback) => {\n\t\t\t\t\tcallback(\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t/** @type {ContextFileSystemInfoEntry} */\n\t\t\t\t\t\t({\n\t\t\t\t\t\t\ttimestampHash: target,\n\t\t\t\t\t\t\tsymlinks: new Set([target])\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tfromFile: (file, stat, callback) => {\n\t\t\t\t\t// Prefer the cached value over our new stat to report consistent results\n\t\t\t\t\tconst cache = this._fileTimestamps.get(file);\n\t\t\t\t\tif (cache !== undefined)\n\t\t\t\t\t\treturn callback(null, cache === \"ignore\" ? null : cache);\n\n\t\t\t\t\tconst mtime = Number(stat.mtime);\n\n\t\t\t\t\tif (mtime) applyMtime(mtime);\n\n\t\t\t\t\t/** @type {FileSystemInfoEntry} */\n\t\t\t\t\tconst ts = {\n\t\t\t\t\t\tsafeTime: mtime ? mtime + FS_ACCURACY : Infinity,\n\t\t\t\t\t\ttimestamp: mtime\n\t\t\t\t\t};\n\n\t\t\t\t\tthis._fileTimestamps.set(file, ts);\n\t\t\t\t\tthis._cachedDeprecatedFileTimestamps = undefined;\n\t\t\t\t\tcallback(null, ts);\n\t\t\t\t},\n\t\t\t\tfromDirectory: (directory, stat, callback) => {\n\t\t\t\t\tthis.contextTimestampQueue.increaseParallelism();\n\t\t\t\t\tthis._getUnresolvedContextTimestamp(directory, (err, tsEntry) => {\n\t\t\t\t\t\tthis.contextTimestampQueue.decreaseParallelism();\n\t\t\t\t\t\tcallback(err, tsEntry);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\treduce: (files, tsEntries) => {\n\t\t\t\t\tlet symlinks;\n\n\t\t\t\t\tconst hash = createHash(this._hashFunction);\n\n\t\t\t\t\tfor (const file of files) hash.update(file);\n\t\t\t\t\tlet safeTime = 0;\n\t\t\t\t\tfor (const _e of tsEntries) {\n\t\t\t\t\t\tif (!_e) {\n\t\t\t\t\t\t\thash.update(\"n\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst entry =\n\t\t\t\t\t\t\t/** @type {FileSystemInfoEntry | ContextFileSystemInfoEntry} */\n\t\t\t\t\t\t\t(_e);\n\t\t\t\t\t\tif (/** @type {FileSystemInfoEntry} */ (entry).timestamp) {\n\t\t\t\t\t\t\thash.update(\"f\");\n\t\t\t\t\t\t\thash.update(\n\t\t\t\t\t\t\t\t`${/** @type {FileSystemInfoEntry} */ (entry).timestamp}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t/** @type {ContextFileSystemInfoEntry} */ (entry).timestampHash\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\thash.update(\"d\");\n\t\t\t\t\t\t\thash.update(\n\t\t\t\t\t\t\t\t`${/** @type {ContextFileSystemInfoEntry} */ (entry).timestampHash}`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t/** @type {ContextFileSystemInfoEntry} */\n\t\t\t\t\t\t\t(entry).symlinks !== undefined\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tif (symlinks === undefined) symlinks = new Set();\n\t\t\t\t\t\t\taddAll(\n\t\t\t\t\t\t\t\t/** @type {ContextFileSystemInfoEntry} */ (entry).symlinks,\n\t\t\t\t\t\t\t\tsymlinks\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst digest = /** @type {string} */ (hash.digest(\"hex\"));\n\t\t\t\t\t/** @type {ContextFileSystemInfoEntry} */\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\ttimestampHash: digest\n\t\t\t\t\t};\n\t\t\t\t\tif (symlinks) result.symlinks = symlinks;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t},\n\t\t\t(err, result) => {\n\t\t\t\tif (err) return callback(/** @type {WebpackError} */ (err));\n\t\t\t\tthis._contextTimestamps.set(path, result);\n\t\t\t\tthis._cachedDeprecatedContextTimestamps = undefined;\n\n\t\t\t\tcallback(null, result);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {ContextFileSystemInfoEntry} entry entry\n\t * @param {function((WebpackError | null)=, (ResolvedContextFileSystemInfoEntry | \"ignore\" | null)=): void} callback callback\n\t * @returns {void}\n\t */\n\t_resolveContextTimestamp(entry, callback) {\n\t\t/** @type {string[]} */\n\t\tconst hashes = [];\n\t\tlet safeTime = 0;\n\t\tprocessAsyncTree(\n\t\t\t/** @type {NonNullable<ContextHash[\"symlinks\"]>} */ (entry.symlinks),\n\t\t\t10,\n\t\t\t(target, push, callback) => {\n\t\t\t\tthis._getUnresolvedContextTimestamp(target, (err, entry) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tif (entry && entry !== \"ignore\") {\n\t\t\t\t\t\thashes.push(/** @type {string} */ (entry.timestampHash));\n\t\t\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entry.symlinks !== undefined) {\n\t\t\t\t\t\t\tfor (const target of entry.symlinks) push(target);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcallback();\n\t\t\t\t});\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tif (err) return callback(/** @type {WebpackError} */ (err));\n\t\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\t\thash.update(/** @type {string} */ (entry.timestampHash));\n\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t}\n\t\t\t\thashes.sort();\n\t\t\t\tfor (const h of hashes) {\n\t\t\t\t\thash.update(h);\n\t\t\t\t}\n\t\t\t\tcallback(\n\t\t\t\t\tnull,\n\t\t\t\t\t(entry.resolved = {\n\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\ttimestampHash: /** @type {string} */ (hash.digest(\"hex\"))\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @type {Processor<string, ContextHash>}\n\t * @private\n\t */\n\t_readContextHash(path, callback) {\n\t\tthis._readContext(\n\t\t\t{\n\t\t\t\tpath,\n\t\t\t\tfromImmutablePath: () =>\n\t\t\t\t\t/** @type {ContextHash} */ (/** @type {unknown} */ (\"\")),\n\t\t\t\tfromManagedItem: info => info || \"\",\n\t\t\t\tfromSymlink: (file, target, callback) => {\n\t\t\t\t\tcallback(\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t/** @type {ContextHash} */\n\t\t\t\t\t\t({\n\t\t\t\t\t\t\thash: target,\n\t\t\t\t\t\t\tsymlinks: new Set([target])\n\t\t\t\t\t\t})\n\t\t\t\t\t);\n\t\t\t\t},\n\t\t\t\tfromFile: (file, stat, callback) =>\n\t\t\t\t\tthis.getFileHash(file, (err, hash) => {\n\t\t\t\t\t\tcallback(err, hash || \"\");\n\t\t\t\t\t}),\n\t\t\t\tfromDirectory: (directory, stat, callback) => {\n\t\t\t\t\tthis.contextHashQueue.increaseParallelism();\n\t\t\t\t\tthis._getUnresolvedContextHash(directory, (err, hash) => {\n\t\t\t\t\t\tthis.contextHashQueue.decreaseParallelism();\n\t\t\t\t\t\tcallback(err, hash || \"\");\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\t/**\n\t\t\t\t * @param {string[]} files files\n\t\t\t\t * @param {(string | ContextHash)[]} fileHashes hashes\n\t\t\t\t * @returns {ContextHash} reduced hash\n\t\t\t\t */\n\t\t\t\treduce: (files, fileHashes) => {\n\t\t\t\t\tlet symlinks;\n\t\t\t\t\tconst hash = createHash(this._hashFunction);\n\n\t\t\t\t\tfor (const file of files) hash.update(file);\n\t\t\t\t\tfor (const entry of fileHashes) {\n\t\t\t\t\t\tif (typeof entry === \"string\") {\n\t\t\t\t\t\t\thash.update(entry);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\thash.update(entry.hash);\n\t\t\t\t\t\t\tif (entry.symlinks) {\n\t\t\t\t\t\t\t\tif (symlinks === undefined) symlinks = new Set();\n\t\t\t\t\t\t\t\taddAll(entry.symlinks, symlinks);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {ContextHash} */\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\thash: /** @type {string} */ (hash.digest(\"hex\"))\n\t\t\t\t\t};\n\t\t\t\t\tif (symlinks) result.symlinks = symlinks;\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t},\n\t\t\t(err, _result) => {\n\t\t\t\tif (err) return callback(/** @type {WebpackError} */ (err));\n\t\t\t\tconst result = /** @type {ContextHash} */ (_result);\n\t\t\t\tthis._contextHashes.set(path, result);\n\t\t\t\treturn callback(null, result);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @param {ContextHash} entry context hash\n\t * @param {function(WebpackError | null, string=): void} callback callback\n\t * @returns {void}\n\t */\n\t_resolveContextHash(entry, callback) {\n\t\t/** @type {string[]} */\n\t\tconst hashes = [];\n\t\tprocessAsyncTree(\n\t\t\t/** @type {NonNullable<ContextHash[\"symlinks\"]>} */ (entry.symlinks),\n\t\t\t10,\n\t\t\t(target, push, callback) => {\n\t\t\t\tthis._getUnresolvedContextHash(target, (err, hash) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tif (hash) {\n\t\t\t\t\t\thashes.push(hash.hash);\n\t\t\t\t\t\tif (hash.symlinks !== undefined) {\n\t\t\t\t\t\t\tfor (const target of hash.symlinks) push(target);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcallback();\n\t\t\t\t});\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tif (err) return callback(/** @type {WebpackError} */ (err));\n\t\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\t\thash.update(entry.hash);\n\t\t\t\thashes.sort();\n\t\t\t\tfor (const h of hashes) {\n\t\t\t\t\thash.update(h);\n\t\t\t\t}\n\t\t\t\tcallback(\n\t\t\t\t\tnull,\n\t\t\t\t\t(entry.resolved = /** @type {string} */ (hash.digest(\"hex\")))\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @type {Processor<string, ContextTimestampAndHash>}\n\t * @private\n\t */\n\t_readContextTimestampAndHash(path, callback) {\n\t\t/**\n\t\t * @param {ContextFileSystemInfoEntry | \"ignore\" | null} timestamp timestamp\n\t\t * @param {ContextHash} hash hash\n\t\t */\n\t\tconst finalize = (timestamp, hash) => {\n\t\t\tconst result =\n\t\t\t\t/** @type {ContextTimestampAndHash} */\n\t\t\t\t(timestamp === \"ignore\" ? hash : { ...timestamp, ...hash });\n\t\t\tthis._contextTshs.set(path, result);\n\t\t\tcallback(null, result);\n\t\t};\n\t\tconst cachedHash = this._contextHashes.get(path);\n\t\tconst cachedTimestamp = this._contextTimestamps.get(path);\n\t\tif (cachedHash !== undefined) {\n\t\t\tif (cachedTimestamp !== undefined) {\n\t\t\t\tfinalize(cachedTimestamp, cachedHash);\n\t\t\t} else {\n\t\t\t\tthis.contextTimestampQueue.add(path, (err, entry) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tfinalize(\n\t\t\t\t\t\t/** @type {ContextFileSystemInfoEntry} */\n\t\t\t\t\t\t(entry),\n\t\t\t\t\t\tcachedHash\n\t\t\t\t\t);\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (cachedTimestamp !== undefined) {\n\t\t\tthis.contextHashQueue.add(path, (err, entry) => {\n\t\t\t\tif (err) return callback(err);\n\t\t\t\tfinalize(cachedTimestamp, /** @type {ContextHash} */ (entry));\n\t\t\t});\n\t\t} else {\n\t\t\tthis._readContext(\n\t\t\t\t{\n\t\t\t\t\tpath,\n\t\t\t\t\tfromImmutablePath: () => null,\n\t\t\t\t\tfromManagedItem: info => ({\n\t\t\t\t\t\tsafeTime: 0,\n\t\t\t\t\t\ttimestampHash: info,\n\t\t\t\t\t\thash: info || \"\"\n\t\t\t\t\t}),\n\t\t\t\t\tfromSymlink: (file, target, callback) => {\n\t\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\t\ttimestampHash: target,\n\t\t\t\t\t\t\thash: target,\n\t\t\t\t\t\t\tsymlinks: new Set([target])\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\tfromFile: (file, stat, callback) => {\n\t\t\t\t\t\tthis._getFileTimestampAndHash(file, callback);\n\t\t\t\t\t},\n\t\t\t\t\tfromDirectory: (directory, stat, callback) => {\n\t\t\t\t\t\tthis.contextTshQueue.increaseParallelism();\n\t\t\t\t\t\tthis.contextTshQueue.add(directory, (err, result) => {\n\t\t\t\t\t\t\tthis.contextTshQueue.decreaseParallelism();\n\t\t\t\t\t\t\tcallback(err, result);\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {string[]} files files\n\t\t\t\t\t * @param {(Partial<TimestampAndHash> & Partial<ContextTimestampAndHash> | string | null)[]} results results\n\t\t\t\t\t * @returns {ContextTimestampAndHash} tsh\n\t\t\t\t\t */\n\t\t\t\t\treduce: (files, results) => {\n\t\t\t\t\t\tlet symlinks;\n\n\t\t\t\t\t\tconst tsHash = createHash(this._hashFunction);\n\t\t\t\t\t\tconst hash = createHash(this._hashFunction);\n\n\t\t\t\t\t\tfor (const file of files) {\n\t\t\t\t\t\t\ttsHash.update(file);\n\t\t\t\t\t\t\thash.update(file);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet safeTime = 0;\n\t\t\t\t\t\tfor (const entry of results) {\n\t\t\t\t\t\t\tif (!entry) {\n\t\t\t\t\t\t\t\ttsHash.update(\"n\");\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (typeof entry === \"string\") {\n\t\t\t\t\t\t\t\ttsHash.update(\"n\");\n\t\t\t\t\t\t\t\thash.update(entry);\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (entry.timestamp) {\n\t\t\t\t\t\t\t\ttsHash.update(\"f\");\n\t\t\t\t\t\t\t\ttsHash.update(`${entry.timestamp}`);\n\t\t\t\t\t\t\t} else if (entry.timestampHash) {\n\t\t\t\t\t\t\t\ttsHash.update(\"d\");\n\t\t\t\t\t\t\t\ttsHash.update(`${entry.timestampHash}`);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (entry.symlinks !== undefined) {\n\t\t\t\t\t\t\t\tif (symlinks === undefined) symlinks = new Set();\n\t\t\t\t\t\t\t\taddAll(entry.symlinks, symlinks);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thash.update(/** @type {string} */ (entry.hash));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/** @type {ContextTimestampAndHash} */\n\t\t\t\t\t\tconst result = {\n\t\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\t\ttimestampHash: /** @type {string} */ (tsHash.digest(\"hex\")),\n\t\t\t\t\t\t\thash: /** @type {string} */ (hash.digest(\"hex\"))\n\t\t\t\t\t\t};\n\t\t\t\t\t\tif (symlinks) result.symlinks = symlinks;\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t(err, _result) => {\n\t\t\t\t\tif (err) return callback(/** @type {WebpackError} */ (err));\n\t\t\t\t\tconst result = /** @type {ContextTimestampAndHash} */ (_result);\n\t\t\t\t\tthis._contextTshs.set(path, result);\n\t\t\t\t\treturn callback(null, result);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @param {ContextTimestampAndHash} entry entry\n\t * @param {ProcessorCallback<ResolvedContextTimestampAndHash>} callback callback\n\t * @returns {void}\n\t */\n\t_resolveContextTsh(entry, callback) {\n\t\t/** @type {string[]} */\n\t\tconst hashes = [];\n\t\t/** @type {string[]} */\n\t\tconst tsHashes = [];\n\t\tlet safeTime = 0;\n\t\tprocessAsyncTree(\n\t\t\t/** @type {NonNullable<ContextHash[\"symlinks\"]>} */ (entry.symlinks),\n\t\t\t10,\n\t\t\t(target, push, callback) => {\n\t\t\t\tthis._getUnresolvedContextTsh(target, (err, entry) => {\n\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\tif (entry) {\n\t\t\t\t\t\thashes.push(entry.hash);\n\t\t\t\t\t\tif (entry.timestampHash) tsHashes.push(entry.timestampHash);\n\t\t\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (entry.symlinks !== undefined) {\n\t\t\t\t\t\t\tfor (const target of entry.symlinks) push(target);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcallback();\n\t\t\t\t});\n\t\t\t},\n\t\t\terr => {\n\t\t\t\tif (err) return callback(/** @type {WebpackError} */ (err));\n\t\t\t\tconst hash = createHash(this._hashFunction);\n\t\t\t\tconst tsHash = createHash(this._hashFunction);\n\t\t\t\thash.update(entry.hash);\n\t\t\t\tif (entry.timestampHash) tsHash.update(entry.timestampHash);\n\t\t\t\tif (entry.safeTime) {\n\t\t\t\t\tsafeTime = Math.max(safeTime, entry.safeTime);\n\t\t\t\t}\n\t\t\t\thashes.sort();\n\t\t\t\tfor (const h of hashes) {\n\t\t\t\t\thash.update(h);\n\t\t\t\t}\n\t\t\t\ttsHashes.sort();\n\t\t\t\tfor (const h of tsHashes) {\n\t\t\t\t\ttsHash.update(h);\n\t\t\t\t}\n\t\t\t\tcallback(\n\t\t\t\t\tnull,\n\t\t\t\t\t(entry.resolved = {\n\t\t\t\t\t\tsafeTime,\n\t\t\t\t\t\ttimestampHash: /** @type {string} */ (tsHash.digest(\"hex\")),\n\t\t\t\t\t\thash: /** @type {string} */ (hash.digest(\"hex\"))\n\t\t\t\t\t})\n\t\t\t\t);\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * @type {Processor<string, Set<string>>}\n\t * @private\n\t */\n\t_getManagedItemDirectoryInfo(path, callback) {\n\t\tthis.fs.readdir(path, (err, elements) => {\n\t\t\tif (err) {\n\t\t\t\tif (err.code === \"ENOENT\" || err.code === \"ENOTDIR\") {\n\t\t\t\t\treturn callback(null, EMPTY_SET);\n\t\t\t\t}\n\t\t\t\treturn callback(/** @type {WebpackError} */ (err));\n\t\t\t}\n\t\t\tconst set = new Set(\n\t\t\t\t/** @type {string[]} */ (elements).map(element =>\n\t\t\t\t\tjoin(this.fs, path, element)\n\t\t\t\t)\n\t\t\t);\n\t\t\tcallback(null, set);\n\t\t});\n\t}\n\n\t/**\n\t * @type {Processor<string, string>}\n\t * @private\n\t */\n\t_getManagedItemInfo(path, callback) {\n\t\tconst dir = dirname(this.fs, path);\n\t\tthis.managedItemDirectoryQueue.add(dir, (err, elements) => {\n\t\t\tif (err) {\n\t\t\t\treturn callback(err);\n\t\t\t}\n\t\t\tif (!(/** @type {Set<string>} */ (elements).has(path))) {\n\t\t\t\t// file or directory doesn't exist\n\t\t\t\tthis._managedItems.set(path, \"*missing\");\n\t\t\t\treturn callback(null, \"*missing\");\n\t\t\t}\n\t\t\t// something exists\n\t\t\t// it may be a file or directory\n\t\t\tif (\n\t\t\t\tpath.endsWith(\"node_modules\") &&\n\t\t\t\t(path.endsWith(\"/node_modules\") || path.endsWith(\"\\\\node_modules\"))\n\t\t\t) {\n\t\t\t\t// we are only interested in existence of this special directory\n\t\t\t\tthis._managedItems.set(path, \"*node_modules\");\n\t\t\t\treturn callback(null, \"*node_modules\");\n\t\t\t}\n\n\t\t\t// we assume it's a directory, as files shouldn't occur in managed paths\n\t\t\tconst packageJsonPath = join(this.fs, path, \"package.json\");\n\t\t\tthis.fs.readFile(packageJsonPath, (err, content) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (err.code === \"ENOENT\" || err.code === \"ENOTDIR\") {\n\t\t\t\t\t\t// no package.json or path is not a directory\n\t\t\t\t\t\tthis.fs.readdir(path, (err, elements) => {\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t!err &&\n\t\t\t\t\t\t\t\t/** @type {string[]} */ (elements).length === 1 &&\n\t\t\t\t\t\t\t\t/** @type {string[]} */ (elements)[0] === \"node_modules\"\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t// This is only a grouping folder e.g. used by yarn\n\t\t\t\t\t\t\t\t// we are only interested in existence of this special directory\n\t\t\t\t\t\t\t\tthis._managedItems.set(path, \"*nested\");\n\t\t\t\t\t\t\t\treturn callback(null, \"*nested\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t/** @type {Logger} */\n\t\t\t\t\t\t\t(this.logger).warn(\n\t\t\t\t\t\t\t\t`Managed item ${path} isn't a directory or doesn't contain a package.json (see snapshot.managedPaths option)`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\treturn callback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn callback(/** @type {WebpackError} */ (err));\n\t\t\t\t}\n\t\t\t\tlet data;\n\t\t\t\ttry {\n\t\t\t\t\tdata = JSON.parse(/** @type {Buffer} */ (content).toString(\"utf-8\"));\n\t\t\t\t} catch (parseErr) {\n\t\t\t\t\treturn callback(/** @type {WebpackError} */ (parseErr));\n\t\t\t\t}\n\t\t\t\tif (!data.name) {\n\t\t\t\t\t/** @type {Logger} */\n\t\t\t\t\t(this.logger).warn(\n\t\t\t\t\t\t`${packageJsonPath} doesn't contain a \"name\" property (see snapshot.managedPaths option)`\n\t\t\t\t\t);\n\t\t\t\t\treturn callback();\n\t\t\t\t}\n\t\t\t\tconst info = `${data.name || \"\"}@${data.version || \"\"}`;\n\t\t\t\tthis._managedItems.set(path, info);\n\t\t\t\tcallback(null, info);\n\t\t\t});\n\t\t});\n\t}\n\n\tgetDeprecatedFileTimestamps() {\n\t\tif (this._cachedDeprecatedFileTimestamps !== undefined)\n\t\t\treturn this._cachedDeprecatedFileTimestamps;\n\t\tconst map = new Map();\n\t\tfor (const [path, info] of this._fileTimestamps) {\n\t\t\tif (info) map.set(path, typeof info === \"object\" ? info.safeTime : null);\n\t\t}\n\t\treturn (this._cachedDeprecatedFileTimestamps = map);\n\t}\n\n\tgetDeprecatedContextTimestamps() {\n\t\tif (this._cachedDeprecatedContextTimestamps !== undefined)\n\t\t\treturn this._cachedDeprecatedContextTimestamps;\n\t\tconst map = new Map();\n\t\tfor (const [path, info] of this._contextTimestamps) {\n\t\t\tif (info) map.set(path, typeof info === \"object\" ? info.safeTime : null);\n\t\t}\n\t\treturn (this._cachedDeprecatedContextTimestamps = map);\n\t}\n}\n\nmodule.exports = FileSystemInfo;\nmodule.exports.Snapshot = Snapshot;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}