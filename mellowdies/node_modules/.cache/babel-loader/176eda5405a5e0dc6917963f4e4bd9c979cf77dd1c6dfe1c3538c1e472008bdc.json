{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst {\n  SyncHook,\n  MultiHook\n} = require(\"tapable\");\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nconst MultiStats = require(\"./MultiStats\");\nconst MultiWatching = require(\"./MultiWatching\");\nconst WebpackError = require(\"./WebpackError\");\nconst ArrayQueue = require(\"./util/ArrayQueue\");\n\n/** @template T @typedef {import(\"tapable\").AsyncSeriesHook<T>} AsyncSeriesHook<T> */\n/** @template T @template R @typedef {import(\"tapable\").SyncBailHook<T, R>} SyncBailHook<T, R> */\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Stats\")} Stats */\n/** @typedef {import(\"./Watching\")} Watching */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @template T\n * @callback Callback\n * @param {Error | null} err\n * @param {T=} result\n */\n\n/**\n * @callback RunWithDependenciesHandler\n * @param {Compiler} compiler\n * @param {Callback<MultiStats>} callback\n */\n\n/**\n * @typedef {object} MultiCompilerOptions\n * @property {number=} parallelism how many Compilers are allows to run at the same time in parallel\n */\n\nmodule.exports = class MultiCompiler {\n  /**\n   * @param {Compiler[] | Record<string, Compiler>} compilers child compilers\n   * @param {MultiCompilerOptions} options options\n   */\n  constructor(compilers, options) {\n    if (!Array.isArray(compilers)) {\n      /** @type {Compiler[]} */\n      compilers = Object.keys(compilers).map(name => {\n        /** @type {Record<string, Compiler>} */\n        compilers[name].name = name;\n        return /** @type {Record<string, Compiler>} */compilers[name];\n      });\n    }\n    this.hooks = Object.freeze({\n      /** @type {SyncHook<[MultiStats]>} */\n      done: new SyncHook([\"stats\"]),\n      /** @type {MultiHook<SyncHook<[string | null, number]>>} */\n      invalid: new MultiHook(compilers.map(c => c.hooks.invalid)),\n      /** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n      run: new MultiHook(compilers.map(c => c.hooks.run)),\n      /** @type {SyncHook<[]>} */\n      watchClose: new SyncHook([]),\n      /** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n      watchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),\n      /** @type {MultiHook<SyncBailHook<[string, string, any[]], true>>} */\n      infrastructureLog: new MultiHook(compilers.map(c => c.hooks.infrastructureLog))\n    });\n    this.compilers = compilers;\n    /** @type {MultiCompilerOptions} */\n    this._options = {\n      parallelism: options.parallelism || Infinity\n    };\n    /** @type {WeakMap<Compiler, string[]>} */\n    this.dependencies = new WeakMap();\n    this.running = false;\n\n    /** @type {(Stats | null)[]} */\n    const compilerStats = this.compilers.map(() => null);\n    let doneCompilers = 0;\n    for (let index = 0; index < this.compilers.length; index++) {\n      const compiler = this.compilers[index];\n      const compilerIndex = index;\n      let compilerDone = false;\n      // eslint-disable-next-line no-loop-func\n      compiler.hooks.done.tap(\"MultiCompiler\", stats => {\n        if (!compilerDone) {\n          compilerDone = true;\n          doneCompilers++;\n        }\n        compilerStats[compilerIndex] = stats;\n        if (doneCompilers === this.compilers.length) {\n          this.hooks.done.call(new MultiStats(/** @type {Stats[]} */compilerStats));\n        }\n      });\n      // eslint-disable-next-line no-loop-func\n      compiler.hooks.invalid.tap(\"MultiCompiler\", () => {\n        if (compilerDone) {\n          compilerDone = false;\n          doneCompilers--;\n        }\n      });\n    }\n    this._validateCompilersOptions();\n  }\n  _validateCompilersOptions() {\n    if (this.compilers.length < 2) return;\n    /**\n     * @param {Compiler} compiler compiler\n     * @param {WebpackError} warning warning\n     */\n    const addWarning = (compiler, warning) => {\n      compiler.hooks.thisCompilation.tap(\"MultiCompiler\", compilation => {\n        compilation.warnings.push(warning);\n      });\n    };\n    const cacheNames = new Set();\n    for (const compiler of this.compilers) {\n      if (compiler.options.cache && \"name\" in compiler.options.cache) {\n        const name = compiler.options.cache.name;\n        if (cacheNames.has(name)) {\n          addWarning(compiler, new WebpackError(`${compiler.name ? `Compiler with name \"${compiler.name}\" doesn't use unique cache name. ` : \"\"}Please set unique \"cache.name\" option. Name \"${name}\" already used.`));\n        } else {\n          cacheNames.add(name);\n        }\n      }\n    }\n  }\n  get options() {\n    return Object.assign(this.compilers.map(c => c.options), this._options);\n  }\n  get outputPath() {\n    let commonPath = this.compilers[0].outputPath;\n    for (const compiler of this.compilers) {\n      while (compiler.outputPath.indexOf(commonPath) !== 0 && /[/\\\\]/.test(commonPath)) {\n        commonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n      }\n    }\n    if (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n    return commonPath;\n  }\n  get inputFileSystem() {\n    throw new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n  }\n\n  /**\n   * @param {InputFileSystem} value the new input file system\n   */\n  set inputFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.inputFileSystem = value;\n    }\n  }\n  get outputFileSystem() {\n    throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n  }\n\n  /**\n   * @param {OutputFileSystem} value the new output file system\n   */\n  set outputFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.outputFileSystem = value;\n    }\n  }\n  get watchFileSystem() {\n    throw new Error(\"Cannot read watchFileSystem of a MultiCompiler\");\n  }\n\n  /**\n   * @param {WatchFileSystem} value the new watch file system\n   */\n  set watchFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.watchFileSystem = value;\n    }\n  }\n\n  /**\n   * @param {IntermediateFileSystem} value the new intermediate file system\n   */\n  set intermediateFileSystem(value) {\n    for (const compiler of this.compilers) {\n      compiler.intermediateFileSystem = value;\n    }\n  }\n  get intermediateFileSystem() {\n    throw new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n  }\n\n  /**\n   * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n   * @returns {Logger} a logger with that name\n   */\n  getInfrastructureLogger(name) {\n    return this.compilers[0].getInfrastructureLogger(name);\n  }\n\n  /**\n   * @param {Compiler} compiler the child compiler\n   * @param {string[]} dependencies its dependencies\n   * @returns {void}\n   */\n  setDependencies(compiler, dependencies) {\n    this.dependencies.set(compiler, dependencies);\n  }\n\n  /**\n   * @param {Callback<MultiStats>} callback signals when the validation is complete\n   * @returns {boolean} true if the dependencies are valid\n   */\n  validateDependencies(callback) {\n    /** @type {Set<{source: Compiler, target: Compiler}>} */\n    const edges = new Set();\n    /** @type {string[]} */\n    const missing = [];\n    /**\n     * @param {Compiler} compiler compiler\n     * @returns {boolean} target was found\n     */\n    const targetFound = compiler => {\n      for (const edge of edges) {\n        if (edge.target === compiler) {\n          return true;\n        }\n      }\n      return false;\n    };\n    /**\n     * @param {{source: Compiler, target: Compiler}} e1 edge 1\n     * @param {{source: Compiler, target: Compiler}} e2 edge 2\n     * @returns {number} result\n     */\n    const sortEdges = (e1, e2) => /** @type {string} */\n    e1.source.name.localeCompare(/** @type {string} */e2.source.name) || /** @type {string} */\n    e1.target.name.localeCompare(/** @type {string} */e2.target.name);\n    for (const source of this.compilers) {\n      const dependencies = this.dependencies.get(source);\n      if (dependencies) {\n        for (const dep of dependencies) {\n          const target = this.compilers.find(c => c.name === dep);\n          if (!target) {\n            missing.push(dep);\n          } else {\n            edges.add({\n              source,\n              target\n            });\n          }\n        }\n      }\n    }\n    /** @type {string[]} */\n    const errors = missing.map(m => `Compiler dependency \\`${m}\\` not found.`);\n    const stack = this.compilers.filter(c => !targetFound(c));\n    while (stack.length > 0) {\n      const current = stack.pop();\n      for (const edge of edges) {\n        if (edge.source === current) {\n          edges.delete(edge);\n          const target = edge.target;\n          if (!targetFound(target)) {\n            stack.push(target);\n          }\n        }\n      }\n    }\n    if (edges.size > 0) {\n      /** @type {string[]} */\n      const lines = Array.from(edges).sort(sortEdges).map(edge => `${edge.source.name} -> ${edge.target.name}`);\n      lines.unshift(\"Circular dependency found in compiler dependencies.\");\n      errors.unshift(lines.join(\"\\n\"));\n    }\n    if (errors.length > 0) {\n      const message = errors.join(\"\\n\");\n      callback(new Error(message));\n      return false;\n    }\n    return true;\n  }\n\n  // TODO webpack 6 remove\n  /**\n   * @deprecated This method should have been private\n   * @param {Compiler[]} compilers the child compilers\n   * @param {RunWithDependenciesHandler} fn a handler to run for each compiler\n   * @param {Callback<MultiStats>} callback the compiler's handler\n   * @returns {void}\n   */\n  runWithDependencies(compilers, fn, callback) {\n    const fulfilledNames = new Set();\n    let remainingCompilers = compilers;\n    /**\n     * @param {string} d dependency\n     * @returns {boolean} when dependency was fulfilled\n     */\n    const isDependencyFulfilled = d => fulfilledNames.has(d);\n    /**\n     * @returns {Compiler[]} compilers\n     */\n    const getReadyCompilers = () => {\n      const readyCompilers = [];\n      const list = remainingCompilers;\n      remainingCompilers = [];\n      for (const c of list) {\n        const dependencies = this.dependencies.get(c);\n        const ready = !dependencies || dependencies.every(isDependencyFulfilled);\n        if (ready) {\n          readyCompilers.push(c);\n        } else {\n          remainingCompilers.push(c);\n        }\n      }\n      return readyCompilers;\n    };\n    /**\n     * @param {Callback<MultiStats>} callback callback\n     * @returns {void}\n     */\n    const runCompilers = callback => {\n      if (remainingCompilers.length === 0) return callback(null);\n      asyncLib.map(getReadyCompilers(), (compiler, callback) => {\n        fn(compiler, err => {\n          if (err) return callback(err);\n          fulfilledNames.add(compiler.name);\n          runCompilers(callback);\n        });\n      }, (err, results) => {\n        callback(err, /** @type {TODO} */results);\n      });\n    };\n    runCompilers(callback);\n  }\n\n  /**\n   * @template SetupResult\n   * @param {function(Compiler, number, Callback<Stats>, function(): boolean, function(): void, function(): void): SetupResult} setup setup a single compiler\n   * @param {function(Compiler, SetupResult, Callback<Stats>): void} run run/continue a single compiler\n   * @param {Callback<MultiStats>} callback callback when all compilers are done, result includes Stats of all changed compilers\n   * @returns {SetupResult[]} result of setup\n   */\n  _runGraph(setup, run, callback) {\n    /** @typedef {{ compiler: Compiler, setupResult: undefined | SetupResult, result: undefined | Stats, state: \"pending\" | \"blocked\" | \"queued\" | \"starting\" | \"running\" | \"running-outdated\" | \"done\", children: Node[], parents: Node[] }} Node */\n\n    // State transitions for nodes:\n    // -> blocked (initial)\n    // blocked -> starting [running++] (when all parents done)\n    // queued -> starting [running++] (when processing the queue)\n    // starting -> running (when run has been called)\n    // running -> done [running--] (when compilation is done)\n    // done -> pending (when invalidated from file change)\n    // pending -> blocked [add to queue] (when invalidated from aggregated changes)\n    // done -> blocked [add to queue] (when invalidated, from parent invalidation)\n    // running -> running-outdated (when invalidated, either from change or parent invalidation)\n    // running-outdated -> blocked [running--] (when compilation is done)\n\n    /** @type {Node[]} */\n    const nodes = this.compilers.map(compiler => ({\n      compiler,\n      setupResult: undefined,\n      result: undefined,\n      state: \"blocked\",\n      children: [],\n      parents: []\n    }));\n    /** @type {Map<string, Node>} */\n    const compilerToNode = new Map();\n    for (const node of nodes) {\n      compilerToNode.set(/** @type {string} */node.compiler.name, node);\n    }\n    for (const node of nodes) {\n      const dependencies = this.dependencies.get(node.compiler);\n      if (!dependencies) continue;\n      for (const dep of dependencies) {\n        const parent = /** @type {Node} */compilerToNode.get(dep);\n        node.parents.push(parent);\n        parent.children.push(node);\n      }\n    }\n    /** @type {ArrayQueue<Node>} */\n    const queue = new ArrayQueue();\n    for (const node of nodes) {\n      if (node.parents.length === 0) {\n        node.state = \"queued\";\n        queue.enqueue(node);\n      }\n    }\n    let errored = false;\n    let running = 0;\n    const parallelism = /** @type {number} */this._options.parallelism;\n    /**\n     * @param {Node} node node\n     * @param {(Error | null)=} err error\n     * @param {Stats=} stats result\n     * @returns {void}\n     */\n    const nodeDone = (node, err, stats) => {\n      if (errored) return;\n      if (err) {\n        errored = true;\n        return asyncLib.each(nodes, (node, callback) => {\n          if (node.compiler.watching) {\n            node.compiler.watching.close(callback);\n          } else {\n            callback();\n          }\n        }, () => callback(err));\n      }\n      node.result = stats;\n      running--;\n      if (node.state === \"running\") {\n        node.state = \"done\";\n        for (const child of node.children) {\n          if (child.state === \"blocked\") queue.enqueue(child);\n        }\n      } else if (node.state === \"running-outdated\") {\n        node.state = \"blocked\";\n        queue.enqueue(node);\n      }\n      processQueue();\n    };\n    /**\n     * @param {Node} node node\n     * @returns {void}\n     */\n    const nodeInvalidFromParent = node => {\n      if (node.state === \"done\") {\n        node.state = \"blocked\";\n      } else if (node.state === \"running\") {\n        node.state = \"running-outdated\";\n      }\n      for (const child of node.children) {\n        nodeInvalidFromParent(child);\n      }\n    };\n    /**\n     * @param {Node} node node\n     * @returns {void}\n     */\n    const nodeInvalid = node => {\n      if (node.state === \"done\") {\n        node.state = \"pending\";\n      } else if (node.state === \"running\") {\n        node.state = \"running-outdated\";\n      }\n      for (const child of node.children) {\n        nodeInvalidFromParent(child);\n      }\n    };\n    /**\n     * @param {Node} node node\n     * @returns {void}\n     */\n    const nodeChange = node => {\n      nodeInvalid(node);\n      if (node.state === \"pending\") {\n        node.state = \"blocked\";\n      }\n      if (node.state === \"blocked\") {\n        queue.enqueue(node);\n        processQueue();\n      }\n    };\n\n    /** @type {SetupResult[]} */\n    const setupResults = [];\n    for (const [i, node] of nodes.entries()) {\n      setupResults.push(node.setupResult = setup(node.compiler, i, nodeDone.bind(null, node), () => node.state !== \"starting\" && node.state !== \"running\", () => nodeChange(node), () => nodeInvalid(node)));\n    }\n    let processing = true;\n    const processQueue = () => {\n      if (processing) return;\n      processing = true;\n      process.nextTick(processQueueWorker);\n    };\n    const processQueueWorker = () => {\n      // eslint-disable-next-line no-unmodified-loop-condition\n      while (running < parallelism && queue.length > 0 && !errored) {\n        const node = /** @type {Node} */queue.dequeue();\n        if (node.state === \"queued\" || node.state === \"blocked\" && node.parents.every(p => p.state === \"done\")) {\n          running++;\n          node.state = \"starting\";\n          run(node.compiler, /** @type {SetupResult} */node.setupResult, nodeDone.bind(null, node));\n          node.state = \"running\";\n        }\n      }\n      processing = false;\n      if (!errored && running === 0 && nodes.every(node => node.state === \"done\")) {\n        const stats = [];\n        for (const node of nodes) {\n          const result = node.result;\n          if (result) {\n            node.result = undefined;\n            stats.push(result);\n          }\n        }\n        if (stats.length > 0) {\n          callback(null, new MultiStats(stats));\n        }\n      }\n    };\n    processQueueWorker();\n    return setupResults;\n  }\n\n  /**\n   * @param {WatchOptions|WatchOptions[]} watchOptions the watcher's options\n   * @param {Callback<MultiStats>} handler signals when the call finishes\n   * @returns {MultiWatching} a compiler watcher\n   */\n  watch(watchOptions, handler) {\n    if (this.running) {\n      return handler(new ConcurrentCompilationError());\n    }\n    this.running = true;\n    if (this.validateDependencies(handler)) {\n      const watchings = this._runGraph((compiler, idx, callback, isBlocked, setChanged, setInvalid) => {\n        const watching = compiler.watch(Array.isArray(watchOptions) ? watchOptions[idx] : watchOptions, callback);\n        if (watching) {\n          watching._onInvalid = setInvalid;\n          watching._onChange = setChanged;\n          watching._isBlocked = isBlocked;\n        }\n        return watching;\n      }, (compiler, watching, callback) => {\n        if (compiler.watching !== watching) return;\n        if (!watching.running) watching.invalidate();\n      }, handler);\n      return new MultiWatching(watchings, this);\n    }\n    return new MultiWatching([], this);\n  }\n\n  /**\n   * @param {Callback<MultiStats>} callback signals when the call finishes\n   * @returns {void}\n   */\n  run(callback) {\n    if (this.running) {\n      return callback(new ConcurrentCompilationError());\n    }\n    this.running = true;\n    if (this.validateDependencies(callback)) {\n      this._runGraph(() => {}, (compiler, setupResult, callback) => compiler.run(callback), (err, stats) => {\n        this.running = false;\n        if (callback !== undefined) {\n          return callback(err, stats);\n        }\n      });\n    }\n  }\n  purgeInputFileSystem() {\n    for (const compiler of this.compilers) {\n      if (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n        compiler.inputFileSystem.purge();\n      }\n    }\n  }\n\n  /**\n   * @param {Callback<void>} callback signals when the compiler closes\n   * @returns {void}\n   */\n  close(callback) {\n    asyncLib.each(this.compilers, (compiler, callback) => {\n      compiler.close(callback);\n    }, error => {\n      callback(error);\n    });\n  }\n};","map":{"version":3,"names":["asyncLib","require","SyncHook","MultiHook","ConcurrentCompilationError","MultiStats","MultiWatching","WebpackError","ArrayQueue","module","exports","MultiCompiler","constructor","compilers","options","Array","isArray","Object","keys","map","name","hooks","freeze","done","invalid","c","run","watchClose","watchRun","infrastructureLog","_options","parallelism","Infinity","dependencies","WeakMap","running","compilerStats","doneCompilers","index","length","compiler","compilerIndex","compilerDone","tap","stats","call","_validateCompilersOptions","addWarning","warning","thisCompilation","compilation","warnings","push","cacheNames","Set","cache","has","add","assign","outputPath","commonPath","indexOf","test","replace","inputFileSystem","Error","value","outputFileSystem","watchFileSystem","intermediateFileSystem","getInfrastructureLogger","setDependencies","set","validateDependencies","callback","edges","missing","targetFound","edge","target","sortEdges","e1","e2","source","localeCompare","get","dep","find","errors","m","stack","filter","current","pop","delete","size","lines","from","sort","unshift","join","message","runWithDependencies","fn","fulfilledNames","remainingCompilers","isDependencyFulfilled","d","getReadyCompilers","readyCompilers","list","ready","every","runCompilers","err","results","_runGraph","setup","nodes","setupResult","undefined","result","state","children","parents","compilerToNode","Map","node","parent","queue","enqueue","errored","nodeDone","each","watching","close","child","processQueue","nodeInvalidFromParent","nodeInvalid","nodeChange","setupResults","i","entries","bind","processing","process","nextTick","processQueueWorker","dequeue","p","watch","watchOptions","handler","watchings","idx","isBlocked","setChanged","setInvalid","_onInvalid","_onChange","_isBlocked","invalidate","purgeInputFileSystem","purge","error"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/webpack/lib/MultiCompiler.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst { SyncHook, MultiHook } = require(\"tapable\");\n\nconst ConcurrentCompilationError = require(\"./ConcurrentCompilationError\");\nconst MultiStats = require(\"./MultiStats\");\nconst MultiWatching = require(\"./MultiWatching\");\nconst WebpackError = require(\"./WebpackError\");\nconst ArrayQueue = require(\"./util/ArrayQueue\");\n\n/** @template T @typedef {import(\"tapable\").AsyncSeriesHook<T>} AsyncSeriesHook<T> */\n/** @template T @template R @typedef {import(\"tapable\").SyncBailHook<T, R>} SyncBailHook<T, R> */\n/** @typedef {import(\"../declarations/WebpackOptions\").WatchOptions} WatchOptions */\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Stats\")} Stats */\n/** @typedef {import(\"./Watching\")} Watching */\n/** @typedef {import(\"./logging/Logger\").Logger} Logger */\n/** @typedef {import(\"./util/fs\").InputFileSystem} InputFileSystem */\n/** @typedef {import(\"./util/fs\").IntermediateFileSystem} IntermediateFileSystem */\n/** @typedef {import(\"./util/fs\").OutputFileSystem} OutputFileSystem */\n/** @typedef {import(\"./util/fs\").WatchFileSystem} WatchFileSystem */\n\n/**\n * @template T\n * @callback Callback\n * @param {Error | null} err\n * @param {T=} result\n */\n\n/**\n * @callback RunWithDependenciesHandler\n * @param {Compiler} compiler\n * @param {Callback<MultiStats>} callback\n */\n\n/**\n * @typedef {object} MultiCompilerOptions\n * @property {number=} parallelism how many Compilers are allows to run at the same time in parallel\n */\n\nmodule.exports = class MultiCompiler {\n\t/**\n\t * @param {Compiler[] | Record<string, Compiler>} compilers child compilers\n\t * @param {MultiCompilerOptions} options options\n\t */\n\tconstructor(compilers, options) {\n\t\tif (!Array.isArray(compilers)) {\n\t\t\t/** @type {Compiler[]} */\n\t\t\tcompilers = Object.keys(compilers).map(name => {\n\t\t\t\t/** @type {Record<string, Compiler>} */\n\t\t\t\t(compilers)[name].name = name;\n\t\t\t\treturn /** @type {Record<string, Compiler>} */ (compilers)[name];\n\t\t\t});\n\t\t}\n\n\t\tthis.hooks = Object.freeze({\n\t\t\t/** @type {SyncHook<[MultiStats]>} */\n\t\t\tdone: new SyncHook([\"stats\"]),\n\t\t\t/** @type {MultiHook<SyncHook<[string | null, number]>>} */\n\t\t\tinvalid: new MultiHook(compilers.map(c => c.hooks.invalid)),\n\t\t\t/** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n\t\t\trun: new MultiHook(compilers.map(c => c.hooks.run)),\n\t\t\t/** @type {SyncHook<[]>} */\n\t\t\twatchClose: new SyncHook([]),\n\t\t\t/** @type {MultiHook<AsyncSeriesHook<[Compiler]>>} */\n\t\t\twatchRun: new MultiHook(compilers.map(c => c.hooks.watchRun)),\n\t\t\t/** @type {MultiHook<SyncBailHook<[string, string, any[]], true>>} */\n\t\t\tinfrastructureLog: new MultiHook(\n\t\t\t\tcompilers.map(c => c.hooks.infrastructureLog)\n\t\t\t)\n\t\t});\n\t\tthis.compilers = compilers;\n\t\t/** @type {MultiCompilerOptions} */\n\t\tthis._options = {\n\t\t\tparallelism: options.parallelism || Infinity\n\t\t};\n\t\t/** @type {WeakMap<Compiler, string[]>} */\n\t\tthis.dependencies = new WeakMap();\n\t\tthis.running = false;\n\n\t\t/** @type {(Stats | null)[]} */\n\t\tconst compilerStats = this.compilers.map(() => null);\n\t\tlet doneCompilers = 0;\n\t\tfor (let index = 0; index < this.compilers.length; index++) {\n\t\t\tconst compiler = this.compilers[index];\n\t\t\tconst compilerIndex = index;\n\t\t\tlet compilerDone = false;\n\t\t\t// eslint-disable-next-line no-loop-func\n\t\t\tcompiler.hooks.done.tap(\"MultiCompiler\", stats => {\n\t\t\t\tif (!compilerDone) {\n\t\t\t\t\tcompilerDone = true;\n\t\t\t\t\tdoneCompilers++;\n\t\t\t\t}\n\t\t\t\tcompilerStats[compilerIndex] = stats;\n\t\t\t\tif (doneCompilers === this.compilers.length) {\n\t\t\t\t\tthis.hooks.done.call(\n\t\t\t\t\t\tnew MultiStats(/** @type {Stats[]} */ (compilerStats))\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t});\n\t\t\t// eslint-disable-next-line no-loop-func\n\t\t\tcompiler.hooks.invalid.tap(\"MultiCompiler\", () => {\n\t\t\t\tif (compilerDone) {\n\t\t\t\t\tcompilerDone = false;\n\t\t\t\t\tdoneCompilers--;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tthis._validateCompilersOptions();\n\t}\n\n\t_validateCompilersOptions() {\n\t\tif (this.compilers.length < 2) return;\n\t\t/**\n\t\t * @param {Compiler} compiler compiler\n\t\t * @param {WebpackError} warning warning\n\t\t */\n\t\tconst addWarning = (compiler, warning) => {\n\t\t\tcompiler.hooks.thisCompilation.tap(\"MultiCompiler\", compilation => {\n\t\t\t\tcompilation.warnings.push(warning);\n\t\t\t});\n\t\t};\n\t\tconst cacheNames = new Set();\n\t\tfor (const compiler of this.compilers) {\n\t\t\tif (compiler.options.cache && \"name\" in compiler.options.cache) {\n\t\t\t\tconst name = compiler.options.cache.name;\n\t\t\t\tif (cacheNames.has(name)) {\n\t\t\t\t\taddWarning(\n\t\t\t\t\t\tcompiler,\n\t\t\t\t\t\tnew WebpackError(\n\t\t\t\t\t\t\t`${\n\t\t\t\t\t\t\t\tcompiler.name\n\t\t\t\t\t\t\t\t\t? `Compiler with name \"${compiler.name}\" doesn't use unique cache name. `\n\t\t\t\t\t\t\t\t\t: \"\"\n\t\t\t\t\t\t\t}Please set unique \"cache.name\" option. Name \"${name}\" already used.`\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t} else {\n\t\t\t\t\tcacheNames.add(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget options() {\n\t\treturn Object.assign(\n\t\t\tthis.compilers.map(c => c.options),\n\t\t\tthis._options\n\t\t);\n\t}\n\n\tget outputPath() {\n\t\tlet commonPath = this.compilers[0].outputPath;\n\t\tfor (const compiler of this.compilers) {\n\t\t\twhile (\n\t\t\t\tcompiler.outputPath.indexOf(commonPath) !== 0 &&\n\t\t\t\t/[/\\\\]/.test(commonPath)\n\t\t\t) {\n\t\t\t\tcommonPath = commonPath.replace(/[/\\\\][^/\\\\]*$/, \"\");\n\t\t\t}\n\t\t}\n\n\t\tif (!commonPath && this.compilers[0].outputPath[0] === \"/\") return \"/\";\n\t\treturn commonPath;\n\t}\n\n\tget inputFileSystem() {\n\t\tthrow new Error(\"Cannot read inputFileSystem of a MultiCompiler\");\n\t}\n\n\t/**\n\t * @param {InputFileSystem} value the new input file system\n\t */\n\tset inputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.inputFileSystem = value;\n\t\t}\n\t}\n\n\tget outputFileSystem() {\n\t\tthrow new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n\t}\n\n\t/**\n\t * @param {OutputFileSystem} value the new output file system\n\t */\n\tset outputFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.outputFileSystem = value;\n\t\t}\n\t}\n\n\tget watchFileSystem() {\n\t\tthrow new Error(\"Cannot read watchFileSystem of a MultiCompiler\");\n\t}\n\n\t/**\n\t * @param {WatchFileSystem} value the new watch file system\n\t */\n\tset watchFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.watchFileSystem = value;\n\t\t}\n\t}\n\n\t/**\n\t * @param {IntermediateFileSystem} value the new intermediate file system\n\t */\n\tset intermediateFileSystem(value) {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tcompiler.intermediateFileSystem = value;\n\t\t}\n\t}\n\n\tget intermediateFileSystem() {\n\t\tthrow new Error(\"Cannot read outputFileSystem of a MultiCompiler\");\n\t}\n\n\t/**\n\t * @param {string | (function(): string)} name name of the logger, or function called once to get the logger name\n\t * @returns {Logger} a logger with that name\n\t */\n\tgetInfrastructureLogger(name) {\n\t\treturn this.compilers[0].getInfrastructureLogger(name);\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the child compiler\n\t * @param {string[]} dependencies its dependencies\n\t * @returns {void}\n\t */\n\tsetDependencies(compiler, dependencies) {\n\t\tthis.dependencies.set(compiler, dependencies);\n\t}\n\n\t/**\n\t * @param {Callback<MultiStats>} callback signals when the validation is complete\n\t * @returns {boolean} true if the dependencies are valid\n\t */\n\tvalidateDependencies(callback) {\n\t\t/** @type {Set<{source: Compiler, target: Compiler}>} */\n\t\tconst edges = new Set();\n\t\t/** @type {string[]} */\n\t\tconst missing = [];\n\t\t/**\n\t\t * @param {Compiler} compiler compiler\n\t\t * @returns {boolean} target was found\n\t\t */\n\t\tconst targetFound = compiler => {\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.target === compiler) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\t\t/**\n\t\t * @param {{source: Compiler, target: Compiler}} e1 edge 1\n\t\t * @param {{source: Compiler, target: Compiler}} e2 edge 2\n\t\t * @returns {number} result\n\t\t */\n\t\tconst sortEdges = (e1, e2) =>\n\t\t\t/** @type {string} */\n\t\t\t(e1.source.name).localeCompare(/** @type {string} */ (e2.source.name)) ||\n\t\t\t/** @type {string} */\n\t\t\t(e1.target.name).localeCompare(/** @type {string} */ (e2.target.name));\n\t\tfor (const source of this.compilers) {\n\t\t\tconst dependencies = this.dependencies.get(source);\n\t\t\tif (dependencies) {\n\t\t\t\tfor (const dep of dependencies) {\n\t\t\t\t\tconst target = this.compilers.find(c => c.name === dep);\n\t\t\t\t\tif (!target) {\n\t\t\t\t\t\tmissing.push(dep);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tedges.add({\n\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\ttarget\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/** @type {string[]} */\n\t\tconst errors = missing.map(m => `Compiler dependency \\`${m}\\` not found.`);\n\t\tconst stack = this.compilers.filter(c => !targetFound(c));\n\t\twhile (stack.length > 0) {\n\t\t\tconst current = stack.pop();\n\t\t\tfor (const edge of edges) {\n\t\t\t\tif (edge.source === current) {\n\t\t\t\t\tedges.delete(edge);\n\t\t\t\t\tconst target = edge.target;\n\t\t\t\t\tif (!targetFound(target)) {\n\t\t\t\t\t\tstack.push(target);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (edges.size > 0) {\n\t\t\t/** @type {string[]} */\n\t\t\tconst lines = Array.from(edges)\n\t\t\t\t.sort(sortEdges)\n\t\t\t\t.map(edge => `${edge.source.name} -> ${edge.target.name}`);\n\t\t\tlines.unshift(\"Circular dependency found in compiler dependencies.\");\n\t\t\terrors.unshift(lines.join(\"\\n\"));\n\t\t}\n\t\tif (errors.length > 0) {\n\t\t\tconst message = errors.join(\"\\n\");\n\t\t\tcallback(new Error(message));\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t// TODO webpack 6 remove\n\t/**\n\t * @deprecated This method should have been private\n\t * @param {Compiler[]} compilers the child compilers\n\t * @param {RunWithDependenciesHandler} fn a handler to run for each compiler\n\t * @param {Callback<MultiStats>} callback the compiler's handler\n\t * @returns {void}\n\t */\n\trunWithDependencies(compilers, fn, callback) {\n\t\tconst fulfilledNames = new Set();\n\t\tlet remainingCompilers = compilers;\n\t\t/**\n\t\t * @param {string} d dependency\n\t\t * @returns {boolean} when dependency was fulfilled\n\t\t */\n\t\tconst isDependencyFulfilled = d => fulfilledNames.has(d);\n\t\t/**\n\t\t * @returns {Compiler[]} compilers\n\t\t */\n\t\tconst getReadyCompilers = () => {\n\t\t\tconst readyCompilers = [];\n\t\t\tconst list = remainingCompilers;\n\t\t\tremainingCompilers = [];\n\t\t\tfor (const c of list) {\n\t\t\t\tconst dependencies = this.dependencies.get(c);\n\t\t\t\tconst ready =\n\t\t\t\t\t!dependencies || dependencies.every(isDependencyFulfilled);\n\t\t\t\tif (ready) {\n\t\t\t\t\treadyCompilers.push(c);\n\t\t\t\t} else {\n\t\t\t\t\tremainingCompilers.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn readyCompilers;\n\t\t};\n\t\t/**\n\t\t * @param {Callback<MultiStats>} callback callback\n\t\t * @returns {void}\n\t\t */\n\t\tconst runCompilers = callback => {\n\t\t\tif (remainingCompilers.length === 0) return callback(null);\n\t\t\tasyncLib.map(\n\t\t\t\tgetReadyCompilers(),\n\t\t\t\t(compiler, callback) => {\n\t\t\t\t\tfn(compiler, err => {\n\t\t\t\t\t\tif (err) return callback(err);\n\t\t\t\t\t\tfulfilledNames.add(compiler.name);\n\t\t\t\t\t\trunCompilers(callback);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\t(err, results) => {\n\t\t\t\t\tcallback(err, /** @type {TODO} */ (results));\n\t\t\t\t}\n\t\t\t);\n\t\t};\n\t\trunCompilers(callback);\n\t}\n\n\t/**\n\t * @template SetupResult\n\t * @param {function(Compiler, number, Callback<Stats>, function(): boolean, function(): void, function(): void): SetupResult} setup setup a single compiler\n\t * @param {function(Compiler, SetupResult, Callback<Stats>): void} run run/continue a single compiler\n\t * @param {Callback<MultiStats>} callback callback when all compilers are done, result includes Stats of all changed compilers\n\t * @returns {SetupResult[]} result of setup\n\t */\n\t_runGraph(setup, run, callback) {\n\t\t/** @typedef {{ compiler: Compiler, setupResult: undefined | SetupResult, result: undefined | Stats, state: \"pending\" | \"blocked\" | \"queued\" | \"starting\" | \"running\" | \"running-outdated\" | \"done\", children: Node[], parents: Node[] }} Node */\n\n\t\t// State transitions for nodes:\n\t\t// -> blocked (initial)\n\t\t// blocked -> starting [running++] (when all parents done)\n\t\t// queued -> starting [running++] (when processing the queue)\n\t\t// starting -> running (when run has been called)\n\t\t// running -> done [running--] (when compilation is done)\n\t\t// done -> pending (when invalidated from file change)\n\t\t// pending -> blocked [add to queue] (when invalidated from aggregated changes)\n\t\t// done -> blocked [add to queue] (when invalidated, from parent invalidation)\n\t\t// running -> running-outdated (when invalidated, either from change or parent invalidation)\n\t\t// running-outdated -> blocked [running--] (when compilation is done)\n\n\t\t/** @type {Node[]} */\n\t\tconst nodes = this.compilers.map(compiler => ({\n\t\t\tcompiler,\n\t\t\tsetupResult: undefined,\n\t\t\tresult: undefined,\n\t\t\tstate: \"blocked\",\n\t\t\tchildren: [],\n\t\t\tparents: []\n\t\t}));\n\t\t/** @type {Map<string, Node>} */\n\t\tconst compilerToNode = new Map();\n\t\tfor (const node of nodes) {\n\t\t\tcompilerToNode.set(/** @type {string} */ (node.compiler.name), node);\n\t\t}\n\t\tfor (const node of nodes) {\n\t\t\tconst dependencies = this.dependencies.get(node.compiler);\n\t\t\tif (!dependencies) continue;\n\t\t\tfor (const dep of dependencies) {\n\t\t\t\tconst parent = /** @type {Node} */ (compilerToNode.get(dep));\n\t\t\t\tnode.parents.push(parent);\n\t\t\t\tparent.children.push(node);\n\t\t\t}\n\t\t}\n\t\t/** @type {ArrayQueue<Node>} */\n\t\tconst queue = new ArrayQueue();\n\t\tfor (const node of nodes) {\n\t\t\tif (node.parents.length === 0) {\n\t\t\t\tnode.state = \"queued\";\n\t\t\t\tqueue.enqueue(node);\n\t\t\t}\n\t\t}\n\t\tlet errored = false;\n\t\tlet running = 0;\n\t\tconst parallelism = /** @type {number} */ (this._options.parallelism);\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @param {(Error | null)=} err error\n\t\t * @param {Stats=} stats result\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeDone = (node, err, stats) => {\n\t\t\tif (errored) return;\n\t\t\tif (err) {\n\t\t\t\terrored = true;\n\t\t\t\treturn asyncLib.each(\n\t\t\t\t\tnodes,\n\t\t\t\t\t(node, callback) => {\n\t\t\t\t\t\tif (node.compiler.watching) {\n\t\t\t\t\t\t\tnode.compiler.watching.close(callback);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => callback(err)\n\t\t\t\t);\n\t\t\t}\n\t\t\tnode.result = stats;\n\t\t\trunning--;\n\t\t\tif (node.state === \"running\") {\n\t\t\t\tnode.state = \"done\";\n\t\t\t\tfor (const child of node.children) {\n\t\t\t\t\tif (child.state === \"blocked\") queue.enqueue(child);\n\t\t\t\t}\n\t\t\t} else if (node.state === \"running-outdated\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t\tqueue.enqueue(node);\n\t\t\t}\n\t\t\tprocessQueue();\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeInvalidFromParent = node => {\n\t\t\tif (node.state === \"done\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t} else if (node.state === \"running\") {\n\t\t\t\tnode.state = \"running-outdated\";\n\t\t\t}\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnodeInvalidFromParent(child);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeInvalid = node => {\n\t\t\tif (node.state === \"done\") {\n\t\t\t\tnode.state = \"pending\";\n\t\t\t} else if (node.state === \"running\") {\n\t\t\t\tnode.state = \"running-outdated\";\n\t\t\t}\n\t\t\tfor (const child of node.children) {\n\t\t\t\tnodeInvalidFromParent(child);\n\t\t\t}\n\t\t};\n\t\t/**\n\t\t * @param {Node} node node\n\t\t * @returns {void}\n\t\t */\n\t\tconst nodeChange = node => {\n\t\t\tnodeInvalid(node);\n\t\t\tif (node.state === \"pending\") {\n\t\t\t\tnode.state = \"blocked\";\n\t\t\t}\n\t\t\tif (node.state === \"blocked\") {\n\t\t\t\tqueue.enqueue(node);\n\t\t\t\tprocessQueue();\n\t\t\t}\n\t\t};\n\n\t\t/** @type {SetupResult[]} */\n\t\tconst setupResults = [];\n\t\tfor (const [i, node] of nodes.entries()) {\n\t\t\tsetupResults.push(\n\t\t\t\t(node.setupResult = setup(\n\t\t\t\t\tnode.compiler,\n\t\t\t\t\ti,\n\t\t\t\t\tnodeDone.bind(null, node),\n\t\t\t\t\t() => node.state !== \"starting\" && node.state !== \"running\",\n\t\t\t\t\t() => nodeChange(node),\n\t\t\t\t\t() => nodeInvalid(node)\n\t\t\t\t))\n\t\t\t);\n\t\t}\n\t\tlet processing = true;\n\t\tconst processQueue = () => {\n\t\t\tif (processing) return;\n\t\t\tprocessing = true;\n\t\t\tprocess.nextTick(processQueueWorker);\n\t\t};\n\t\tconst processQueueWorker = () => {\n\t\t\t// eslint-disable-next-line no-unmodified-loop-condition\n\t\t\twhile (running < parallelism && queue.length > 0 && !errored) {\n\t\t\t\tconst node = /** @type {Node} */ (queue.dequeue());\n\t\t\t\tif (\n\t\t\t\t\tnode.state === \"queued\" ||\n\t\t\t\t\t(node.state === \"blocked\" &&\n\t\t\t\t\t\tnode.parents.every(p => p.state === \"done\"))\n\t\t\t\t) {\n\t\t\t\t\trunning++;\n\t\t\t\t\tnode.state = \"starting\";\n\t\t\t\t\trun(\n\t\t\t\t\t\tnode.compiler,\n\t\t\t\t\t\t/** @type {SetupResult} */ (node.setupResult),\n\t\t\t\t\t\tnodeDone.bind(null, node)\n\t\t\t\t\t);\n\t\t\t\t\tnode.state = \"running\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tprocessing = false;\n\t\t\tif (\n\t\t\t\t!errored &&\n\t\t\t\trunning === 0 &&\n\t\t\t\tnodes.every(node => node.state === \"done\")\n\t\t\t) {\n\t\t\t\tconst stats = [];\n\t\t\t\tfor (const node of nodes) {\n\t\t\t\t\tconst result = node.result;\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tnode.result = undefined;\n\t\t\t\t\t\tstats.push(result);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (stats.length > 0) {\n\t\t\t\t\tcallback(null, new MultiStats(stats));\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tprocessQueueWorker();\n\t\treturn setupResults;\n\t}\n\n\t/**\n\t * @param {WatchOptions|WatchOptions[]} watchOptions the watcher's options\n\t * @param {Callback<MultiStats>} handler signals when the call finishes\n\t * @returns {MultiWatching} a compiler watcher\n\t */\n\twatch(watchOptions, handler) {\n\t\tif (this.running) {\n\t\t\treturn handler(new ConcurrentCompilationError());\n\t\t}\n\t\tthis.running = true;\n\n\t\tif (this.validateDependencies(handler)) {\n\t\t\tconst watchings = this._runGraph(\n\t\t\t\t(compiler, idx, callback, isBlocked, setChanged, setInvalid) => {\n\t\t\t\t\tconst watching = compiler.watch(\n\t\t\t\t\t\tArray.isArray(watchOptions) ? watchOptions[idx] : watchOptions,\n\t\t\t\t\t\tcallback\n\t\t\t\t\t);\n\t\t\t\t\tif (watching) {\n\t\t\t\t\t\twatching._onInvalid = setInvalid;\n\t\t\t\t\t\twatching._onChange = setChanged;\n\t\t\t\t\t\twatching._isBlocked = isBlocked;\n\t\t\t\t\t}\n\t\t\t\t\treturn watching;\n\t\t\t\t},\n\t\t\t\t(compiler, watching, callback) => {\n\t\t\t\t\tif (compiler.watching !== watching) return;\n\t\t\t\t\tif (!watching.running) watching.invalidate();\n\t\t\t\t},\n\t\t\t\thandler\n\t\t\t);\n\t\t\treturn new MultiWatching(watchings, this);\n\t\t}\n\n\t\treturn new MultiWatching([], this);\n\t}\n\n\t/**\n\t * @param {Callback<MultiStats>} callback signals when the call finishes\n\t * @returns {void}\n\t */\n\trun(callback) {\n\t\tif (this.running) {\n\t\t\treturn callback(new ConcurrentCompilationError());\n\t\t}\n\t\tthis.running = true;\n\n\t\tif (this.validateDependencies(callback)) {\n\t\t\tthis._runGraph(\n\t\t\t\t() => {},\n\t\t\t\t(compiler, setupResult, callback) => compiler.run(callback),\n\t\t\t\t(err, stats) => {\n\t\t\t\t\tthis.running = false;\n\n\t\t\t\t\tif (callback !== undefined) {\n\t\t\t\t\t\treturn callback(err, stats);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\tpurgeInputFileSystem() {\n\t\tfor (const compiler of this.compilers) {\n\t\t\tif (compiler.inputFileSystem && compiler.inputFileSystem.purge) {\n\t\t\t\tcompiler.inputFileSystem.purge();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @param {Callback<void>} callback signals when the compiler closes\n\t * @returns {void}\n\t */\n\tclose(callback) {\n\t\tasyncLib.each(\n\t\t\tthis.compilers,\n\t\t\t(compiler, callback) => {\n\t\t\t\tcompiler.close(callback);\n\t\t\t},\n\t\t\terror => {\n\t\t\t\tcallback(error);\n\t\t\t}\n\t\t);\n\t}\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}