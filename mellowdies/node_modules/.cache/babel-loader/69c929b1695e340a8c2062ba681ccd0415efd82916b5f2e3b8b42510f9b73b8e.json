{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importAttributesOrAssertions = exports.importAttributes = exports.importAssertions = void 0;\nvar _acorn = _interopRequireWildcard(require(\"acorn\"));\nfunction _getRequireWildcardCache(e) {\n  if (\"function\" != typeof WeakMap) return null;\n  var r = new WeakMap(),\n    t = new WeakMap();\n  return (_getRequireWildcardCache = function (e) {\n    return e ? t : r;\n  })(e);\n}\nfunction _interopRequireWildcard(e, r) {\n  if (!r && e && e.__esModule) return e;\n  if (null === e || \"object\" != typeof e && \"function\" != typeof e) return {\n    default: e\n  };\n  var t = _getRequireWildcardCache(r);\n  if (t && t.has(e)) return t.get(e);\n  var n = {\n      __proto__: null\n    },\n    a = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) {\n    var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;\n    i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];\n  }\n  return n.default = e, t && t.set(e, n), n;\n}\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\nconst withKeyword = \"with\";\nconst assertKeyword = \"assert\";\nconst FUNC_STATEMENT = 1,\n  FUNC_HANGING_STATEMENT = 2,\n  FUNC_NULLABLE_ID = 4;\nconst importAttributes = exports.importAttributes = plugin({\n  keyword: \"with\"\n});\nconst importAssertions = exports.importAssertions = plugin({\n  keyword: \"assert\"\n});\nconst importAttributesOrAssertions = exports.importAttributesOrAssertions = plugin({\n  keyword: \"with-assert\"\n});\nfunction plugin(options) {\n  return function (Parser) {\n    return pluginImpl(options, Parser);\n  };\n}\nfunction pluginImpl(options, Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const {\n    tokTypes: tt,\n    TokenType\n  } = acorn;\n  const {\n    keyword\n  } = options;\n  const isWithKeyword = keyword.includes(withKeyword);\n  const isAssertKeyword = keyword.includes(assertKeyword);\n  const isWithOrAssertKeyword = isWithKeyword && isAssertKeyword;\n  return class extends Parser {\n    constructor(...args) {\n      super(...args);\n      this.withToken = isWithKeyword && new TokenType(withKeyword);\n      this.assertToken = isAssertKeyword && new TokenType(assertKeyword);\n    }\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n      this.next();\n    }\n    _matchKeywordToken() {\n      return isWithOrAssertKeyword && (this.type === this.withToken || this.type === this.assertToken) || isWithKeyword && this.type === this.withToken || isAssertKeyword && this.type === this.assertToken;\n    }\n    _getProperty() {\n      if (isWithOrAssertKeyword) {\n        return this.type === this.withToken ? \"attributes\" : \"assertions\";\n      }\n      return isWithKeyword ? \"attributes\" : \"assertions\";\n    }\n    readToken(code) {\n      let i = 0;\n      let keyword;\n      let token;\n      if (isWithOrAssertKeyword) {\n        if (this.input.slice(this.pos, this.pos + withKeyword.length) === withKeyword) {\n          keyword = withKeyword;\n          token = this.withToken;\n        } else if (this.input.slice(this.pos, this.pos + assertKeyword.length) === assertKeyword) {\n          keyword = assertKeyword;\n          token = this.assertToken;\n        } else {\n          return super.readToken(code);\n        }\n        i += keyword.length;\n      } else {\n        keyword = isWithKeyword ? withKeyword : assertKeyword;\n        token = isWithKeyword ? this.withToken : this.assertToken;\n        for (; i < keyword.length; i++) {\n          if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n            return super.readToken(code);\n          }\n        }\n      }\n\n      // ensure that the keyword is at the correct location\n      // ie `with{...` or `with {...`\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `with` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      }\n\n      // If we're inside a dynamic import expression we'll parse\n      // the `with` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { with: { type: \"json\" } })`\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n      this.pos += keyword.length;\n      return this.finishToken(token);\n    }\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n\n      // Parse node.source.\n      node.source = this.parseMaybeAssign();\n      if (this.eat(tt.comma)) {\n        const expr = this.parseExpression();\n        node.arguments = [expr];\n      }\n      this._eat(tt.parenR);\n      return this.finishNode(node, \"ImportExpression\");\n    }\n\n    // ported from acorn/src/statement.js pp.parseExport\n    parseExport(node, exports) {\n      this.next();\n      // export * from '...'\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n        this.expectContextual(\"from\");\n        if (this.type !== tt.string) {\n          this.unexpected();\n        }\n        node.source = this.parseExprAtom();\n        if (this._matchKeywordToken()) {\n          const property = this._getProperty();\n          this.next();\n          const attributes = this.parseImportAttributes();\n          if (attributes) {\n            node[property] = attributes;\n          }\n        }\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n      }\n      if (this.eat(tt._default)) {\n        // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n          if (isAsync) {\n            this.next();\n          }\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n      }\n      // export var|const|let|function|class ...\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n        if (node.declaration.type === \"VariableDeclaration\") {\n          this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n        }\n        node.specifiers = [];\n        node.source = null;\n      } else {\n        // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n          node.source = this.parseExprAtom();\n          if (this._matchKeywordToken()) {\n            const property = this._getProperty();\n            this.next();\n            const attributes = this.parseImportAttributes();\n            if (attributes) {\n              node[property] = attributes;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n            this.checkUnreserved(spec.local);\n            // check if export is defined\n            this.checkLocalExport(spec.local);\n          }\n          node.source = null;\n        }\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n    parseImport(node) {\n      this.next();\n      // import '...'\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n      if (this._matchKeywordToken()) {\n        const property = this._getProperty();\n        this.next();\n        const attributes = this.parseImportAttributes();\n        if (attributes) {\n          node[property] = attributes;\n        }\n      }\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n    parseImportAttributes() {\n      this._eat(tt.braceL);\n      const attrs = this.parsewithEntries();\n      this._eat(tt.braceR);\n      return attrs;\n    }\n    parsewithEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n        const node = this.startNode();\n\n        // parse withionKey : IdentifierName, StringLiteral\n        let withionKeyNode;\n        if (this.type === tt.string) {\n          withionKeyNode = this.parseLiteral(this.value);\n        } else {\n          withionKeyNode = this.parseIdent(true);\n        }\n        this.next();\n        node.key = withionKeyNode;\n\n        // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in attributes\");\n        }\n        attrNames.add(node.key.name);\n        if (this.type !== tt.string) {\n          this.raise(this.pos, \"Only string is supported as an attribute value\");\n        }\n        node.value = this.parseLiteral(this.value);\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n      return attrs;\n    }\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","importAttributesOrAssertions","importAttributes","importAssertions","_acorn","_interopRequireWildcard","require","_getRequireWildcardCache","e","WeakMap","r","t","__esModule","default","has","get","n","__proto__","a","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","leftCurlyBrace","charCodeAt","space","withKeyword","assertKeyword","FUNC_STATEMENT","FUNC_HANGING_STATEMENT","FUNC_NULLABLE_ID","plugin","keyword","options","Parser","pluginImpl","acorn","tokTypes","tt","TokenType","isWithKeyword","includes","isAssertKeyword","isWithOrAssertKeyword","constructor","args","withToken","assertToken","_codeAt","input","_eat","type","unexpected","next","_matchKeywordToken","_getProperty","readToken","code","token","slice","pos","length","label","finishToken","parseDynamicImport","node","source","parseMaybeAssign","eat","comma","expr","parseExpression","arguments","parenR","finishNode","parseExport","star","ecmaVersion","eatContextual","exported","parseIdent","checkExport","name","lastTokStart","expectContextual","string","parseExprAtom","property","attributes","parseImportAttributes","semicolon","_default","isAsync","_function","isAsyncFunction","fNode","startNode","declaration","parseFunction","_class","cNode","parseClass","shouldParseExportStatement","parseStatement","checkVariableExport","declarations","id","start","specifiers","parseExportSpecifiers","list","spec","checkUnreserved","local","checkLocalExport","parseImport","parseImportSpecifiers","braceL","attrs","parsewithEntries","braceR","attrNames","Set","withionKeyNode","parseLiteral","key","raise","add","push"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/acorn-import-attributes/lib/index.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importAttributesOrAssertions = exports.importAttributes = exports.importAssertions = void 0;\nvar _acorn = _interopRequireWildcard(require(\"acorn\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\nconst leftCurlyBrace = \"{\".charCodeAt(0);\nconst space = \" \".charCodeAt(0);\nconst withKeyword = \"with\";\nconst assertKeyword = \"assert\";\nconst FUNC_STATEMENT = 1,\n  FUNC_HANGING_STATEMENT = 2,\n  FUNC_NULLABLE_ID = 4;\nconst importAttributes = exports.importAttributes = plugin({\n  keyword: \"with\"\n});\nconst importAssertions = exports.importAssertions = plugin({\n  keyword: \"assert\"\n});\nconst importAttributesOrAssertions = exports.importAttributesOrAssertions = plugin({\n  keyword: \"with-assert\"\n});\nfunction plugin(options) {\n  return function (Parser) {\n    return pluginImpl(options, Parser);\n  };\n}\nfunction pluginImpl(options, Parser) {\n  // Use supplied version acorn version if present, to avoid\n  // reference mismatches due to different acorn versions. This\n  // allows this plugin to be used with Rollup which supplies\n  // its own internal version of acorn and thereby sidesteps\n  // the package manager.\n  const acorn = Parser.acorn || _acorn;\n  const {\n    tokTypes: tt,\n    TokenType\n  } = acorn;\n  const {\n    keyword\n  } = options;\n  const isWithKeyword = keyword.includes(withKeyword);\n  const isAssertKeyword = keyword.includes(assertKeyword);\n  const isWithOrAssertKeyword = isWithKeyword && isAssertKeyword;\n  return class extends Parser {\n    constructor(...args) {\n      super(...args);\n      this.withToken = isWithKeyword && new TokenType(withKeyword);\n      this.assertToken = isAssertKeyword && new TokenType(assertKeyword);\n    }\n    _codeAt(i) {\n      return this.input.charCodeAt(i);\n    }\n    _eat(t) {\n      if (this.type !== t) {\n        this.unexpected();\n      }\n      this.next();\n    }\n    _matchKeywordToken() {\n      return isWithOrAssertKeyword && (this.type === this.withToken || this.type === this.assertToken) || isWithKeyword && this.type === this.withToken || isAssertKeyword && this.type === this.assertToken;\n    }\n    _getProperty() {\n      if (isWithOrAssertKeyword) {\n        return this.type === this.withToken ? \"attributes\" : \"assertions\";\n      }\n      return isWithKeyword ? \"attributes\" : \"assertions\";\n    }\n    readToken(code) {\n      let i = 0;\n      let keyword;\n      let token;\n      if (isWithOrAssertKeyword) {\n        if (this.input.slice(this.pos, this.pos + withKeyword.length) === withKeyword) {\n          keyword = withKeyword;\n          token = this.withToken;\n        } else if (this.input.slice(this.pos, this.pos + assertKeyword.length) === assertKeyword) {\n          keyword = assertKeyword;\n          token = this.assertToken;\n        } else {\n          return super.readToken(code);\n        }\n        i += keyword.length;\n      } else {\n        keyword = isWithKeyword ? withKeyword : assertKeyword;\n        token = isWithKeyword ? this.withToken : this.assertToken;\n        for (; i < keyword.length; i++) {\n          if (this._codeAt(this.pos + i) !== keyword.charCodeAt(i)) {\n            return super.readToken(code);\n          }\n        }\n      }\n\n      // ensure that the keyword is at the correct location\n      // ie `with{...` or `with {...`\n      for (;; i++) {\n        if (this._codeAt(this.pos + i) === leftCurlyBrace) {\n          // Found '{'\n          break;\n        } else if (this._codeAt(this.pos + i) === space) {\n          // white space is allowed between `with` and `{`, so continue.\n          continue;\n        } else {\n          return super.readToken(code);\n        }\n      }\n\n      // If we're inside a dynamic import expression we'll parse\n      // the `with` keyword as a standard object property name\n      // ie `import(\"\"./foo.json\", { with: { type: \"json\" } })`\n      if (this.type.label === \"{\") {\n        return super.readToken(code);\n      }\n      this.pos += keyword.length;\n      return this.finishToken(token);\n    }\n    parseDynamicImport(node) {\n      this.next(); // skip `(`\n\n      // Parse node.source.\n      node.source = this.parseMaybeAssign();\n      if (this.eat(tt.comma)) {\n        const expr = this.parseExpression();\n        node.arguments = [expr];\n      }\n      this._eat(tt.parenR);\n      return this.finishNode(node, \"ImportExpression\");\n    }\n\n    // ported from acorn/src/statement.js pp.parseExport\n    parseExport(node, exports) {\n      this.next();\n      // export * from '...'\n      if (this.eat(tt.star)) {\n        if (this.options.ecmaVersion >= 11) {\n          if (this.eatContextual(\"as\")) {\n            node.exported = this.parseIdent(true);\n            this.checkExport(exports, node.exported.name, this.lastTokStart);\n          } else {\n            node.exported = null;\n          }\n        }\n        this.expectContextual(\"from\");\n        if (this.type !== tt.string) {\n          this.unexpected();\n        }\n        node.source = this.parseExprAtom();\n        if (this._matchKeywordToken()) {\n          const property = this._getProperty();\n          this.next();\n          const attributes = this.parseImportAttributes();\n          if (attributes) {\n            node[property] = attributes;\n          }\n        }\n        this.semicolon();\n        return this.finishNode(node, \"ExportAllDeclaration\");\n      }\n      if (this.eat(tt._default)) {\n        // export default ...\n        this.checkExport(exports, \"default\", this.lastTokStart);\n        var isAsync;\n        if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n          var fNode = this.startNode();\n          this.next();\n          if (isAsync) {\n            this.next();\n          }\n          node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n        } else if (this.type === tt._class) {\n          var cNode = this.startNode();\n          node.declaration = this.parseClass(cNode, \"nullableID\");\n        } else {\n          node.declaration = this.parseMaybeAssign();\n          this.semicolon();\n        }\n        return this.finishNode(node, \"ExportDefaultDeclaration\");\n      }\n      // export var|const|let|function|class ...\n      if (this.shouldParseExportStatement()) {\n        node.declaration = this.parseStatement(null);\n        if (node.declaration.type === \"VariableDeclaration\") {\n          this.checkVariableExport(exports, node.declaration.declarations);\n        } else {\n          this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n        }\n        node.specifiers = [];\n        node.source = null;\n      } else {\n        // export { x, y as z } [from '...']\n        node.declaration = null;\n        node.specifiers = this.parseExportSpecifiers(exports);\n        if (this.eatContextual(\"from\")) {\n          if (this.type !== tt.string) {\n            this.unexpected();\n          }\n          node.source = this.parseExprAtom();\n          if (this._matchKeywordToken()) {\n            const property = this._getProperty();\n            this.next();\n            const attributes = this.parseImportAttributes();\n            if (attributes) {\n              node[property] = attributes;\n            }\n          }\n        } else {\n          for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n            // check for keywords used as local names\n            var spec = list[i];\n            this.checkUnreserved(spec.local);\n            // check if export is defined\n            this.checkLocalExport(spec.local);\n          }\n          node.source = null;\n        }\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportNamedDeclaration\");\n    }\n    parseImport(node) {\n      this.next();\n      // import '...'\n      if (this.type === tt.string) {\n        node.specifiers = [];\n        node.source = this.parseExprAtom();\n      } else {\n        node.specifiers = this.parseImportSpecifiers();\n        this.expectContextual(\"from\");\n        node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected();\n      }\n      if (this._matchKeywordToken()) {\n        const property = this._getProperty();\n        this.next();\n        const attributes = this.parseImportAttributes();\n        if (attributes) {\n          node[property] = attributes;\n        }\n      }\n      this.semicolon();\n      return this.finishNode(node, \"ImportDeclaration\");\n    }\n    parseImportAttributes() {\n      this._eat(tt.braceL);\n      const attrs = this.parsewithEntries();\n      this._eat(tt.braceR);\n      return attrs;\n    }\n    parsewithEntries() {\n      const attrs = [];\n      const attrNames = new Set();\n      do {\n        if (this.type === tt.braceR) {\n          break;\n        }\n        const node = this.startNode();\n\n        // parse withionKey : IdentifierName, StringLiteral\n        let withionKeyNode;\n        if (this.type === tt.string) {\n          withionKeyNode = this.parseLiteral(this.value);\n        } else {\n          withionKeyNode = this.parseIdent(true);\n        }\n        this.next();\n        node.key = withionKeyNode;\n\n        // check if we already have an entry for an attribute\n        // if a duplicate entry is found, throw an error\n        // for now this logic will come into play only when someone declares `type` twice\n        if (attrNames.has(node.key.name)) {\n          this.raise(this.pos, \"Duplicated key in attributes\");\n        }\n        attrNames.add(node.key.name);\n        if (this.type !== tt.string) {\n          this.raise(this.pos, \"Only string is supported as an attribute value\");\n        }\n        node.value = this.parseLiteral(this.value);\n        attrs.push(this.finishNode(node, \"ImportAttribute\"));\n      } while (this.eat(tt.comma));\n      return attrs;\n    }\n  };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}