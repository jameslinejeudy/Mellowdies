{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst NormalModule = require(\"./NormalModule\");\nconst createHash = require(\"./util/createHash\");\nconst memoize = require(\"./util/memoize\");\n\n/** @typedef {import(\"./ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./RequestShortener\")} RequestShortener */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n\n/** @typedef {string | RegExp | (string | RegExp)[]} Matcher */\n/** @typedef {{test?: Matcher, include?: Matcher, exclude?: Matcher }} MatchObject */\n\nconst ModuleFilenameHelpers = module.exports;\n\n// TODO webpack 6: consider removing these\nModuleFilenameHelpers.ALL_LOADERS_RESOURCE = \"[all-loaders][resource]\";\nModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE = /\\[all-?loaders\\]\\[resource\\]/gi;\nModuleFilenameHelpers.LOADERS_RESOURCE = \"[loaders][resource]\";\nModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE = /\\[loaders\\]\\[resource\\]/gi;\nModuleFilenameHelpers.RESOURCE = \"[resource]\";\nModuleFilenameHelpers.REGEXP_RESOURCE = /\\[resource\\]/gi;\nModuleFilenameHelpers.ABSOLUTE_RESOURCE_PATH = \"[absolute-resource-path]\";\n// cSpell:words olute\nModuleFilenameHelpers.REGEXP_ABSOLUTE_RESOURCE_PATH = /\\[abs(olute)?-?resource-?path\\]/gi;\nModuleFilenameHelpers.RESOURCE_PATH = \"[resource-path]\";\nModuleFilenameHelpers.REGEXP_RESOURCE_PATH = /\\[resource-?path\\]/gi;\nModuleFilenameHelpers.ALL_LOADERS = \"[all-loaders]\";\nModuleFilenameHelpers.REGEXP_ALL_LOADERS = /\\[all-?loaders\\]/gi;\nModuleFilenameHelpers.LOADERS = \"[loaders]\";\nModuleFilenameHelpers.REGEXP_LOADERS = /\\[loaders\\]/gi;\nModuleFilenameHelpers.QUERY = \"[query]\";\nModuleFilenameHelpers.REGEXP_QUERY = /\\[query\\]/gi;\nModuleFilenameHelpers.ID = \"[id]\";\nModuleFilenameHelpers.REGEXP_ID = /\\[id\\]/gi;\nModuleFilenameHelpers.HASH = \"[hash]\";\nModuleFilenameHelpers.REGEXP_HASH = /\\[hash\\]/gi;\nModuleFilenameHelpers.NAMESPACE = \"[namespace]\";\nModuleFilenameHelpers.REGEXP_NAMESPACE = /\\[namespace\\]/gi;\n\n/** @typedef {() => string} ReturnStringCallback */\n\n/**\n * Returns a function that returns the part of the string after the token\n * @param {ReturnStringCallback} strFn the function to get the string\n * @param {string} token the token to search for\n * @returns {ReturnStringCallback} a function that returns the part of the string after the token\n */\nconst getAfter = (strFn, token) => () => {\n  const str = strFn();\n  const idx = str.indexOf(token);\n  return idx < 0 ? \"\" : str.slice(idx);\n};\n\n/**\n * Returns a function that returns the part of the string before the token\n * @param {ReturnStringCallback} strFn the function to get the string\n * @param {string} token the token to search for\n * @returns {ReturnStringCallback} a function that returns the part of the string before the token\n */\nconst getBefore = (strFn, token) => () => {\n  const str = strFn();\n  const idx = str.lastIndexOf(token);\n  return idx < 0 ? \"\" : str.slice(0, idx);\n};\n\n/**\n * Returns a function that returns a hash of the string\n * @param {ReturnStringCallback} strFn the function to get the string\n * @param {string | Hash=} hashFunction the hash function to use\n * @returns {ReturnStringCallback} a function that returns the hash of the string\n */\nconst getHash = (strFn, hashFunction = \"md4\") => () => {\n  const hash = createHash(hashFunction);\n  hash.update(strFn());\n  const digest = /** @type {string} */hash.digest(\"hex\");\n  return digest.slice(0, 4);\n};\n\n/**\n * Returns a function that returns the string with the token replaced with the replacement\n * @param {string|RegExp} test A regular expression string or Regular Expression object\n * @returns\t{RegExp} A regular expression object\n * @example\n * ```js\n * const test = asRegExp(\"test\");\n * test.test(\"test\"); // true\n *\n * const test2 = asRegExp(/test/);\n * test2.test(\"test\"); // true\n * ```\n */\nconst asRegExp = test => {\n  if (typeof test === \"string\") {\n    // Escape special characters in the string to prevent them from being interpreted as special characters in a regular expression. Do this by\n    // adding a backslash before each special character\n    test = new RegExp(`^${test.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\")}`);\n  }\n  return test;\n};\n\n/**\n * @template T\n * Returns a lazy object. The object is lazy in the sense that the properties are\n * only evaluated when they are accessed. This is only obtained by setting a function as the value for each key.\n * @param {Record<string, () => T>} obj the object to convert to a lazy access object\n * @returns {object} the lazy access object\n */\nconst lazyObject = obj => {\n  const newObj = {};\n  for (const key of Object.keys(obj)) {\n    const fn = obj[key];\n    Object.defineProperty(newObj, key, {\n      get: () => fn(),\n      set: v => {\n        Object.defineProperty(newObj, key, {\n          value: v,\n          enumerable: true,\n          writable: true\n        });\n      },\n      enumerable: true,\n      configurable: true\n    });\n  }\n  return newObj;\n};\nconst SQUARE_BRACKET_TAG_REGEXP = /\\[\\\\*([\\w-]+)\\\\*\\]/gi;\n\n/**\n * @param {Module | string} module the module\n * @param {TODO} options options\n * @param {object} contextInfo context info\n * @param {RequestShortener} contextInfo.requestShortener requestShortener\n * @param {ChunkGraph} contextInfo.chunkGraph chunk graph\n * @param {string | Hash=} contextInfo.hashFunction the hash function to use\n * @returns {string} the filename\n */\nModuleFilenameHelpers.createFilename = (\n// eslint-disable-next-line default-param-last\nmodule = \"\", options, {\n  requestShortener,\n  chunkGraph,\n  hashFunction = \"md4\"\n}) => {\n  const opts = {\n    namespace: \"\",\n    moduleFilenameTemplate: \"\",\n    ...(typeof options === \"object\" ? options : {\n      moduleFilenameTemplate: options\n    })\n  };\n  let absoluteResourcePath;\n  let hash;\n  /** @type {ReturnStringCallback} */\n  let identifier;\n  /** @type {ReturnStringCallback} */\n  let moduleId;\n  /** @type {ReturnStringCallback} */\n  let shortIdentifier;\n  if (typeof module === \"string\") {\n    shortIdentifier = /** @type {ReturnStringCallback} */\n    memoize(() => requestShortener.shorten(module));\n    identifier = shortIdentifier;\n    moduleId = () => \"\";\n    absoluteResourcePath = () => module.split(\"!\").pop();\n    hash = getHash(identifier, hashFunction);\n  } else {\n    shortIdentifier = memoize(() => module.readableIdentifier(requestShortener));\n    identifier = /** @type {ReturnStringCallback} */\n    memoize(() => requestShortener.shorten(module.identifier()));\n    moduleId = /** @type {ReturnStringCallback} */\n    () => chunkGraph.getModuleId(module);\n    absoluteResourcePath = () => module instanceof NormalModule ? module.resource : module.identifier().split(\"!\").pop();\n    hash = getHash(identifier, hashFunction);\n  }\n  const resource = /** @type {ReturnStringCallback} */\n  memoize(() => shortIdentifier().split(\"!\").pop());\n  const loaders = getBefore(shortIdentifier, \"!\");\n  const allLoaders = getBefore(identifier, \"!\");\n  const query = getAfter(resource, \"?\");\n  const resourcePath = () => {\n    const q = query().length;\n    return q === 0 ? resource() : resource().slice(0, -q);\n  };\n  if (typeof opts.moduleFilenameTemplate === \"function\") {\n    return opts.moduleFilenameTemplate(lazyObject({\n      identifier,\n      shortIdentifier,\n      resource,\n      resourcePath: memoize(resourcePath),\n      absoluteResourcePath: memoize(absoluteResourcePath),\n      loaders: memoize(loaders),\n      allLoaders: memoize(allLoaders),\n      query: memoize(query),\n      moduleId: memoize(moduleId),\n      hash: memoize(hash),\n      namespace: () => opts.namespace\n    }));\n  }\n\n  // TODO webpack 6: consider removing alternatives without dashes\n  /** @type {Map<string, function(): string>} */\n  const replacements = new Map([[\"identifier\", identifier], [\"short-identifier\", shortIdentifier], [\"resource\", resource], [\"resource-path\", resourcePath],\n  // cSpell:words resourcepath\n  [\"resourcepath\", resourcePath], [\"absolute-resource-path\", absoluteResourcePath], [\"abs-resource-path\", absoluteResourcePath],\n  // cSpell:words absoluteresource\n  [\"absoluteresource-path\", absoluteResourcePath],\n  // cSpell:words absresource\n  [\"absresource-path\", absoluteResourcePath],\n  // cSpell:words resourcepath\n  [\"absolute-resourcepath\", absoluteResourcePath],\n  // cSpell:words resourcepath\n  [\"abs-resourcepath\", absoluteResourcePath],\n  // cSpell:words absoluteresourcepath\n  [\"absoluteresourcepath\", absoluteResourcePath],\n  // cSpell:words absresourcepath\n  [\"absresourcepath\", absoluteResourcePath], [\"all-loaders\", allLoaders],\n  // cSpell:words allloaders\n  [\"allloaders\", allLoaders], [\"loaders\", loaders], [\"query\", query], [\"id\", moduleId], [\"hash\", hash], [\"namespace\", () => opts.namespace]]);\n\n  // TODO webpack 6: consider removing weird double placeholders\n  return /** @type {string} */opts.moduleFilenameTemplate.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE, \"[identifier]\").replace(ModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE, \"[short-identifier]\").replace(SQUARE_BRACKET_TAG_REGEXP, (match, content) => {\n    if (content.length + 2 === match.length) {\n      const replacement = replacements.get(content.toLowerCase());\n      if (replacement !== undefined) {\n        return replacement();\n      }\n    } else if (match.startsWith(\"[\\\\\") && match.endsWith(\"\\\\]\")) {\n      return `[${match.slice(2, -2)}]`;\n    }\n    return match;\n  });\n};\n\n/**\n * Replaces duplicate items in an array with new values generated by a callback function.\n * The callback function is called with the duplicate item, the index of the duplicate item, and the number of times the item has been replaced.\n * The callback function should return the new value for the duplicate item.\n * @template T\n * @param {T[]} array the array with duplicates to be replaced\n * @param {(duplicateItem: T, duplicateItemIndex: number, numberOfTimesReplaced: number) => T} fn callback function to generate new values for the duplicate items\n * @param {(firstElement:T, nextElement:T) => -1 | 0 | 1} [comparator] optional comparator function to sort the duplicate items\n * @returns {T[]} the array with duplicates replaced\n * @example\n * ```js\n * const array = [\"a\", \"b\", \"c\", \"a\", \"b\", \"a\"];\n * const result = ModuleFilenameHelpers.replaceDuplicates(array, (item, index, count) => `${item}-${count}`);\n * // result: [\"a-1\", \"b-1\", \"c\", \"a-2\", \"b-2\", \"a-3\"]\n * ```\n */\nModuleFilenameHelpers.replaceDuplicates = (array, fn, comparator) => {\n  const countMap = Object.create(null);\n  const posMap = Object.create(null);\n  for (const [idx, item] of array.entries()) {\n    countMap[item] = countMap[item] || [];\n    countMap[item].push(idx);\n    posMap[item] = 0;\n  }\n  if (comparator) {\n    for (const item of Object.keys(countMap)) {\n      countMap[item].sort(comparator);\n    }\n  }\n  return array.map((item, i) => {\n    if (countMap[item].length > 1) {\n      if (comparator && countMap[item][0] === i) return item;\n      return fn(item, i, posMap[item]++);\n    }\n    return item;\n  });\n};\n\n/**\n * Tests if a string matches a RegExp or an array of RegExp.\n * @param {string} str string to test\n * @param {Matcher} test value which will be used to match against the string\n * @returns {boolean} true, when the RegExp matches\n * @example\n * ```js\n * ModuleFilenameHelpers.matchPart(\"foo.js\", \"foo\"); // true\n * ModuleFilenameHelpers.matchPart(\"foo.js\", \"foo.js\"); // true\n * ModuleFilenameHelpers.matchPart(\"foo.js\", \"foo.\"); // false\n * ModuleFilenameHelpers.matchPart(\"foo.js\", \"foo*\"); // false\n * ModuleFilenameHelpers.matchPart(\"foo.js\", \"foo.*\"); // true\n * ModuleFilenameHelpers.matchPart(\"foo.js\", /^foo/); // true\n * ModuleFilenameHelpers.matchPart(\"foo.js\", [/^foo/, \"bar\"]); // true\n * ModuleFilenameHelpers.matchPart(\"foo.js\", [/^foo/, \"bar\"]); // true\n * ModuleFilenameHelpers.matchPart(\"foo.js\", [/^foo/, /^bar/]); // true\n * ModuleFilenameHelpers.matchPart(\"foo.js\", [/^baz/, /^bar/]); // false\n * ```\n */\nModuleFilenameHelpers.matchPart = (str, test) => {\n  if (!test) return true;\n  if (Array.isArray(test)) {\n    return test.map(asRegExp).some(regExp => regExp.test(str));\n  }\n  return asRegExp(test).test(str);\n};\n\n/**\n * Tests if a string matches a match object. The match object can have the following properties:\n * - `test`: a RegExp or an array of RegExp\n * - `include`: a RegExp or an array of RegExp\n * - `exclude`: a RegExp or an array of RegExp\n *\n * The `test` property is tested first, then `include` and then `exclude`.\n * @param {MatchObject} obj a match object to test against the string\n * @param {string} str string to test against the matching object\n * @returns {boolean} true, when the object matches\n * @example\n * ```js\n * ModuleFilenameHelpers.matchObject({ test: \"foo.js\" }, \"foo.js\"); // true\n * ModuleFilenameHelpers.matchObject({ test: /^foo/ }, \"foo.js\"); // true\n * ModuleFilenameHelpers.matchObject({ test: [/^foo/, \"bar\"] }, \"foo.js\"); // true\n * ModuleFilenameHelpers.matchObject({ test: [/^foo/, \"bar\"] }, \"baz.js\"); // false\n * ModuleFilenameHelpers.matchObject({ include: \"foo.js\" }, \"foo.js\"); // true\n * ModuleFilenameHelpers.matchObject({ include: \"foo.js\" }, \"bar.js\"); // false\n * ModuleFilenameHelpers.matchObject({ include: /^foo/ }, \"foo.js\"); // true\n * ModuleFilenameHelpers.matchObject({ include: [/^foo/, \"bar\"] }, \"foo.js\"); // true\n * ModuleFilenameHelpers.matchObject({ include: [/^foo/, \"bar\"] }, \"baz.js\"); // false\n * ModuleFilenameHelpers.matchObject({ exclude: \"foo.js\" }, \"foo.js\"); // false\n * ModuleFilenameHelpers.matchObject({ exclude: [/^foo/, \"bar\"] }, \"foo.js\"); // false\n * ```\n */\nModuleFilenameHelpers.matchObject = (obj, str) => {\n  if (obj.test && !ModuleFilenameHelpers.matchPart(str, obj.test)) {\n    return false;\n  }\n  if (obj.include && !ModuleFilenameHelpers.matchPart(str, obj.include)) {\n    return false;\n  }\n  if (obj.exclude && ModuleFilenameHelpers.matchPart(str, obj.exclude)) {\n    return false;\n  }\n  return true;\n};","map":{"version":3,"names":["NormalModule","require","createHash","memoize","ModuleFilenameHelpers","module","exports","ALL_LOADERS_RESOURCE","REGEXP_ALL_LOADERS_RESOURCE","LOADERS_RESOURCE","REGEXP_LOADERS_RESOURCE","RESOURCE","REGEXP_RESOURCE","ABSOLUTE_RESOURCE_PATH","REGEXP_ABSOLUTE_RESOURCE_PATH","RESOURCE_PATH","REGEXP_RESOURCE_PATH","ALL_LOADERS","REGEXP_ALL_LOADERS","LOADERS","REGEXP_LOADERS","QUERY","REGEXP_QUERY","ID","REGEXP_ID","HASH","REGEXP_HASH","NAMESPACE","REGEXP_NAMESPACE","getAfter","strFn","token","str","idx","indexOf","slice","getBefore","lastIndexOf","getHash","hashFunction","hash","update","digest","asRegExp","test","RegExp","replace","lazyObject","obj","newObj","key","Object","keys","fn","defineProperty","get","set","v","value","enumerable","writable","configurable","SQUARE_BRACKET_TAG_REGEXP","createFilename","options","requestShortener","chunkGraph","opts","namespace","moduleFilenameTemplate","absoluteResourcePath","identifier","moduleId","shortIdentifier","shorten","split","pop","readableIdentifier","getModuleId","resource","loaders","allLoaders","query","resourcePath","q","length","replacements","Map","match","content","replacement","toLowerCase","undefined","startsWith","endsWith","replaceDuplicates","array","comparator","countMap","create","posMap","item","entries","push","sort","map","i","matchPart","Array","isArray","some","regExp","matchObject","include","exclude"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/webpack/lib/ModuleFilenameHelpers.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst NormalModule = require(\"./NormalModule\");\nconst createHash = require(\"./util/createHash\");\nconst memoize = require(\"./util/memoize\");\n\n/** @typedef {import(\"./ChunkGraph\")} ChunkGraph */\n/** @typedef {import(\"./Module\")} Module */\n/** @typedef {import(\"./RequestShortener\")} RequestShortener */\n/** @typedef {typeof import(\"./util/Hash\")} Hash */\n\n/** @typedef {string | RegExp | (string | RegExp)[]} Matcher */\n/** @typedef {{test?: Matcher, include?: Matcher, exclude?: Matcher }} MatchObject */\n\nconst ModuleFilenameHelpers = module.exports;\n\n// TODO webpack 6: consider removing these\nModuleFilenameHelpers.ALL_LOADERS_RESOURCE = \"[all-loaders][resource]\";\nModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE =\n\t/\\[all-?loaders\\]\\[resource\\]/gi;\nModuleFilenameHelpers.LOADERS_RESOURCE = \"[loaders][resource]\";\nModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE = /\\[loaders\\]\\[resource\\]/gi;\nModuleFilenameHelpers.RESOURCE = \"[resource]\";\nModuleFilenameHelpers.REGEXP_RESOURCE = /\\[resource\\]/gi;\nModuleFilenameHelpers.ABSOLUTE_RESOURCE_PATH = \"[absolute-resource-path]\";\n// cSpell:words olute\nModuleFilenameHelpers.REGEXP_ABSOLUTE_RESOURCE_PATH =\n\t/\\[abs(olute)?-?resource-?path\\]/gi;\nModuleFilenameHelpers.RESOURCE_PATH = \"[resource-path]\";\nModuleFilenameHelpers.REGEXP_RESOURCE_PATH = /\\[resource-?path\\]/gi;\nModuleFilenameHelpers.ALL_LOADERS = \"[all-loaders]\";\nModuleFilenameHelpers.REGEXP_ALL_LOADERS = /\\[all-?loaders\\]/gi;\nModuleFilenameHelpers.LOADERS = \"[loaders]\";\nModuleFilenameHelpers.REGEXP_LOADERS = /\\[loaders\\]/gi;\nModuleFilenameHelpers.QUERY = \"[query]\";\nModuleFilenameHelpers.REGEXP_QUERY = /\\[query\\]/gi;\nModuleFilenameHelpers.ID = \"[id]\";\nModuleFilenameHelpers.REGEXP_ID = /\\[id\\]/gi;\nModuleFilenameHelpers.HASH = \"[hash]\";\nModuleFilenameHelpers.REGEXP_HASH = /\\[hash\\]/gi;\nModuleFilenameHelpers.NAMESPACE = \"[namespace]\";\nModuleFilenameHelpers.REGEXP_NAMESPACE = /\\[namespace\\]/gi;\n\n/** @typedef {() => string} ReturnStringCallback */\n\n/**\n * Returns a function that returns the part of the string after the token\n * @param {ReturnStringCallback} strFn the function to get the string\n * @param {string} token the token to search for\n * @returns {ReturnStringCallback} a function that returns the part of the string after the token\n */\nconst getAfter = (strFn, token) => () => {\n\tconst str = strFn();\n\tconst idx = str.indexOf(token);\n\treturn idx < 0 ? \"\" : str.slice(idx);\n};\n\n/**\n * Returns a function that returns the part of the string before the token\n * @param {ReturnStringCallback} strFn the function to get the string\n * @param {string} token the token to search for\n * @returns {ReturnStringCallback} a function that returns the part of the string before the token\n */\nconst getBefore = (strFn, token) => () => {\n\tconst str = strFn();\n\tconst idx = str.lastIndexOf(token);\n\treturn idx < 0 ? \"\" : str.slice(0, idx);\n};\n\n/**\n * Returns a function that returns a hash of the string\n * @param {ReturnStringCallback} strFn the function to get the string\n * @param {string | Hash=} hashFunction the hash function to use\n * @returns {ReturnStringCallback} a function that returns the hash of the string\n */\nconst getHash =\n\t(strFn, hashFunction = \"md4\") =>\n\t() => {\n\t\tconst hash = createHash(hashFunction);\n\t\thash.update(strFn());\n\t\tconst digest = /** @type {string} */ (hash.digest(\"hex\"));\n\t\treturn digest.slice(0, 4);\n\t};\n\n/**\n * Returns a function that returns the string with the token replaced with the replacement\n * @param {string|RegExp} test A regular expression string or Regular Expression object\n * @returns\t{RegExp} A regular expression object\n * @example\n * ```js\n * const test = asRegExp(\"test\");\n * test.test(\"test\"); // true\n *\n * const test2 = asRegExp(/test/);\n * test2.test(\"test\"); // true\n * ```\n */\nconst asRegExp = test => {\n\tif (typeof test === \"string\") {\n\t\t// Escape special characters in the string to prevent them from being interpreted as special characters in a regular expression. Do this by\n\t\t// adding a backslash before each special character\n\t\ttest = new RegExp(`^${test.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\")}`);\n\t}\n\treturn test;\n};\n\n/**\n * @template T\n * Returns a lazy object. The object is lazy in the sense that the properties are\n * only evaluated when they are accessed. This is only obtained by setting a function as the value for each key.\n * @param {Record<string, () => T>} obj the object to convert to a lazy access object\n * @returns {object} the lazy access object\n */\nconst lazyObject = obj => {\n\tconst newObj = {};\n\tfor (const key of Object.keys(obj)) {\n\t\tconst fn = obj[key];\n\t\tObject.defineProperty(newObj, key, {\n\t\t\tget: () => fn(),\n\t\t\tset: v => {\n\t\t\t\tObject.defineProperty(newObj, key, {\n\t\t\t\t\tvalue: v,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\twritable: true\n\t\t\t\t});\n\t\t\t},\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true\n\t\t});\n\t}\n\treturn newObj;\n};\n\nconst SQUARE_BRACKET_TAG_REGEXP = /\\[\\\\*([\\w-]+)\\\\*\\]/gi;\n\n/**\n * @param {Module | string} module the module\n * @param {TODO} options options\n * @param {object} contextInfo context info\n * @param {RequestShortener} contextInfo.requestShortener requestShortener\n * @param {ChunkGraph} contextInfo.chunkGraph chunk graph\n * @param {string | Hash=} contextInfo.hashFunction the hash function to use\n * @returns {string} the filename\n */\nModuleFilenameHelpers.createFilename = (\n\t// eslint-disable-next-line default-param-last\n\tmodule = \"\",\n\toptions,\n\t{ requestShortener, chunkGraph, hashFunction = \"md4\" }\n) => {\n\tconst opts = {\n\t\tnamespace: \"\",\n\t\tmoduleFilenameTemplate: \"\",\n\t\t...(typeof options === \"object\"\n\t\t\t? options\n\t\t\t: {\n\t\t\t\t\tmoduleFilenameTemplate: options\n\t\t\t\t})\n\t};\n\n\tlet absoluteResourcePath;\n\tlet hash;\n\t/** @type {ReturnStringCallback} */\n\tlet identifier;\n\t/** @type {ReturnStringCallback} */\n\tlet moduleId;\n\t/** @type {ReturnStringCallback} */\n\tlet shortIdentifier;\n\tif (typeof module === \"string\") {\n\t\tshortIdentifier =\n\t\t\t/** @type {ReturnStringCallback} */\n\t\t\t(memoize(() => requestShortener.shorten(module)));\n\t\tidentifier = shortIdentifier;\n\t\tmoduleId = () => \"\";\n\t\tabsoluteResourcePath = () => module.split(\"!\").pop();\n\t\thash = getHash(identifier, hashFunction);\n\t} else {\n\t\tshortIdentifier = memoize(() =>\n\t\t\tmodule.readableIdentifier(requestShortener)\n\t\t);\n\t\tidentifier =\n\t\t\t/** @type {ReturnStringCallback} */\n\t\t\t(memoize(() => requestShortener.shorten(module.identifier())));\n\t\tmoduleId =\n\t\t\t/** @type {ReturnStringCallback} */\n\t\t\t(() => chunkGraph.getModuleId(module));\n\t\tabsoluteResourcePath = () =>\n\t\t\tmodule instanceof NormalModule\n\t\t\t\t? module.resource\n\t\t\t\t: module.identifier().split(\"!\").pop();\n\t\thash = getHash(identifier, hashFunction);\n\t}\n\tconst resource =\n\t\t/** @type {ReturnStringCallback} */\n\t\t(memoize(() => shortIdentifier().split(\"!\").pop()));\n\n\tconst loaders = getBefore(shortIdentifier, \"!\");\n\tconst allLoaders = getBefore(identifier, \"!\");\n\tconst query = getAfter(resource, \"?\");\n\tconst resourcePath = () => {\n\t\tconst q = query().length;\n\t\treturn q === 0 ? resource() : resource().slice(0, -q);\n\t};\n\tif (typeof opts.moduleFilenameTemplate === \"function\") {\n\t\treturn opts.moduleFilenameTemplate(\n\t\t\tlazyObject({\n\t\t\t\tidentifier,\n\t\t\t\tshortIdentifier,\n\t\t\t\tresource,\n\t\t\t\tresourcePath: memoize(resourcePath),\n\t\t\t\tabsoluteResourcePath: memoize(absoluteResourcePath),\n\t\t\t\tloaders: memoize(loaders),\n\t\t\t\tallLoaders: memoize(allLoaders),\n\t\t\t\tquery: memoize(query),\n\t\t\t\tmoduleId: memoize(moduleId),\n\t\t\t\thash: memoize(hash),\n\t\t\t\tnamespace: () => opts.namespace\n\t\t\t})\n\t\t);\n\t}\n\n\t// TODO webpack 6: consider removing alternatives without dashes\n\t/** @type {Map<string, function(): string>} */\n\tconst replacements = new Map([\n\t\t[\"identifier\", identifier],\n\t\t[\"short-identifier\", shortIdentifier],\n\t\t[\"resource\", resource],\n\t\t[\"resource-path\", resourcePath],\n\t\t// cSpell:words resourcepath\n\t\t[\"resourcepath\", resourcePath],\n\t\t[\"absolute-resource-path\", absoluteResourcePath],\n\t\t[\"abs-resource-path\", absoluteResourcePath],\n\t\t// cSpell:words absoluteresource\n\t\t[\"absoluteresource-path\", absoluteResourcePath],\n\t\t// cSpell:words absresource\n\t\t[\"absresource-path\", absoluteResourcePath],\n\t\t// cSpell:words resourcepath\n\t\t[\"absolute-resourcepath\", absoluteResourcePath],\n\t\t// cSpell:words resourcepath\n\t\t[\"abs-resourcepath\", absoluteResourcePath],\n\t\t// cSpell:words absoluteresourcepath\n\t\t[\"absoluteresourcepath\", absoluteResourcePath],\n\t\t// cSpell:words absresourcepath\n\t\t[\"absresourcepath\", absoluteResourcePath],\n\t\t[\"all-loaders\", allLoaders],\n\t\t// cSpell:words allloaders\n\t\t[\"allloaders\", allLoaders],\n\t\t[\"loaders\", loaders],\n\t\t[\"query\", query],\n\t\t[\"id\", moduleId],\n\t\t[\"hash\", hash],\n\t\t[\"namespace\", () => opts.namespace]\n\t]);\n\n\t// TODO webpack 6: consider removing weird double placeholders\n\treturn /** @type {string} */ (opts.moduleFilenameTemplate)\n\t\t.replace(ModuleFilenameHelpers.REGEXP_ALL_LOADERS_RESOURCE, \"[identifier]\")\n\t\t.replace(\n\t\t\tModuleFilenameHelpers.REGEXP_LOADERS_RESOURCE,\n\t\t\t\"[short-identifier]\"\n\t\t)\n\t\t.replace(SQUARE_BRACKET_TAG_REGEXP, (match, content) => {\n\t\t\tif (content.length + 2 === match.length) {\n\t\t\t\tconst replacement = replacements.get(content.toLowerCase());\n\t\t\t\tif (replacement !== undefined) {\n\t\t\t\t\treturn replacement();\n\t\t\t\t}\n\t\t\t} else if (match.startsWith(\"[\\\\\") && match.endsWith(\"\\\\]\")) {\n\t\t\t\treturn `[${match.slice(2, -2)}]`;\n\t\t\t}\n\t\t\treturn match;\n\t\t});\n};\n\n/**\n * Replaces duplicate items in an array with new values generated by a callback function.\n * The callback function is called with the duplicate item, the index of the duplicate item, and the number of times the item has been replaced.\n * The callback function should return the new value for the duplicate item.\n * @template T\n * @param {T[]} array the array with duplicates to be replaced\n * @param {(duplicateItem: T, duplicateItemIndex: number, numberOfTimesReplaced: number) => T} fn callback function to generate new values for the duplicate items\n * @param {(firstElement:T, nextElement:T) => -1 | 0 | 1} [comparator] optional comparator function to sort the duplicate items\n * @returns {T[]} the array with duplicates replaced\n * @example\n * ```js\n * const array = [\"a\", \"b\", \"c\", \"a\", \"b\", \"a\"];\n * const result = ModuleFilenameHelpers.replaceDuplicates(array, (item, index, count) => `${item}-${count}`);\n * // result: [\"a-1\", \"b-1\", \"c\", \"a-2\", \"b-2\", \"a-3\"]\n * ```\n */\nModuleFilenameHelpers.replaceDuplicates = (array, fn, comparator) => {\n\tconst countMap = Object.create(null);\n\tconst posMap = Object.create(null);\n\n\tfor (const [idx, item] of array.entries()) {\n\t\tcountMap[item] = countMap[item] || [];\n\t\tcountMap[item].push(idx);\n\t\tposMap[item] = 0;\n\t}\n\tif (comparator) {\n\t\tfor (const item of Object.keys(countMap)) {\n\t\t\tcountMap[item].sort(comparator);\n\t\t}\n\t}\n\treturn array.map((item, i) => {\n\t\tif (countMap[item].length > 1) {\n\t\t\tif (comparator && countMap[item][0] === i) return item;\n\t\t\treturn fn(item, i, posMap[item]++);\n\t\t}\n\t\treturn item;\n\t});\n};\n\n/**\n * Tests if a string matches a RegExp or an array of RegExp.\n * @param {string} str string to test\n * @param {Matcher} test value which will be used to match against the string\n * @returns {boolean} true, when the RegExp matches\n * @example\n * ```js\n * ModuleFilenameHelpers.matchPart(\"foo.js\", \"foo\"); // true\n * ModuleFilenameHelpers.matchPart(\"foo.js\", \"foo.js\"); // true\n * ModuleFilenameHelpers.matchPart(\"foo.js\", \"foo.\"); // false\n * ModuleFilenameHelpers.matchPart(\"foo.js\", \"foo*\"); // false\n * ModuleFilenameHelpers.matchPart(\"foo.js\", \"foo.*\"); // true\n * ModuleFilenameHelpers.matchPart(\"foo.js\", /^foo/); // true\n * ModuleFilenameHelpers.matchPart(\"foo.js\", [/^foo/, \"bar\"]); // true\n * ModuleFilenameHelpers.matchPart(\"foo.js\", [/^foo/, \"bar\"]); // true\n * ModuleFilenameHelpers.matchPart(\"foo.js\", [/^foo/, /^bar/]); // true\n * ModuleFilenameHelpers.matchPart(\"foo.js\", [/^baz/, /^bar/]); // false\n * ```\n */\nModuleFilenameHelpers.matchPart = (str, test) => {\n\tif (!test) return true;\n\n\tif (Array.isArray(test)) {\n\t\treturn test.map(asRegExp).some(regExp => regExp.test(str));\n\t}\n\treturn asRegExp(test).test(str);\n};\n\n/**\n * Tests if a string matches a match object. The match object can have the following properties:\n * - `test`: a RegExp or an array of RegExp\n * - `include`: a RegExp or an array of RegExp\n * - `exclude`: a RegExp or an array of RegExp\n *\n * The `test` property is tested first, then `include` and then `exclude`.\n * @param {MatchObject} obj a match object to test against the string\n * @param {string} str string to test against the matching object\n * @returns {boolean} true, when the object matches\n * @example\n * ```js\n * ModuleFilenameHelpers.matchObject({ test: \"foo.js\" }, \"foo.js\"); // true\n * ModuleFilenameHelpers.matchObject({ test: /^foo/ }, \"foo.js\"); // true\n * ModuleFilenameHelpers.matchObject({ test: [/^foo/, \"bar\"] }, \"foo.js\"); // true\n * ModuleFilenameHelpers.matchObject({ test: [/^foo/, \"bar\"] }, \"baz.js\"); // false\n * ModuleFilenameHelpers.matchObject({ include: \"foo.js\" }, \"foo.js\"); // true\n * ModuleFilenameHelpers.matchObject({ include: \"foo.js\" }, \"bar.js\"); // false\n * ModuleFilenameHelpers.matchObject({ include: /^foo/ }, \"foo.js\"); // true\n * ModuleFilenameHelpers.matchObject({ include: [/^foo/, \"bar\"] }, \"foo.js\"); // true\n * ModuleFilenameHelpers.matchObject({ include: [/^foo/, \"bar\"] }, \"baz.js\"); // false\n * ModuleFilenameHelpers.matchObject({ exclude: \"foo.js\" }, \"foo.js\"); // false\n * ModuleFilenameHelpers.matchObject({ exclude: [/^foo/, \"bar\"] }, \"foo.js\"); // false\n * ```\n */\nModuleFilenameHelpers.matchObject = (obj, str) => {\n\tif (obj.test && !ModuleFilenameHelpers.matchPart(str, obj.test)) {\n\t\treturn false;\n\t}\n\tif (obj.include && !ModuleFilenameHelpers.matchPart(str, obj.include)) {\n\t\treturn false;\n\t}\n\tif (obj.exclude && ModuleFilenameHelpers.matchPart(str, obj.exclude)) {\n\t\treturn false;\n\t}\n\treturn true;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}