{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst ChunkGraph = require(\"../ChunkGraph\");\nconst ModuleGraph = require(\"../ModuleGraph\");\nconst {\n  STAGE_DEFAULT\n} = require(\"../OptimizationStages\");\nconst HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\nconst {\n  compareModulesByIdentifier\n} = require(\"../util/comparators\");\nconst {\n  intersectRuntime,\n  mergeRuntimeOwned,\n  filterRuntime,\n  runtimeToString,\n  mergeRuntime\n} = require(\"../util/runtime\");\nconst ConcatenatedModule = require(\"./ConcatenatedModule\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Module\").BuildInfo} BuildInfo */\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {object} Statistics\n * @property {number} cached\n * @property {number} alreadyInConfig\n * @property {number} invalidModule\n * @property {number} incorrectChunks\n * @property {number} incorrectDependency\n * @property {number} incorrectModuleDependency\n * @property {number} incorrectChunksOfImporter\n * @property {number} incorrectRuntimeCondition\n * @property {number} importerFailed\n * @property {number} added\n */\n\n/**\n * @param {string} msg message\n * @returns {string} formatted message\n */\nconst formatBailoutReason = msg => `ModuleConcatenation bailout: ${msg}`;\nclass ModuleConcatenationPlugin {\n  /**\n   * Apply the plugin\n   * @param {Compiler} compiler the compiler instance\n   * @returns {void}\n   */\n  apply(compiler) {\n    const {\n      _backCompat: backCompat\n    } = compiler;\n    compiler.hooks.compilation.tap(\"ModuleConcatenationPlugin\", compilation => {\n      if (compilation.moduleMemCaches) {\n        throw new Error(\"optimization.concatenateModules can't be used with cacheUnaffected as module concatenation is a global effect\");\n      }\n      const moduleGraph = compilation.moduleGraph;\n      /** @type {Map<Module, string | ((requestShortener: RequestShortener) => string)>} */\n      const bailoutReasonMap = new Map();\n\n      /**\n       * @param {Module} module the module\n       * @param {string | ((requestShortener: RequestShortener) => string)} reason the reason\n       */\n      const setBailoutReason = (module, reason) => {\n        setInnerBailoutReason(module, reason);\n        moduleGraph.getOptimizationBailout(module).push(typeof reason === \"function\" ? rs => formatBailoutReason(reason(rs)) : formatBailoutReason(reason));\n      };\n\n      /**\n       * @param {Module} module the module\n       * @param {string | ((requestShortener: RequestShortener) => string)} reason the reason\n       */\n      const setInnerBailoutReason = (module, reason) => {\n        bailoutReasonMap.set(module, reason);\n      };\n\n      /**\n       * @param {Module} module the module\n       * @param {RequestShortener} requestShortener the request shortener\n       * @returns {string | ((requestShortener: RequestShortener) => string) | undefined} the reason\n       */\n      const getInnerBailoutReason = (module, requestShortener) => {\n        const reason = bailoutReasonMap.get(module);\n        if (typeof reason === \"function\") return reason(requestShortener);\n        return reason;\n      };\n\n      /**\n       * @param {Module} module the module\n       * @param {Module | function(RequestShortener): string} problem the problem\n       * @returns {(requestShortener: RequestShortener) => string} the reason\n       */\n      const formatBailoutWarning = (module, problem) => requestShortener => {\n        if (typeof problem === \"function\") {\n          return formatBailoutReason(`Cannot concat with ${module.readableIdentifier(requestShortener)}: ${problem(requestShortener)}`);\n        }\n        const reason = getInnerBailoutReason(module, requestShortener);\n        const reasonWithPrefix = reason ? `: ${reason}` : \"\";\n        if (module === problem) {\n          return formatBailoutReason(`Cannot concat with ${module.readableIdentifier(requestShortener)}${reasonWithPrefix}`);\n        }\n        return formatBailoutReason(`Cannot concat with ${module.readableIdentifier(requestShortener)} because of ${problem.readableIdentifier(requestShortener)}${reasonWithPrefix}`);\n      };\n      compilation.hooks.optimizeChunkModules.tapAsync({\n        name: \"ModuleConcatenationPlugin\",\n        stage: STAGE_DEFAULT\n      }, (allChunks, modules, callback) => {\n        const logger = compilation.getLogger(\"webpack.ModuleConcatenationPlugin\");\n        const {\n          chunkGraph,\n          moduleGraph\n        } = compilation;\n        const relevantModules = [];\n        const possibleInners = new Set();\n        const context = {\n          chunkGraph,\n          moduleGraph\n        };\n        logger.time(\"select relevant modules\");\n        for (const module of modules) {\n          let canBeRoot = true;\n          let canBeInner = true;\n          const bailoutReason = module.getConcatenationBailoutReason(context);\n          if (bailoutReason) {\n            setBailoutReason(module, bailoutReason);\n            continue;\n          }\n\n          // Must not be an async module\n          if (moduleGraph.isAsync(module)) {\n            setBailoutReason(module, \"Module is async\");\n            continue;\n          }\n\n          // Must be in strict mode\n          if (!(/** @type {BuildInfo} */module.buildInfo.strict)) {\n            setBailoutReason(module, \"Module is not in strict mode\");\n            continue;\n          }\n\n          // Module must be in any chunk (we don't want to do useless work)\n          if (chunkGraph.getNumberOfModuleChunks(module) === 0) {\n            setBailoutReason(module, \"Module is not in any chunk\");\n            continue;\n          }\n\n          // Exports must be known (and not dynamic)\n          const exportsInfo = moduleGraph.getExportsInfo(module);\n          const relevantExports = exportsInfo.getRelevantExports(undefined);\n          const unknownReexports = relevantExports.filter(exportInfo => exportInfo.isReexport() && !exportInfo.getTarget(moduleGraph));\n          if (unknownReexports.length > 0) {\n            setBailoutReason(module, `Reexports in this module do not have a static target (${Array.from(unknownReexports, exportInfo => `${exportInfo.name || \"other exports\"}: ${exportInfo.getUsedInfo()}`).join(\", \")})`);\n            continue;\n          }\n\n          // Root modules must have a static list of exports\n          const unknownProvidedExports = relevantExports.filter(exportInfo => exportInfo.provided !== true);\n          if (unknownProvidedExports.length > 0) {\n            setBailoutReason(module, `List of module exports is dynamic (${Array.from(unknownProvidedExports, exportInfo => `${exportInfo.name || \"other exports\"}: ${exportInfo.getProvidedInfo()} and ${exportInfo.getUsedInfo()}`).join(\", \")})`);\n            canBeRoot = false;\n          }\n\n          // Module must not be an entry point\n          if (chunkGraph.isEntryModule(module)) {\n            setInnerBailoutReason(module, \"Module is an entry point\");\n            canBeInner = false;\n          }\n          if (canBeRoot) relevantModules.push(module);\n          if (canBeInner) possibleInners.add(module);\n        }\n        logger.timeEnd(\"select relevant modules\");\n        logger.debug(`${relevantModules.length} potential root modules, ${possibleInners.size} potential inner modules`);\n        // sort by depth\n        // modules with lower depth are more likely suited as roots\n        // this improves performance, because modules already selected as inner are skipped\n        logger.time(\"sort relevant modules\");\n        relevantModules.sort((a, b) => /** @type {number} */moduleGraph.getDepth(a) - (/** @type {number} */moduleGraph.getDepth(b)));\n        logger.timeEnd(\"sort relevant modules\");\n\n        /** @type {Statistics} */\n        const stats = {\n          cached: 0,\n          alreadyInConfig: 0,\n          invalidModule: 0,\n          incorrectChunks: 0,\n          incorrectDependency: 0,\n          incorrectModuleDependency: 0,\n          incorrectChunksOfImporter: 0,\n          incorrectRuntimeCondition: 0,\n          importerFailed: 0,\n          added: 0\n        };\n        let statsCandidates = 0;\n        let statsSizeSum = 0;\n        let statsEmptyConfigurations = 0;\n        logger.time(\"find modules to concatenate\");\n        const concatConfigurations = [];\n        const usedAsInner = new Set();\n        for (const currentRoot of relevantModules) {\n          // when used by another configuration as inner:\n          // the other configuration is better and we can skip this one\n          // TODO reconsider that when it's only used in a different runtime\n          if (usedAsInner.has(currentRoot)) continue;\n          let chunkRuntime;\n          for (const r of chunkGraph.getModuleRuntimes(currentRoot)) {\n            chunkRuntime = mergeRuntimeOwned(chunkRuntime, r);\n          }\n          const exportsInfo = moduleGraph.getExportsInfo(currentRoot);\n          const filteredRuntime = filterRuntime(chunkRuntime, r => exportsInfo.isModuleUsed(r));\n          const activeRuntime = filteredRuntime === true ? chunkRuntime : filteredRuntime === false ? undefined : filteredRuntime;\n\n          // create a configuration with the root\n          const currentConfiguration = new ConcatConfiguration(currentRoot, activeRuntime);\n\n          // cache failures to add modules\n          const failureCache = new Map();\n\n          // potential optional import candidates\n          /** @type {Set<Module>} */\n          const candidates = new Set();\n\n          // try to add all imports\n          for (const imp of this._getImports(compilation, currentRoot, activeRuntime)) {\n            candidates.add(imp);\n          }\n          for (const imp of candidates) {\n            const impCandidates = new Set();\n            const problem = this._tryToAdd(compilation, currentConfiguration, imp, chunkRuntime, activeRuntime, possibleInners, impCandidates, failureCache, chunkGraph, true, stats);\n            if (problem) {\n              failureCache.set(imp, problem);\n              currentConfiguration.addWarning(imp, problem);\n            } else {\n              for (const c of impCandidates) {\n                candidates.add(c);\n              }\n            }\n          }\n          statsCandidates += candidates.size;\n          if (!currentConfiguration.isEmpty()) {\n            const modules = currentConfiguration.getModules();\n            statsSizeSum += modules.size;\n            concatConfigurations.push(currentConfiguration);\n            for (const module of modules) {\n              if (module !== currentConfiguration.rootModule) {\n                usedAsInner.add(module);\n              }\n            }\n          } else {\n            statsEmptyConfigurations++;\n            const optimizationBailouts = moduleGraph.getOptimizationBailout(currentRoot);\n            for (const warning of currentConfiguration.getWarningsSorted()) {\n              optimizationBailouts.push(formatBailoutWarning(warning[0], warning[1]));\n            }\n          }\n        }\n        logger.timeEnd(\"find modules to concatenate\");\n        logger.debug(`${concatConfigurations.length} successful concat configurations (avg size: ${statsSizeSum / concatConfigurations.length}), ${statsEmptyConfigurations} bailed out completely`);\n        logger.debug(`${statsCandidates} candidates were considered for adding (${stats.cached} cached failure, ${stats.alreadyInConfig} already in config, ${stats.invalidModule} invalid module, ${stats.incorrectChunks} incorrect chunks, ${stats.incorrectDependency} incorrect dependency, ${stats.incorrectChunksOfImporter} incorrect chunks of importer, ${stats.incorrectModuleDependency} incorrect module dependency, ${stats.incorrectRuntimeCondition} incorrect runtime condition, ${stats.importerFailed} importer failed, ${stats.added} added)`);\n        // HACK: Sort configurations by length and start with the longest one\n        // to get the biggest groups possible. Used modules are marked with usedModules\n        // TODO: Allow to reuse existing configuration while trying to add dependencies.\n        // This would improve performance. O(n^2) -> O(n)\n        logger.time(\"sort concat configurations\");\n        concatConfigurations.sort((a, b) => b.modules.size - a.modules.size);\n        logger.timeEnd(\"sort concat configurations\");\n        const usedModules = new Set();\n        logger.time(\"create concatenated modules\");\n        asyncLib.each(concatConfigurations, (concatConfiguration, callback) => {\n          const rootModule = concatConfiguration.rootModule;\n\n          // Avoid overlapping configurations\n          // TODO: remove this when todo above is fixed\n          if (usedModules.has(rootModule)) return callback();\n          const modules = concatConfiguration.getModules();\n          for (const m of modules) {\n            usedModules.add(m);\n          }\n\n          // Create a new ConcatenatedModule\n          ConcatenatedModule.getCompilationHooks(compilation);\n          const newModule = ConcatenatedModule.create(rootModule, modules, concatConfiguration.runtime, compilation, compiler.root, compilation.outputOptions.hashFunction);\n          const build = () => {\n            newModule.build(compiler.options, compilation, null, null, err => {\n              if (err) {\n                if (!err.module) {\n                  err.module = newModule;\n                }\n                return callback(err);\n              }\n              integrate();\n            });\n          };\n          const integrate = () => {\n            if (backCompat) {\n              ChunkGraph.setChunkGraphForModule(newModule, chunkGraph);\n              ModuleGraph.setModuleGraphForModule(newModule, moduleGraph);\n            }\n            for (const warning of concatConfiguration.getWarningsSorted()) {\n              moduleGraph.getOptimizationBailout(newModule).push(formatBailoutWarning(warning[0], warning[1]));\n            }\n            moduleGraph.cloneModuleAttributes(rootModule, newModule);\n            for (const m of modules) {\n              // add to builtModules when one of the included modules was built\n              if (compilation.builtModules.has(m)) {\n                compilation.builtModules.add(newModule);\n              }\n              if (m !== rootModule) {\n                // attach external references to the concatenated module too\n                moduleGraph.copyOutgoingModuleConnections(m, newModule, c => c.originModule === m && !(c.dependency instanceof HarmonyImportDependency && modules.has(c.module)));\n                // remove module from chunk\n                for (const chunk of chunkGraph.getModuleChunksIterable(rootModule)) {\n                  const sourceTypes = chunkGraph.getChunkModuleSourceTypes(chunk, m);\n                  if (sourceTypes.size === 1) {\n                    chunkGraph.disconnectChunkAndModule(chunk, m);\n                  } else {\n                    const newSourceTypes = new Set(sourceTypes);\n                    newSourceTypes.delete(\"javascript\");\n                    chunkGraph.setChunkModuleSourceTypes(chunk, m, newSourceTypes);\n                  }\n                }\n              }\n            }\n            compilation.modules.delete(rootModule);\n            ChunkGraph.clearChunkGraphForModule(rootModule);\n            ModuleGraph.clearModuleGraphForModule(rootModule);\n\n            // remove module from chunk\n            chunkGraph.replaceModule(rootModule, newModule);\n            // replace module references with the concatenated module\n            moduleGraph.moveModuleConnections(rootModule, newModule, c => {\n              const otherModule = c.module === rootModule ? c.originModule : c.module;\n              const innerConnection = c.dependency instanceof HarmonyImportDependency && modules.has(/** @type {Module} */otherModule);\n              return !innerConnection;\n            });\n            // add concatenated module to the compilation\n            compilation.modules.add(newModule);\n            callback();\n          };\n          build();\n        }, err => {\n          logger.timeEnd(\"create concatenated modules\");\n          process.nextTick(callback.bind(null, err));\n        });\n      });\n    });\n  }\n\n  /**\n   * @param {Compilation} compilation the compilation\n   * @param {Module} module the module to be added\n   * @param {RuntimeSpec} runtime the runtime scope\n   * @returns {Set<Module>} the imported modules\n   */\n  _getImports(compilation, module, runtime) {\n    const moduleGraph = compilation.moduleGraph;\n    const set = new Set();\n    for (const dep of module.dependencies) {\n      // Get reference info only for harmony Dependencies\n      if (!(dep instanceof HarmonyImportDependency)) continue;\n      const connection = moduleGraph.getConnection(dep);\n      // Reference is valid and has a module\n      if (!connection || !connection.module || !connection.isTargetActive(runtime)) {\n        continue;\n      }\n      const importedNames = compilation.getDependencyReferencedExports(dep, undefined);\n      if (importedNames.every(i => Array.isArray(i) ? i.length > 0 : i.name.length > 0) || Array.isArray(moduleGraph.getProvidedExports(module))) {\n        set.add(connection.module);\n      }\n    }\n    return set;\n  }\n\n  /**\n   * @param {Compilation} compilation webpack compilation\n   * @param {ConcatConfiguration} config concat configuration (will be modified when added)\n   * @param {Module} module the module to be added\n   * @param {RuntimeSpec} runtime the runtime scope of the generated code\n   * @param {RuntimeSpec} activeRuntime the runtime scope of the root module\n   * @param {Set<Module>} possibleModules modules that are candidates\n   * @param {Set<Module>} candidates list of potential candidates (will be added to)\n   * @param {Map<Module, Module | function(RequestShortener): string>} failureCache cache for problematic modules to be more performant\n   * @param {ChunkGraph} chunkGraph the chunk graph\n   * @param {boolean} avoidMutateOnFailure avoid mutating the config when adding fails\n   * @param {Statistics} statistics gathering metrics\n   * @returns {null | Module | function(RequestShortener): string} the problematic module\n   */\n  _tryToAdd(compilation, config, module, runtime, activeRuntime, possibleModules, candidates, failureCache, chunkGraph, avoidMutateOnFailure, statistics) {\n    const cacheEntry = failureCache.get(module);\n    if (cacheEntry) {\n      statistics.cached++;\n      return cacheEntry;\n    }\n\n    // Already added?\n    if (config.has(module)) {\n      statistics.alreadyInConfig++;\n      return null;\n    }\n\n    // Not possible to add?\n    if (!possibleModules.has(module)) {\n      statistics.invalidModule++;\n      failureCache.set(module, module); // cache failures for performance\n      return module;\n    }\n\n    // Module must be in the correct chunks\n    const missingChunks = Array.from(chunkGraph.getModuleChunksIterable(config.rootModule)).filter(chunk => !chunkGraph.isModuleInChunk(module, chunk));\n    if (missingChunks.length > 0) {\n      /**\n       * @param {RequestShortener} requestShortener request shortener\n       * @returns {string} problem description\n       */\n      const problem = requestShortener => {\n        const missingChunksList = Array.from(new Set(missingChunks.map(chunk => chunk.name || \"unnamed chunk(s)\"))).sort();\n        const chunks = Array.from(new Set(Array.from(chunkGraph.getModuleChunksIterable(module)).map(chunk => chunk.name || \"unnamed chunk(s)\"))).sort();\n        return `Module ${module.readableIdentifier(requestShortener)} is not in the same chunk(s) (expected in chunk(s) ${missingChunksList.join(\", \")}, module is in chunk(s) ${chunks.join(\", \")})`;\n      };\n      statistics.incorrectChunks++;\n      failureCache.set(module, problem); // cache failures for performance\n      return problem;\n    }\n    const moduleGraph = compilation.moduleGraph;\n    const incomingConnections = moduleGraph.getIncomingConnectionsByOriginModule(module);\n    const incomingConnectionsFromNonModules = incomingConnections.get(null) || incomingConnections.get(undefined);\n    if (incomingConnectionsFromNonModules) {\n      const activeNonModulesConnections = incomingConnectionsFromNonModules.filter(connection =>\n      // We are not interested in inactive connections\n      // or connections without dependency\n      connection.isActive(runtime));\n      if (activeNonModulesConnections.length > 0) {\n        /**\n         * @param {RequestShortener} requestShortener request shortener\n         * @returns {string} problem description\n         */\n        const problem = requestShortener => {\n          const importingExplanations = new Set(activeNonModulesConnections.map(c => c.explanation).filter(Boolean));\n          const explanations = Array.from(importingExplanations).sort();\n          return `Module ${module.readableIdentifier(requestShortener)} is referenced ${explanations.length > 0 ? `by: ${explanations.join(\", \")}` : \"in an unsupported way\"}`;\n        };\n        statistics.incorrectDependency++;\n        failureCache.set(module, problem); // cache failures for performance\n        return problem;\n      }\n    }\n\n    /** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n    const incomingConnectionsFromModules = new Map();\n    for (const [originModule, connections] of incomingConnections) {\n      if (originModule) {\n        // Ignore connection from orphan modules\n        if (chunkGraph.getNumberOfModuleChunks(originModule) === 0) continue;\n\n        // We don't care for connections from other runtimes\n        let originRuntime;\n        for (const r of chunkGraph.getModuleRuntimes(originModule)) {\n          originRuntime = mergeRuntimeOwned(originRuntime, r);\n        }\n        if (!intersectRuntime(runtime, originRuntime)) continue;\n\n        // We are not interested in inactive connections\n        const activeConnections = connections.filter(connection => connection.isActive(runtime));\n        if (activeConnections.length > 0) incomingConnectionsFromModules.set(originModule, activeConnections);\n      }\n    }\n    const incomingModules = Array.from(incomingConnectionsFromModules.keys());\n\n    // Module must be in the same chunks like the referencing module\n    const otherChunkModules = incomingModules.filter(originModule => {\n      for (const chunk of chunkGraph.getModuleChunksIterable(config.rootModule)) {\n        if (!chunkGraph.isModuleInChunk(originModule, chunk)) {\n          return true;\n        }\n      }\n      return false;\n    });\n    if (otherChunkModules.length > 0) {\n      /**\n       * @param {RequestShortener} requestShortener request shortener\n       * @returns {string} problem description\n       */\n      const problem = requestShortener => {\n        const names = otherChunkModules.map(m => m.readableIdentifier(requestShortener)).sort();\n        return `Module ${module.readableIdentifier(requestShortener)} is referenced from different chunks by these modules: ${names.join(\", \")}`;\n      };\n      statistics.incorrectChunksOfImporter++;\n      failureCache.set(module, problem); // cache failures for performance\n      return problem;\n    }\n\n    /** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n    const nonHarmonyConnections = new Map();\n    for (const [originModule, connections] of incomingConnectionsFromModules) {\n      const selected = connections.filter(connection => !connection.dependency || !(connection.dependency instanceof HarmonyImportDependency));\n      if (selected.length > 0) nonHarmonyConnections.set(originModule, connections);\n    }\n    if (nonHarmonyConnections.size > 0) {\n      /**\n       * @param {RequestShortener} requestShortener request shortener\n       * @returns {string} problem description\n       */\n      const problem = requestShortener => {\n        const names = Array.from(nonHarmonyConnections).map(([originModule, connections]) => `${originModule.readableIdentifier(requestShortener)} (referenced with ${Array.from(new Set(connections.map(c => c.dependency && c.dependency.type).filter(Boolean))).sort().join(\", \")})`).sort();\n        return `Module ${module.readableIdentifier(requestShortener)} is referenced from these modules with unsupported syntax: ${names.join(\", \")}`;\n      };\n      statistics.incorrectModuleDependency++;\n      failureCache.set(module, problem); // cache failures for performance\n      return problem;\n    }\n    if (runtime !== undefined && typeof runtime !== \"string\") {\n      // Module must be consistently referenced in the same runtimes\n      /** @type {{ originModule: Module, runtimeCondition: RuntimeSpec }[]} */\n      const otherRuntimeConnections = [];\n      outer: for (const [originModule, connections] of incomingConnectionsFromModules) {\n        /** @type {false | RuntimeSpec} */\n        let currentRuntimeCondition = false;\n        for (const connection of connections) {\n          const runtimeCondition = filterRuntime(runtime, runtime => connection.isTargetActive(runtime));\n          if (runtimeCondition === false) continue;\n          if (runtimeCondition === true) continue outer;\n          currentRuntimeCondition = currentRuntimeCondition !== false ? mergeRuntime(currentRuntimeCondition, runtimeCondition) : runtimeCondition;\n        }\n        if (currentRuntimeCondition !== false) {\n          otherRuntimeConnections.push({\n            originModule,\n            runtimeCondition: currentRuntimeCondition\n          });\n        }\n      }\n      if (otherRuntimeConnections.length > 0) {\n        /**\n         * @param {RequestShortener} requestShortener request shortener\n         * @returns {string} problem description\n         */\n        const problem = requestShortener => `Module ${module.readableIdentifier(requestShortener)} is runtime-dependent referenced by these modules: ${Array.from(otherRuntimeConnections, ({\n          originModule,\n          runtimeCondition\n        }) => `${originModule.readableIdentifier(requestShortener)} (expected runtime ${runtimeToString(runtime)}, module is only referenced in ${runtimeToString(/** @type {RuntimeSpec} */runtimeCondition)})`).join(\", \")}`;\n        statistics.incorrectRuntimeCondition++;\n        failureCache.set(module, problem); // cache failures for performance\n        return problem;\n      }\n    }\n    let backup;\n    if (avoidMutateOnFailure) {\n      backup = config.snapshot();\n    }\n\n    // Add the module\n    config.add(module);\n    incomingModules.sort(compareModulesByIdentifier);\n\n    // Every module which depends on the added module must be in the configuration too.\n    for (const originModule of incomingModules) {\n      const problem = this._tryToAdd(compilation, config, originModule, runtime, activeRuntime, possibleModules, candidates, failureCache, chunkGraph, false, statistics);\n      if (problem) {\n        if (backup !== undefined) config.rollback(backup);\n        statistics.importerFailed++;\n        failureCache.set(module, problem); // cache failures for performance\n        return problem;\n      }\n    }\n\n    // Add imports to possible candidates list\n    for (const imp of this._getImports(compilation, module, runtime)) {\n      candidates.add(imp);\n    }\n    statistics.added++;\n    return null;\n  }\n}\nclass ConcatConfiguration {\n  /**\n   * @param {Module} rootModule the root module\n   * @param {RuntimeSpec} runtime the runtime\n   */\n  constructor(rootModule, runtime) {\n    this.rootModule = rootModule;\n    this.runtime = runtime;\n    /** @type {Set<Module>} */\n    this.modules = new Set();\n    this.modules.add(rootModule);\n    /** @type {Map<Module, Module | function(RequestShortener): string>} */\n    this.warnings = new Map();\n  }\n\n  /**\n   * @param {Module} module the module\n   */\n  add(module) {\n    this.modules.add(module);\n  }\n\n  /**\n   * @param {Module} module the module\n   * @returns {boolean} true, when the module is in the module set\n   */\n  has(module) {\n    return this.modules.has(module);\n  }\n  isEmpty() {\n    return this.modules.size === 1;\n  }\n\n  /**\n   * @param {Module} module the module\n   * @param {Module | function(RequestShortener): string} problem the problem\n   */\n  addWarning(module, problem) {\n    this.warnings.set(module, problem);\n  }\n\n  /**\n   * @returns {Map<Module, Module | function(RequestShortener): string>} warnings\n   */\n  getWarningsSorted() {\n    return new Map(Array.from(this.warnings).sort((a, b) => {\n      const ai = a[0].identifier();\n      const bi = b[0].identifier();\n      if (ai < bi) return -1;\n      if (ai > bi) return 1;\n      return 0;\n    }));\n  }\n\n  /**\n   * @returns {Set<Module>} modules as set\n   */\n  getModules() {\n    return this.modules;\n  }\n  snapshot() {\n    return this.modules.size;\n  }\n\n  /**\n   * @param {number} snapshot snapshot\n   */\n  rollback(snapshot) {\n    const modules = this.modules;\n    for (const m of modules) {\n      if (snapshot === 0) {\n        modules.delete(m);\n      } else {\n        snapshot--;\n      }\n    }\n  }\n}\nmodule.exports = ModuleConcatenationPlugin;","map":{"version":3,"names":["asyncLib","require","ChunkGraph","ModuleGraph","STAGE_DEFAULT","HarmonyImportDependency","compareModulesByIdentifier","intersectRuntime","mergeRuntimeOwned","filterRuntime","runtimeToString","mergeRuntime","ConcatenatedModule","formatBailoutReason","msg","ModuleConcatenationPlugin","apply","compiler","_backCompat","backCompat","hooks","compilation","tap","moduleMemCaches","Error","moduleGraph","bailoutReasonMap","Map","setBailoutReason","module","reason","setInnerBailoutReason","getOptimizationBailout","push","rs","set","getInnerBailoutReason","requestShortener","get","formatBailoutWarning","problem","readableIdentifier","reasonWithPrefix","optimizeChunkModules","tapAsync","name","stage","allChunks","modules","callback","logger","getLogger","chunkGraph","relevantModules","possibleInners","Set","context","time","canBeRoot","canBeInner","bailoutReason","getConcatenationBailoutReason","isAsync","buildInfo","strict","getNumberOfModuleChunks","exportsInfo","getExportsInfo","relevantExports","getRelevantExports","undefined","unknownReexports","filter","exportInfo","isReexport","getTarget","length","Array","from","getUsedInfo","join","unknownProvidedExports","provided","getProvidedInfo","isEntryModule","add","timeEnd","debug","size","sort","a","b","getDepth","stats","cached","alreadyInConfig","invalidModule","incorrectChunks","incorrectDependency","incorrectModuleDependency","incorrectChunksOfImporter","incorrectRuntimeCondition","importerFailed","added","statsCandidates","statsSizeSum","statsEmptyConfigurations","concatConfigurations","usedAsInner","currentRoot","has","chunkRuntime","r","getModuleRuntimes","filteredRuntime","isModuleUsed","activeRuntime","currentConfiguration","ConcatConfiguration","failureCache","candidates","imp","_getImports","impCandidates","_tryToAdd","addWarning","c","isEmpty","getModules","rootModule","optimizationBailouts","warning","getWarningsSorted","usedModules","each","concatConfiguration","m","getCompilationHooks","newModule","create","runtime","root","outputOptions","hashFunction","build","options","err","integrate","setChunkGraphForModule","setModuleGraphForModule","cloneModuleAttributes","builtModules","copyOutgoingModuleConnections","originModule","dependency","chunk","getModuleChunksIterable","sourceTypes","getChunkModuleSourceTypes","disconnectChunkAndModule","newSourceTypes","delete","setChunkModuleSourceTypes","clearChunkGraphForModule","clearModuleGraphForModule","replaceModule","moveModuleConnections","otherModule","innerConnection","process","nextTick","bind","dep","dependencies","connection","getConnection","isTargetActive","importedNames","getDependencyReferencedExports","every","i","isArray","getProvidedExports","config","possibleModules","avoidMutateOnFailure","statistics","cacheEntry","missingChunks","isModuleInChunk","missingChunksList","map","chunks","incomingConnections","getIncomingConnectionsByOriginModule","incomingConnectionsFromNonModules","activeNonModulesConnections","isActive","importingExplanations","explanation","Boolean","explanations","incomingConnectionsFromModules","connections","originRuntime","activeConnections","incomingModules","keys","otherChunkModules","names","nonHarmonyConnections","selected","type","otherRuntimeConnections","outer","currentRuntimeCondition","runtimeCondition","backup","snapshot","rollback","constructor","warnings","ai","identifier","bi","exports"],"sources":["C:/Users/james/Downloads/Mellowdies/mellowdies/node_modules/webpack/lib/optimize/ModuleConcatenationPlugin.js"],"sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\n\"use strict\";\n\nconst asyncLib = require(\"neo-async\");\nconst ChunkGraph = require(\"../ChunkGraph\");\nconst ModuleGraph = require(\"../ModuleGraph\");\nconst { STAGE_DEFAULT } = require(\"../OptimizationStages\");\nconst HarmonyImportDependency = require(\"../dependencies/HarmonyImportDependency\");\nconst { compareModulesByIdentifier } = require(\"../util/comparators\");\nconst {\n\tintersectRuntime,\n\tmergeRuntimeOwned,\n\tfilterRuntime,\n\truntimeToString,\n\tmergeRuntime\n} = require(\"../util/runtime\");\nconst ConcatenatedModule = require(\"./ConcatenatedModule\");\n\n/** @typedef {import(\"../Compilation\")} Compilation */\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Module\").BuildInfo} BuildInfo */\n/** @typedef {import(\"../RequestShortener\")} RequestShortener */\n/** @typedef {import(\"../util/runtime\").RuntimeSpec} RuntimeSpec */\n\n/**\n * @typedef {object} Statistics\n * @property {number} cached\n * @property {number} alreadyInConfig\n * @property {number} invalidModule\n * @property {number} incorrectChunks\n * @property {number} incorrectDependency\n * @property {number} incorrectModuleDependency\n * @property {number} incorrectChunksOfImporter\n * @property {number} incorrectRuntimeCondition\n * @property {number} importerFailed\n * @property {number} added\n */\n\n/**\n * @param {string} msg message\n * @returns {string} formatted message\n */\nconst formatBailoutReason = msg => `ModuleConcatenation bailout: ${msg}`;\n\nclass ModuleConcatenationPlugin {\n\t/**\n\t * Apply the plugin\n\t * @param {Compiler} compiler the compiler instance\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst { _backCompat: backCompat } = compiler;\n\t\tcompiler.hooks.compilation.tap(\"ModuleConcatenationPlugin\", compilation => {\n\t\t\tif (compilation.moduleMemCaches) {\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"optimization.concatenateModules can't be used with cacheUnaffected as module concatenation is a global effect\"\n\t\t\t\t);\n\t\t\t}\n\t\t\tconst moduleGraph = compilation.moduleGraph;\n\t\t\t/** @type {Map<Module, string | ((requestShortener: RequestShortener) => string)>} */\n\t\t\tconst bailoutReasonMap = new Map();\n\n\t\t\t/**\n\t\t\t * @param {Module} module the module\n\t\t\t * @param {string | ((requestShortener: RequestShortener) => string)} reason the reason\n\t\t\t */\n\t\t\tconst setBailoutReason = (module, reason) => {\n\t\t\t\tsetInnerBailoutReason(module, reason);\n\t\t\t\tmoduleGraph\n\t\t\t\t\t.getOptimizationBailout(module)\n\t\t\t\t\t.push(\n\t\t\t\t\t\ttypeof reason === \"function\"\n\t\t\t\t\t\t\t? rs => formatBailoutReason(reason(rs))\n\t\t\t\t\t\t\t: formatBailoutReason(reason)\n\t\t\t\t\t);\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * @param {Module} module the module\n\t\t\t * @param {string | ((requestShortener: RequestShortener) => string)} reason the reason\n\t\t\t */\n\t\t\tconst setInnerBailoutReason = (module, reason) => {\n\t\t\t\tbailoutReasonMap.set(module, reason);\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * @param {Module} module the module\n\t\t\t * @param {RequestShortener} requestShortener the request shortener\n\t\t\t * @returns {string | ((requestShortener: RequestShortener) => string) | undefined} the reason\n\t\t\t */\n\t\t\tconst getInnerBailoutReason = (module, requestShortener) => {\n\t\t\t\tconst reason = bailoutReasonMap.get(module);\n\t\t\t\tif (typeof reason === \"function\") return reason(requestShortener);\n\t\t\t\treturn reason;\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * @param {Module} module the module\n\t\t\t * @param {Module | function(RequestShortener): string} problem the problem\n\t\t\t * @returns {(requestShortener: RequestShortener) => string} the reason\n\t\t\t */\n\t\t\tconst formatBailoutWarning = (module, problem) => requestShortener => {\n\t\t\t\tif (typeof problem === \"function\") {\n\t\t\t\t\treturn formatBailoutReason(\n\t\t\t\t\t\t`Cannot concat with ${module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}: ${problem(requestShortener)}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tconst reason = getInnerBailoutReason(module, requestShortener);\n\t\t\t\tconst reasonWithPrefix = reason ? `: ${reason}` : \"\";\n\t\t\t\tif (module === problem) {\n\t\t\t\t\treturn formatBailoutReason(\n\t\t\t\t\t\t`Cannot concat with ${module.readableIdentifier(\n\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t)}${reasonWithPrefix}`\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn formatBailoutReason(\n\t\t\t\t\t`Cannot concat with ${module.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)} because of ${problem.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)}${reasonWithPrefix}`\n\t\t\t\t);\n\t\t\t};\n\n\t\t\tcompilation.hooks.optimizeChunkModules.tapAsync(\n\t\t\t\t{\n\t\t\t\t\tname: \"ModuleConcatenationPlugin\",\n\t\t\t\t\tstage: STAGE_DEFAULT\n\t\t\t\t},\n\t\t\t\t(allChunks, modules, callback) => {\n\t\t\t\t\tconst logger = compilation.getLogger(\n\t\t\t\t\t\t\"webpack.ModuleConcatenationPlugin\"\n\t\t\t\t\t);\n\t\t\t\t\tconst { chunkGraph, moduleGraph } = compilation;\n\t\t\t\t\tconst relevantModules = [];\n\t\t\t\t\tconst possibleInners = new Set();\n\t\t\t\t\tconst context = {\n\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t};\n\t\t\t\t\tlogger.time(\"select relevant modules\");\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tlet canBeRoot = true;\n\t\t\t\t\t\tlet canBeInner = true;\n\n\t\t\t\t\t\tconst bailoutReason = module.getConcatenationBailoutReason(context);\n\t\t\t\t\t\tif (bailoutReason) {\n\t\t\t\t\t\t\tsetBailoutReason(module, bailoutReason);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Must not be an async module\n\t\t\t\t\t\tif (moduleGraph.isAsync(module)) {\n\t\t\t\t\t\t\tsetBailoutReason(module, \"Module is async\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Must be in strict mode\n\t\t\t\t\t\tif (!(/** @type {BuildInfo} */ (module.buildInfo).strict)) {\n\t\t\t\t\t\t\tsetBailoutReason(module, \"Module is not in strict mode\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Module must be in any chunk (we don't want to do useless work)\n\t\t\t\t\t\tif (chunkGraph.getNumberOfModuleChunks(module) === 0) {\n\t\t\t\t\t\t\tsetBailoutReason(module, \"Module is not in any chunk\");\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Exports must be known (and not dynamic)\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(module);\n\t\t\t\t\t\tconst relevantExports = exportsInfo.getRelevantExports(undefined);\n\t\t\t\t\t\tconst unknownReexports = relevantExports.filter(\n\t\t\t\t\t\t\texportInfo =>\n\t\t\t\t\t\t\t\texportInfo.isReexport() && !exportInfo.getTarget(moduleGraph)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (unknownReexports.length > 0) {\n\t\t\t\t\t\t\tsetBailoutReason(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t`Reexports in this module do not have a static target (${Array.from(\n\t\t\t\t\t\t\t\t\tunknownReexports,\n\t\t\t\t\t\t\t\t\texportInfo =>\n\t\t\t\t\t\t\t\t\t\t`${\n\t\t\t\t\t\t\t\t\t\t\texportInfo.name || \"other exports\"\n\t\t\t\t\t\t\t\t\t\t}: ${exportInfo.getUsedInfo()}`\n\t\t\t\t\t\t\t\t).join(\", \")})`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Root modules must have a static list of exports\n\t\t\t\t\t\tconst unknownProvidedExports = relevantExports.filter(\n\t\t\t\t\t\t\texportInfo => exportInfo.provided !== true\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (unknownProvidedExports.length > 0) {\n\t\t\t\t\t\t\tsetBailoutReason(\n\t\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\t\t`List of module exports is dynamic (${Array.from(\n\t\t\t\t\t\t\t\t\tunknownProvidedExports,\n\t\t\t\t\t\t\t\t\texportInfo =>\n\t\t\t\t\t\t\t\t\t\t`${\n\t\t\t\t\t\t\t\t\t\t\texportInfo.name || \"other exports\"\n\t\t\t\t\t\t\t\t\t\t}: ${exportInfo.getProvidedInfo()} and ${exportInfo.getUsedInfo()}`\n\t\t\t\t\t\t\t\t).join(\", \")})`\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcanBeRoot = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Module must not be an entry point\n\t\t\t\t\t\tif (chunkGraph.isEntryModule(module)) {\n\t\t\t\t\t\t\tsetInnerBailoutReason(module, \"Module is an entry point\");\n\t\t\t\t\t\t\tcanBeInner = false;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (canBeRoot) relevantModules.push(module);\n\t\t\t\t\t\tif (canBeInner) possibleInners.add(module);\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"select relevant modules\");\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`${relevantModules.length} potential root modules, ${possibleInners.size} potential inner modules`\n\t\t\t\t\t);\n\t\t\t\t\t// sort by depth\n\t\t\t\t\t// modules with lower depth are more likely suited as roots\n\t\t\t\t\t// this improves performance, because modules already selected as inner are skipped\n\t\t\t\t\tlogger.time(\"sort relevant modules\");\n\t\t\t\t\trelevantModules.sort(\n\t\t\t\t\t\t(a, b) =>\n\t\t\t\t\t\t\t/** @type {number} */ (moduleGraph.getDepth(a)) -\n\t\t\t\t\t\t\t/** @type {number} */ (moduleGraph.getDepth(b))\n\t\t\t\t\t);\n\t\t\t\t\tlogger.timeEnd(\"sort relevant modules\");\n\n\t\t\t\t\t/** @type {Statistics} */\n\t\t\t\t\tconst stats = {\n\t\t\t\t\t\tcached: 0,\n\t\t\t\t\t\talreadyInConfig: 0,\n\t\t\t\t\t\tinvalidModule: 0,\n\t\t\t\t\t\tincorrectChunks: 0,\n\t\t\t\t\t\tincorrectDependency: 0,\n\t\t\t\t\t\tincorrectModuleDependency: 0,\n\t\t\t\t\t\tincorrectChunksOfImporter: 0,\n\t\t\t\t\t\tincorrectRuntimeCondition: 0,\n\t\t\t\t\t\timporterFailed: 0,\n\t\t\t\t\t\tadded: 0\n\t\t\t\t\t};\n\t\t\t\t\tlet statsCandidates = 0;\n\t\t\t\t\tlet statsSizeSum = 0;\n\t\t\t\t\tlet statsEmptyConfigurations = 0;\n\n\t\t\t\t\tlogger.time(\"find modules to concatenate\");\n\t\t\t\t\tconst concatConfigurations = [];\n\t\t\t\t\tconst usedAsInner = new Set();\n\t\t\t\t\tfor (const currentRoot of relevantModules) {\n\t\t\t\t\t\t// when used by another configuration as inner:\n\t\t\t\t\t\t// the other configuration is better and we can skip this one\n\t\t\t\t\t\t// TODO reconsider that when it's only used in a different runtime\n\t\t\t\t\t\tif (usedAsInner.has(currentRoot)) continue;\n\n\t\t\t\t\t\tlet chunkRuntime;\n\t\t\t\t\t\tfor (const r of chunkGraph.getModuleRuntimes(currentRoot)) {\n\t\t\t\t\t\t\tchunkRuntime = mergeRuntimeOwned(chunkRuntime, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst exportsInfo = moduleGraph.getExportsInfo(currentRoot);\n\t\t\t\t\t\tconst filteredRuntime = filterRuntime(chunkRuntime, r =>\n\t\t\t\t\t\t\texportsInfo.isModuleUsed(r)\n\t\t\t\t\t\t);\n\t\t\t\t\t\tconst activeRuntime =\n\t\t\t\t\t\t\tfilteredRuntime === true\n\t\t\t\t\t\t\t\t? chunkRuntime\n\t\t\t\t\t\t\t\t: filteredRuntime === false\n\t\t\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t\t\t: filteredRuntime;\n\n\t\t\t\t\t\t// create a configuration with the root\n\t\t\t\t\t\tconst currentConfiguration = new ConcatConfiguration(\n\t\t\t\t\t\t\tcurrentRoot,\n\t\t\t\t\t\t\tactiveRuntime\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// cache failures to add modules\n\t\t\t\t\t\tconst failureCache = new Map();\n\n\t\t\t\t\t\t// potential optional import candidates\n\t\t\t\t\t\t/** @type {Set<Module>} */\n\t\t\t\t\t\tconst candidates = new Set();\n\n\t\t\t\t\t\t// try to add all imports\n\t\t\t\t\t\tfor (const imp of this._getImports(\n\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\tcurrentRoot,\n\t\t\t\t\t\t\tactiveRuntime\n\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\tcandidates.add(imp);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const imp of candidates) {\n\t\t\t\t\t\t\tconst impCandidates = new Set();\n\t\t\t\t\t\t\tconst problem = this._tryToAdd(\n\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\tcurrentConfiguration,\n\t\t\t\t\t\t\t\timp,\n\t\t\t\t\t\t\t\tchunkRuntime,\n\t\t\t\t\t\t\t\tactiveRuntime,\n\t\t\t\t\t\t\t\tpossibleInners,\n\t\t\t\t\t\t\t\timpCandidates,\n\t\t\t\t\t\t\t\tfailureCache,\n\t\t\t\t\t\t\t\tchunkGraph,\n\t\t\t\t\t\t\t\ttrue,\n\t\t\t\t\t\t\t\tstats\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (problem) {\n\t\t\t\t\t\t\t\tfailureCache.set(imp, problem);\n\t\t\t\t\t\t\t\tcurrentConfiguration.addWarning(imp, problem);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tfor (const c of impCandidates) {\n\t\t\t\t\t\t\t\t\tcandidates.add(c);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstatsCandidates += candidates.size;\n\t\t\t\t\t\tif (!currentConfiguration.isEmpty()) {\n\t\t\t\t\t\t\tconst modules = currentConfiguration.getModules();\n\t\t\t\t\t\t\tstatsSizeSum += modules.size;\n\t\t\t\t\t\t\tconcatConfigurations.push(currentConfiguration);\n\t\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\t\tif (module !== currentConfiguration.rootModule) {\n\t\t\t\t\t\t\t\t\tusedAsInner.add(module);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstatsEmptyConfigurations++;\n\t\t\t\t\t\t\tconst optimizationBailouts =\n\t\t\t\t\t\t\t\tmoduleGraph.getOptimizationBailout(currentRoot);\n\t\t\t\t\t\t\tfor (const warning of currentConfiguration.getWarningsSorted()) {\n\t\t\t\t\t\t\t\toptimizationBailouts.push(\n\t\t\t\t\t\t\t\t\tformatBailoutWarning(warning[0], warning[1])\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlogger.timeEnd(\"find modules to concatenate\");\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`${\n\t\t\t\t\t\t\tconcatConfigurations.length\n\t\t\t\t\t\t} successful concat configurations (avg size: ${\n\t\t\t\t\t\t\tstatsSizeSum / concatConfigurations.length\n\t\t\t\t\t\t}), ${statsEmptyConfigurations} bailed out completely`\n\t\t\t\t\t);\n\t\t\t\t\tlogger.debug(\n\t\t\t\t\t\t`${statsCandidates} candidates were considered for adding (${stats.cached} cached failure, ${stats.alreadyInConfig} already in config, ${stats.invalidModule} invalid module, ${stats.incorrectChunks} incorrect chunks, ${stats.incorrectDependency} incorrect dependency, ${stats.incorrectChunksOfImporter} incorrect chunks of importer, ${stats.incorrectModuleDependency} incorrect module dependency, ${stats.incorrectRuntimeCondition} incorrect runtime condition, ${stats.importerFailed} importer failed, ${stats.added} added)`\n\t\t\t\t\t);\n\t\t\t\t\t// HACK: Sort configurations by length and start with the longest one\n\t\t\t\t\t// to get the biggest groups possible. Used modules are marked with usedModules\n\t\t\t\t\t// TODO: Allow to reuse existing configuration while trying to add dependencies.\n\t\t\t\t\t// This would improve performance. O(n^2) -> O(n)\n\t\t\t\t\tlogger.time(\"sort concat configurations\");\n\t\t\t\t\tconcatConfigurations.sort((a, b) => b.modules.size - a.modules.size);\n\t\t\t\t\tlogger.timeEnd(\"sort concat configurations\");\n\t\t\t\t\tconst usedModules = new Set();\n\n\t\t\t\t\tlogger.time(\"create concatenated modules\");\n\t\t\t\t\tasyncLib.each(\n\t\t\t\t\t\tconcatConfigurations,\n\t\t\t\t\t\t(concatConfiguration, callback) => {\n\t\t\t\t\t\t\tconst rootModule = concatConfiguration.rootModule;\n\n\t\t\t\t\t\t\t// Avoid overlapping configurations\n\t\t\t\t\t\t\t// TODO: remove this when todo above is fixed\n\t\t\t\t\t\t\tif (usedModules.has(rootModule)) return callback();\n\t\t\t\t\t\t\tconst modules = concatConfiguration.getModules();\n\t\t\t\t\t\t\tfor (const m of modules) {\n\t\t\t\t\t\t\t\tusedModules.add(m);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// Create a new ConcatenatedModule\n\t\t\t\t\t\t\tConcatenatedModule.getCompilationHooks(compilation);\n\t\t\t\t\t\t\tconst newModule = ConcatenatedModule.create(\n\t\t\t\t\t\t\t\trootModule,\n\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\tconcatConfiguration.runtime,\n\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\tcompiler.root,\n\t\t\t\t\t\t\t\tcompilation.outputOptions.hashFunction\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tconst build = () => {\n\t\t\t\t\t\t\t\tnewModule.build(\n\t\t\t\t\t\t\t\t\tcompiler.options,\n\t\t\t\t\t\t\t\t\tcompilation,\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\t\tif (!err.module) {\n\t\t\t\t\t\t\t\t\t\t\t\terr.module = newModule;\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\treturn callback(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tintegrate();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tconst integrate = () => {\n\t\t\t\t\t\t\t\tif (backCompat) {\n\t\t\t\t\t\t\t\t\tChunkGraph.setChunkGraphForModule(newModule, chunkGraph);\n\t\t\t\t\t\t\t\t\tModuleGraph.setModuleGraphForModule(newModule, moduleGraph);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tfor (const warning of concatConfiguration.getWarningsSorted()) {\n\t\t\t\t\t\t\t\t\tmoduleGraph\n\t\t\t\t\t\t\t\t\t\t.getOptimizationBailout(newModule)\n\t\t\t\t\t\t\t\t\t\t.push(formatBailoutWarning(warning[0], warning[1]));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmoduleGraph.cloneModuleAttributes(rootModule, newModule);\n\t\t\t\t\t\t\t\tfor (const m of modules) {\n\t\t\t\t\t\t\t\t\t// add to builtModules when one of the included modules was built\n\t\t\t\t\t\t\t\t\tif (compilation.builtModules.has(m)) {\n\t\t\t\t\t\t\t\t\t\tcompilation.builtModules.add(newModule);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (m !== rootModule) {\n\t\t\t\t\t\t\t\t\t\t// attach external references to the concatenated module too\n\t\t\t\t\t\t\t\t\t\tmoduleGraph.copyOutgoingModuleConnections(\n\t\t\t\t\t\t\t\t\t\t\tm,\n\t\t\t\t\t\t\t\t\t\t\tnewModule,\n\t\t\t\t\t\t\t\t\t\t\tc =>\n\t\t\t\t\t\t\t\t\t\t\t\tc.originModule === m &&\n\t\t\t\t\t\t\t\t\t\t\t\t!(\n\t\t\t\t\t\t\t\t\t\t\t\t\tc.dependency instanceof HarmonyImportDependency &&\n\t\t\t\t\t\t\t\t\t\t\t\t\tmodules.has(c.module)\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t// remove module from chunk\n\t\t\t\t\t\t\t\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(\n\t\t\t\t\t\t\t\t\t\t\trootModule\n\t\t\t\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\t\t\t\tconst sourceTypes = chunkGraph.getChunkModuleSourceTypes(\n\t\t\t\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\t\t\t\tm\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tif (sourceTypes.size === 1) {\n\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph.disconnectChunkAndModule(chunk, m);\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\tconst newSourceTypes = new Set(sourceTypes);\n\t\t\t\t\t\t\t\t\t\t\t\tnewSourceTypes.delete(\"javascript\");\n\t\t\t\t\t\t\t\t\t\t\t\tchunkGraph.setChunkModuleSourceTypes(\n\t\t\t\t\t\t\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\t\t\t\t\t\t\tm,\n\t\t\t\t\t\t\t\t\t\t\t\t\tnewSourceTypes\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcompilation.modules.delete(rootModule);\n\t\t\t\t\t\t\t\tChunkGraph.clearChunkGraphForModule(rootModule);\n\t\t\t\t\t\t\t\tModuleGraph.clearModuleGraphForModule(rootModule);\n\n\t\t\t\t\t\t\t\t// remove module from chunk\n\t\t\t\t\t\t\t\tchunkGraph.replaceModule(rootModule, newModule);\n\t\t\t\t\t\t\t\t// replace module references with the concatenated module\n\t\t\t\t\t\t\t\tmoduleGraph.moveModuleConnections(rootModule, newModule, c => {\n\t\t\t\t\t\t\t\t\tconst otherModule =\n\t\t\t\t\t\t\t\t\t\tc.module === rootModule ? c.originModule : c.module;\n\t\t\t\t\t\t\t\t\tconst innerConnection =\n\t\t\t\t\t\t\t\t\t\tc.dependency instanceof HarmonyImportDependency &&\n\t\t\t\t\t\t\t\t\t\tmodules.has(/** @type {Module} */ (otherModule));\n\t\t\t\t\t\t\t\t\treturn !innerConnection;\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t// add concatenated module to the compilation\n\t\t\t\t\t\t\t\tcompilation.modules.add(newModule);\n\n\t\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\tbuild();\n\t\t\t\t\t\t},\n\t\t\t\t\t\terr => {\n\t\t\t\t\t\t\tlogger.timeEnd(\"create concatenated modules\");\n\t\t\t\t\t\t\tprocess.nextTick(callback.bind(null, err));\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * @param {Compilation} compilation the compilation\n\t * @param {Module} module the module to be added\n\t * @param {RuntimeSpec} runtime the runtime scope\n\t * @returns {Set<Module>} the imported modules\n\t */\n\t_getImports(compilation, module, runtime) {\n\t\tconst moduleGraph = compilation.moduleGraph;\n\t\tconst set = new Set();\n\t\tfor (const dep of module.dependencies) {\n\t\t\t// Get reference info only for harmony Dependencies\n\t\t\tif (!(dep instanceof HarmonyImportDependency)) continue;\n\n\t\t\tconst connection = moduleGraph.getConnection(dep);\n\t\t\t// Reference is valid and has a module\n\t\t\tif (\n\t\t\t\t!connection ||\n\t\t\t\t!connection.module ||\n\t\t\t\t!connection.isTargetActive(runtime)\n\t\t\t) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst importedNames = compilation.getDependencyReferencedExports(\n\t\t\t\tdep,\n\t\t\t\tundefined\n\t\t\t);\n\n\t\t\tif (\n\t\t\t\timportedNames.every(i =>\n\t\t\t\t\tArray.isArray(i) ? i.length > 0 : i.name.length > 0\n\t\t\t\t) ||\n\t\t\t\tArray.isArray(moduleGraph.getProvidedExports(module))\n\t\t\t) {\n\t\t\t\tset.add(connection.module);\n\t\t\t}\n\t\t}\n\t\treturn set;\n\t}\n\n\t/**\n\t * @param {Compilation} compilation webpack compilation\n\t * @param {ConcatConfiguration} config concat configuration (will be modified when added)\n\t * @param {Module} module the module to be added\n\t * @param {RuntimeSpec} runtime the runtime scope of the generated code\n\t * @param {RuntimeSpec} activeRuntime the runtime scope of the root module\n\t * @param {Set<Module>} possibleModules modules that are candidates\n\t * @param {Set<Module>} candidates list of potential candidates (will be added to)\n\t * @param {Map<Module, Module | function(RequestShortener): string>} failureCache cache for problematic modules to be more performant\n\t * @param {ChunkGraph} chunkGraph the chunk graph\n\t * @param {boolean} avoidMutateOnFailure avoid mutating the config when adding fails\n\t * @param {Statistics} statistics gathering metrics\n\t * @returns {null | Module | function(RequestShortener): string} the problematic module\n\t */\n\t_tryToAdd(\n\t\tcompilation,\n\t\tconfig,\n\t\tmodule,\n\t\truntime,\n\t\tactiveRuntime,\n\t\tpossibleModules,\n\t\tcandidates,\n\t\tfailureCache,\n\t\tchunkGraph,\n\t\tavoidMutateOnFailure,\n\t\tstatistics\n\t) {\n\t\tconst cacheEntry = failureCache.get(module);\n\t\tif (cacheEntry) {\n\t\t\tstatistics.cached++;\n\t\t\treturn cacheEntry;\n\t\t}\n\n\t\t// Already added?\n\t\tif (config.has(module)) {\n\t\t\tstatistics.alreadyInConfig++;\n\t\t\treturn null;\n\t\t}\n\n\t\t// Not possible to add?\n\t\tif (!possibleModules.has(module)) {\n\t\t\tstatistics.invalidModule++;\n\t\t\tfailureCache.set(module, module); // cache failures for performance\n\t\t\treturn module;\n\t\t}\n\n\t\t// Module must be in the correct chunks\n\t\tconst missingChunks = Array.from(\n\t\t\tchunkGraph.getModuleChunksIterable(config.rootModule)\n\t\t).filter(chunk => !chunkGraph.isModuleInChunk(module, chunk));\n\t\tif (missingChunks.length > 0) {\n\t\t\t/**\n\t\t\t * @param {RequestShortener} requestShortener request shortener\n\t\t\t * @returns {string} problem description\n\t\t\t */\n\t\t\tconst problem = requestShortener => {\n\t\t\t\tconst missingChunksList = Array.from(\n\t\t\t\t\tnew Set(missingChunks.map(chunk => chunk.name || \"unnamed chunk(s)\"))\n\t\t\t\t).sort();\n\t\t\t\tconst chunks = Array.from(\n\t\t\t\t\tnew Set(\n\t\t\t\t\t\tArray.from(chunkGraph.getModuleChunksIterable(module)).map(\n\t\t\t\t\t\t\tchunk => chunk.name || \"unnamed chunk(s)\"\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t).sort();\n\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\trequestShortener\n\t\t\t\t)} is not in the same chunk(s) (expected in chunk(s) ${missingChunksList.join(\n\t\t\t\t\t\", \"\n\t\t\t\t)}, module is in chunk(s) ${chunks.join(\", \")})`;\n\t\t\t};\n\t\t\tstatistics.incorrectChunks++;\n\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\treturn problem;\n\t\t}\n\n\t\tconst moduleGraph = compilation.moduleGraph;\n\n\t\tconst incomingConnections =\n\t\t\tmoduleGraph.getIncomingConnectionsByOriginModule(module);\n\n\t\tconst incomingConnectionsFromNonModules =\n\t\t\tincomingConnections.get(null) || incomingConnections.get(undefined);\n\t\tif (incomingConnectionsFromNonModules) {\n\t\t\tconst activeNonModulesConnections =\n\t\t\t\tincomingConnectionsFromNonModules.filter(connection =>\n\t\t\t\t\t// We are not interested in inactive connections\n\t\t\t\t\t// or connections without dependency\n\t\t\t\t\tconnection.isActive(runtime)\n\t\t\t\t);\n\t\t\tif (activeNonModulesConnections.length > 0) {\n\t\t\t\t/**\n\t\t\t\t * @param {RequestShortener} requestShortener request shortener\n\t\t\t\t * @returns {string} problem description\n\t\t\t\t */\n\t\t\t\tconst problem = requestShortener => {\n\t\t\t\t\tconst importingExplanations = new Set(\n\t\t\t\t\t\tactiveNonModulesConnections.map(c => c.explanation).filter(Boolean)\n\t\t\t\t\t);\n\t\t\t\t\tconst explanations = Array.from(importingExplanations).sort();\n\t\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)} is referenced ${\n\t\t\t\t\t\texplanations.length > 0\n\t\t\t\t\t\t\t? `by: ${explanations.join(\", \")}`\n\t\t\t\t\t\t\t: \"in an unsupported way\"\n\t\t\t\t\t}`;\n\t\t\t\t};\n\t\t\t\tstatistics.incorrectDependency++;\n\t\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\t\treturn problem;\n\t\t\t}\n\t\t}\n\n\t\t/** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\t\tconst incomingConnectionsFromModules = new Map();\n\t\tfor (const [originModule, connections] of incomingConnections) {\n\t\t\tif (originModule) {\n\t\t\t\t// Ignore connection from orphan modules\n\t\t\t\tif (chunkGraph.getNumberOfModuleChunks(originModule) === 0) continue;\n\n\t\t\t\t// We don't care for connections from other runtimes\n\t\t\t\tlet originRuntime;\n\t\t\t\tfor (const r of chunkGraph.getModuleRuntimes(originModule)) {\n\t\t\t\t\toriginRuntime = mergeRuntimeOwned(originRuntime, r);\n\t\t\t\t}\n\n\t\t\t\tif (!intersectRuntime(runtime, originRuntime)) continue;\n\n\t\t\t\t// We are not interested in inactive connections\n\t\t\t\tconst activeConnections = connections.filter(connection =>\n\t\t\t\t\tconnection.isActive(runtime)\n\t\t\t\t);\n\t\t\t\tif (activeConnections.length > 0)\n\t\t\t\t\tincomingConnectionsFromModules.set(originModule, activeConnections);\n\t\t\t}\n\t\t}\n\n\t\tconst incomingModules = Array.from(incomingConnectionsFromModules.keys());\n\n\t\t// Module must be in the same chunks like the referencing module\n\t\tconst otherChunkModules = incomingModules.filter(originModule => {\n\t\t\tfor (const chunk of chunkGraph.getModuleChunksIterable(\n\t\t\t\tconfig.rootModule\n\t\t\t)) {\n\t\t\t\tif (!chunkGraph.isModuleInChunk(originModule, chunk)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\tif (otherChunkModules.length > 0) {\n\t\t\t/**\n\t\t\t * @param {RequestShortener} requestShortener request shortener\n\t\t\t * @returns {string} problem description\n\t\t\t */\n\t\t\tconst problem = requestShortener => {\n\t\t\t\tconst names = otherChunkModules\n\t\t\t\t\t.map(m => m.readableIdentifier(requestShortener))\n\t\t\t\t\t.sort();\n\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\trequestShortener\n\t\t\t\t)} is referenced from different chunks by these modules: ${names.join(\n\t\t\t\t\t\", \"\n\t\t\t\t)}`;\n\t\t\t};\n\t\t\tstatistics.incorrectChunksOfImporter++;\n\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\treturn problem;\n\t\t}\n\n\t\t/** @type {Map<Module, readonly ModuleGraph.ModuleGraphConnection[]>} */\n\t\tconst nonHarmonyConnections = new Map();\n\t\tfor (const [originModule, connections] of incomingConnectionsFromModules) {\n\t\t\tconst selected = connections.filter(\n\t\t\t\tconnection =>\n\t\t\t\t\t!connection.dependency ||\n\t\t\t\t\t!(connection.dependency instanceof HarmonyImportDependency)\n\t\t\t);\n\t\t\tif (selected.length > 0)\n\t\t\t\tnonHarmonyConnections.set(originModule, connections);\n\t\t}\n\t\tif (nonHarmonyConnections.size > 0) {\n\t\t\t/**\n\t\t\t * @param {RequestShortener} requestShortener request shortener\n\t\t\t * @returns {string} problem description\n\t\t\t */\n\t\t\tconst problem = requestShortener => {\n\t\t\t\tconst names = Array.from(nonHarmonyConnections)\n\t\t\t\t\t.map(\n\t\t\t\t\t\t([originModule, connections]) =>\n\t\t\t\t\t\t\t`${originModule.readableIdentifier(\n\t\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t\t)} (referenced with ${Array.from(\n\t\t\t\t\t\t\t\tnew Set(\n\t\t\t\t\t\t\t\t\tconnections\n\t\t\t\t\t\t\t\t\t\t.map(c => c.dependency && c.dependency.type)\n\t\t\t\t\t\t\t\t\t\t.filter(Boolean)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t.sort()\n\t\t\t\t\t\t\t\t.join(\", \")})`\n\t\t\t\t\t)\n\t\t\t\t\t.sort();\n\t\t\t\treturn `Module ${module.readableIdentifier(\n\t\t\t\t\trequestShortener\n\t\t\t\t)} is referenced from these modules with unsupported syntax: ${names.join(\n\t\t\t\t\t\", \"\n\t\t\t\t)}`;\n\t\t\t};\n\t\t\tstatistics.incorrectModuleDependency++;\n\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\treturn problem;\n\t\t}\n\n\t\tif (runtime !== undefined && typeof runtime !== \"string\") {\n\t\t\t// Module must be consistently referenced in the same runtimes\n\t\t\t/** @type {{ originModule: Module, runtimeCondition: RuntimeSpec }[]} */\n\t\t\tconst otherRuntimeConnections = [];\n\t\t\touter: for (const [\n\t\t\t\toriginModule,\n\t\t\t\tconnections\n\t\t\t] of incomingConnectionsFromModules) {\n\t\t\t\t/** @type {false | RuntimeSpec} */\n\t\t\t\tlet currentRuntimeCondition = false;\n\t\t\t\tfor (const connection of connections) {\n\t\t\t\t\tconst runtimeCondition = filterRuntime(runtime, runtime =>\n\t\t\t\t\t\tconnection.isTargetActive(runtime)\n\t\t\t\t\t);\n\t\t\t\t\tif (runtimeCondition === false) continue;\n\t\t\t\t\tif (runtimeCondition === true) continue outer;\n\t\t\t\t\tcurrentRuntimeCondition =\n\t\t\t\t\t\tcurrentRuntimeCondition !== false\n\t\t\t\t\t\t\t? mergeRuntime(currentRuntimeCondition, runtimeCondition)\n\t\t\t\t\t\t\t: runtimeCondition;\n\t\t\t\t}\n\t\t\t\tif (currentRuntimeCondition !== false) {\n\t\t\t\t\totherRuntimeConnections.push({\n\t\t\t\t\t\toriginModule,\n\t\t\t\t\t\truntimeCondition: currentRuntimeCondition\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (otherRuntimeConnections.length > 0) {\n\t\t\t\t/**\n\t\t\t\t * @param {RequestShortener} requestShortener request shortener\n\t\t\t\t * @returns {string} problem description\n\t\t\t\t */\n\t\t\t\tconst problem = requestShortener =>\n\t\t\t\t\t`Module ${module.readableIdentifier(\n\t\t\t\t\t\trequestShortener\n\t\t\t\t\t)} is runtime-dependent referenced by these modules: ${Array.from(\n\t\t\t\t\t\totherRuntimeConnections,\n\t\t\t\t\t\t({ originModule, runtimeCondition }) =>\n\t\t\t\t\t\t\t`${originModule.readableIdentifier(\n\t\t\t\t\t\t\t\trequestShortener\n\t\t\t\t\t\t\t)} (expected runtime ${runtimeToString(\n\t\t\t\t\t\t\t\truntime\n\t\t\t\t\t\t\t)}, module is only referenced in ${runtimeToString(\n\t\t\t\t\t\t\t\t/** @type {RuntimeSpec} */ (runtimeCondition)\n\t\t\t\t\t\t\t)})`\n\t\t\t\t\t).join(\", \")}`;\n\t\t\t\tstatistics.incorrectRuntimeCondition++;\n\t\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\t\treturn problem;\n\t\t\t}\n\t\t}\n\n\t\tlet backup;\n\t\tif (avoidMutateOnFailure) {\n\t\t\tbackup = config.snapshot();\n\t\t}\n\n\t\t// Add the module\n\t\tconfig.add(module);\n\n\t\tincomingModules.sort(compareModulesByIdentifier);\n\n\t\t// Every module which depends on the added module must be in the configuration too.\n\t\tfor (const originModule of incomingModules) {\n\t\t\tconst problem = this._tryToAdd(\n\t\t\t\tcompilation,\n\t\t\t\tconfig,\n\t\t\t\toriginModule,\n\t\t\t\truntime,\n\t\t\t\tactiveRuntime,\n\t\t\t\tpossibleModules,\n\t\t\t\tcandidates,\n\t\t\t\tfailureCache,\n\t\t\t\tchunkGraph,\n\t\t\t\tfalse,\n\t\t\t\tstatistics\n\t\t\t);\n\t\t\tif (problem) {\n\t\t\t\tif (backup !== undefined) config.rollback(backup);\n\t\t\t\tstatistics.importerFailed++;\n\t\t\t\tfailureCache.set(module, problem); // cache failures for performance\n\t\t\t\treturn problem;\n\t\t\t}\n\t\t}\n\n\t\t// Add imports to possible candidates list\n\t\tfor (const imp of this._getImports(compilation, module, runtime)) {\n\t\t\tcandidates.add(imp);\n\t\t}\n\t\tstatistics.added++;\n\t\treturn null;\n\t}\n}\n\nclass ConcatConfiguration {\n\t/**\n\t * @param {Module} rootModule the root module\n\t * @param {RuntimeSpec} runtime the runtime\n\t */\n\tconstructor(rootModule, runtime) {\n\t\tthis.rootModule = rootModule;\n\t\tthis.runtime = runtime;\n\t\t/** @type {Set<Module>} */\n\t\tthis.modules = new Set();\n\t\tthis.modules.add(rootModule);\n\t\t/** @type {Map<Module, Module | function(RequestShortener): string>} */\n\t\tthis.warnings = new Map();\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t */\n\tadd(module) {\n\t\tthis.modules.add(module);\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @returns {boolean} true, when the module is in the module set\n\t */\n\thas(module) {\n\t\treturn this.modules.has(module);\n\t}\n\n\tisEmpty() {\n\t\treturn this.modules.size === 1;\n\t}\n\n\t/**\n\t * @param {Module} module the module\n\t * @param {Module | function(RequestShortener): string} problem the problem\n\t */\n\taddWarning(module, problem) {\n\t\tthis.warnings.set(module, problem);\n\t}\n\n\t/**\n\t * @returns {Map<Module, Module | function(RequestShortener): string>} warnings\n\t */\n\tgetWarningsSorted() {\n\t\treturn new Map(\n\t\t\tArray.from(this.warnings).sort((a, b) => {\n\t\t\t\tconst ai = a[0].identifier();\n\t\t\t\tconst bi = b[0].identifier();\n\t\t\t\tif (ai < bi) return -1;\n\t\t\t\tif (ai > bi) return 1;\n\t\t\t\treturn 0;\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * @returns {Set<Module>} modules as set\n\t */\n\tgetModules() {\n\t\treturn this.modules;\n\t}\n\n\tsnapshot() {\n\t\treturn this.modules.size;\n\t}\n\n\t/**\n\t * @param {number} snapshot snapshot\n\t */\n\trollback(snapshot) {\n\t\tconst modules = this.modules;\n\t\tfor (const m of modules) {\n\t\t\tif (snapshot === 0) {\n\t\t\t\tmodules.delete(m);\n\t\t\t} else {\n\t\t\t\tsnapshot--;\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = ModuleConcatenationPlugin;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}